 export default /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/deeplearn/dist/src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/deeplearn/dist/src/data/checkpoint_loader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/data/checkpoint_loader.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar MANIFEST_FILE = 'manifest.json';\nvar CheckpointLoader = (function () {\n    function CheckpointLoader(urlPath) {\n        this.urlPath = urlPath;\n        if (this.urlPath.charAt(this.urlPath.length - 1) !== '/') {\n            this.urlPath += '/';\n        }\n    }\n    CheckpointLoader.prototype.loadManifest = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', _this.urlPath + MANIFEST_FILE);\n            xhr.onload = function () {\n                _this.checkpointManifest = JSON.parse(xhr.responseText);\n                resolve();\n            };\n            xhr.onerror = function (error) {\n                throw new Error(MANIFEST_FILE + \" not found at \" + _this.urlPath + \". \" + error);\n            };\n            xhr.send();\n        });\n    };\n    CheckpointLoader.prototype.getCheckpointManifest = function () {\n        var _this = this;\n        if (this.checkpointManifest == null) {\n            return new Promise(function (resolve, reject) {\n                _this.loadManifest().then(function () {\n                    resolve(_this.checkpointManifest);\n                });\n            });\n        }\n        return new Promise(function (resolve, reject) {\n            resolve(_this.checkpointManifest);\n        });\n    };\n    CheckpointLoader.prototype.getAllVariables = function () {\n        var _this = this;\n        if (this.variables != null) {\n            return new Promise(function (resolve, reject) {\n                resolve(_this.variables);\n            });\n        }\n        return new Promise(function (resolve, reject) {\n            _this.getCheckpointManifest().then(function (checkpointDefinition) {\n                var variableNames = Object.keys(_this.checkpointManifest);\n                var variablePromises = [];\n                for (var i = 0; i < variableNames.length; i++) {\n                    variablePromises.push(_this.getVariable(variableNames[i]));\n                }\n                Promise.all(variablePromises).then(function (variables) {\n                    _this.variables = {};\n                    for (var i = 0; i < variables.length; i++) {\n                        _this.variables[variableNames[i]] = variables[i];\n                    }\n                    resolve(_this.variables);\n                });\n            });\n        });\n    };\n    CheckpointLoader.prototype.getVariable = function (varName) {\n        var _this = this;\n        if (!(varName in this.checkpointManifest)) {\n            throw new Error('Cannot load non-existant variable ' + varName);\n        }\n        var variableRequestPromiseMethod = function (resolve, reject) {\n            var xhr = new XMLHttpRequest();\n            xhr.responseType = 'arraybuffer';\n            var fname = _this.checkpointManifest[varName].filename;\n            xhr.open('GET', _this.urlPath + fname);\n            xhr.onload = function () {\n                var values = new Float32Array(xhr.response);\n                var ndarray = ndarray_1.NDArray.make(_this.checkpointManifest[varName].shape, { values: values });\n                resolve(ndarray);\n            };\n            xhr.onerror = function (error) {\n                throw new Error('Could not fetch variable ' + varName + ': ' + error);\n            };\n            xhr.send();\n        };\n        if (this.checkpointManifest == null) {\n            return new Promise(function (resolve, reject) {\n                _this.loadManifest().then(function () {\n                    new Promise(variableRequestPromiseMethod).then(resolve);\n                });\n            });\n        }\n        return new Promise(variableRequestPromiseMethod);\n    };\n    return CheckpointLoader;\n}());\nexports.CheckpointLoader = CheckpointLoader;\n//# sourceMappingURL=checkpoint_loader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2RhdGEvY2hlY2twb2ludF9sb2FkZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2RhdGEvY2hlY2twb2ludF9sb2FkZXIuanM/ZmI2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIE1BTklGRVNUX0ZJTEUgPSAnbWFuaWZlc3QuanNvbic7XG52YXIgQ2hlY2twb2ludExvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hlY2twb2ludExvYWRlcih1cmxQYXRoKSB7XG4gICAgICAgIHRoaXMudXJsUGF0aCA9IHVybFBhdGg7XG4gICAgICAgIGlmICh0aGlzLnVybFBhdGguY2hhckF0KHRoaXMudXJsUGF0aC5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgICAgICAgICB0aGlzLnVybFBhdGggKz0gJy8nO1xuICAgICAgICB9XG4gICAgfVxuICAgIENoZWNrcG9pbnRMb2FkZXIucHJvdG90eXBlLmxvYWRNYW5pZmVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBfdGhpcy51cmxQYXRoICsgTUFOSUZFU1RfRklMRSk7XG4gICAgICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE1BTklGRVNUX0ZJTEUgKyBcIiBub3QgZm91bmQgYXQgXCIgKyBfdGhpcy51cmxQYXRoICsgXCIuIFwiICsgZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2hlY2twb2ludExvYWRlci5wcm90b3R5cGUuZ2V0Q2hlY2twb2ludE1hbmlmZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5jaGVja3BvaW50TWFuaWZlc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2FkTWFuaWZlc3QoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcy5jaGVja3BvaW50TWFuaWZlc3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHJlc29sdmUoX3RoaXMuY2hlY2twb2ludE1hbmlmZXN0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaGVja3BvaW50TG9hZGVyLnByb3RvdHlwZS5nZXRBbGxWYXJpYWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMudmFyaWFibGVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5nZXRDaGVja3BvaW50TWFuaWZlc3QoKS50aGVuKGZ1bmN0aW9uIChjaGVja3BvaW50RGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZU5hbWVzID0gT2JqZWN0LmtleXMoX3RoaXMuY2hlY2twb2ludE1hbmlmZXN0KTtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGVQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFyaWFibGVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZVByb21pc2VzLnB1c2goX3RoaXMuZ2V0VmFyaWFibGUodmFyaWFibGVOYW1lc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbCh2YXJpYWJsZVByb21pc2VzKS50aGVuKGZ1bmN0aW9uICh2YXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmFyaWFibGVzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFyaWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52YXJpYWJsZXNbdmFyaWFibGVOYW1lc1tpXV0gPSB2YXJpYWJsZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcy52YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2hlY2twb2ludExvYWRlci5wcm90b3R5cGUuZ2V0VmFyaWFibGUgPSBmdW5jdGlvbiAodmFyTmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoISh2YXJOYW1lIGluIHRoaXMuY2hlY2twb2ludE1hbmlmZXN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbG9hZCBub24tZXhpc3RhbnQgdmFyaWFibGUgJyArIHZhck5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YXJpYWJsZVJlcXVlc3RQcm9taXNlTWV0aG9kID0gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICB2YXIgZm5hbWUgPSBfdGhpcy5jaGVja3BvaW50TWFuaWZlc3RbdmFyTmFtZV0uZmlsZW5hbWU7XG4gICAgICAgICAgICB4aHIub3BlbignR0VUJywgX3RoaXMudXJsUGF0aCArIGZuYW1lKTtcbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB2YXIgbmRhcnJheSA9IG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoX3RoaXMuY2hlY2twb2ludE1hbmlmZXN0W3Zhck5hbWVdLnNoYXBlLCB7IHZhbHVlczogdmFsdWVzIH0pO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobmRhcnJheSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmZXRjaCB2YXJpYWJsZSAnICsgdmFyTmFtZSArICc6ICcgKyBlcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLnNlbmQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2twb2ludE1hbmlmZXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9hZE1hbmlmZXN0KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKHZhcmlhYmxlUmVxdWVzdFByb21pc2VNZXRob2QpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UodmFyaWFibGVSZXF1ZXN0UHJvbWlzZU1ldGhvZCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hlY2twb2ludExvYWRlcjtcbn0oKSk7XG5leHBvcnRzLkNoZWNrcG9pbnRMb2FkZXIgPSBDaGVja3BvaW50TG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2twb2ludF9sb2FkZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/data/checkpoint_loader.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/data/dataset.js":
/*!*********************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/data/dataset.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar STATS_SAMPLE_PERCENTAGE = 0.1;\nvar InMemoryDataset = (function () {\n    function InMemoryDataset(dataShapes) {\n        this.dataShapes = dataShapes;\n        this.normalizationInfo = {};\n    }\n    InMemoryDataset.prototype.getDataShape = function (dataIndex) {\n        return this.dataShapes[dataIndex];\n    };\n    InMemoryDataset.prototype.getData = function () {\n        return this.dataset;\n    };\n    InMemoryDataset.prototype.getStats = function () {\n        var _this = this;\n        if (this.dataset == null) {\n            throw new Error('Data is null.');\n        }\n        return this.dataset.map(function (d) { return _this.getStatsForData(d); });\n    };\n    InMemoryDataset.prototype.getStatsForData = function (data) {\n        var inputMin = Number.POSITIVE_INFINITY;\n        var inputMax = Number.NEGATIVE_INFINITY;\n        var exampleIndices = data.map(function (example, i) { return i; });\n        util.shuffle(exampleIndices);\n        exampleIndices =\n            exampleIndices.slice(exampleIndices.length * STATS_SAMPLE_PERCENTAGE);\n        for (var i = 0; i < exampleIndices.length; i++) {\n            var inputValues = data[exampleIndices[i]].getValues();\n            for (var j = 0; j < inputValues.length; j++) {\n                inputMin = Math.min(inputMin, inputValues[j]);\n                inputMax = Math.max(inputMax, inputValues[j]);\n            }\n        }\n        return {\n            inputMin: inputMin,\n            inputMax: inputMax,\n            exampleCount: data.length,\n            shape: data[0].shape,\n        };\n    };\n    InMemoryDataset.prototype.normalizeExamplesToRange = function (examples, curLowerBounds, curUpperBounds, newLowerBounds, newUpperBounds) {\n        var curBoundsIsPerDimension = (curUpperBounds instanceof Float32Array &&\n            curLowerBounds instanceof Float32Array);\n        var newBoundsIsPerDimension = (newLowerBounds instanceof Float32Array &&\n            newUpperBounds instanceof Float32Array);\n        var inputSize = util.sizeFromShape(examples[0].shape);\n        var newExamples = [];\n        examples.forEach(function (example) {\n            var inputValues = example.getValues();\n            var normalizedValues = new Float32Array(inputSize);\n            for (var j = 0; j < inputSize; j++) {\n                var curLowerBound = curBoundsIsPerDimension ?\n                    curLowerBounds[j] :\n                    curLowerBounds;\n                var curUpperBound = curBoundsIsPerDimension ?\n                    curUpperBounds[j] :\n                    curUpperBounds;\n                var curRange = curUpperBound - curLowerBound;\n                var newLowerBound = newBoundsIsPerDimension ?\n                    newLowerBounds[j] :\n                    newLowerBounds;\n                var newUpperBound = newBoundsIsPerDimension ?\n                    newUpperBounds[j] :\n                    newUpperBounds;\n                var newRange = newUpperBound - newLowerBound;\n                if (curRange === 0) {\n                    normalizedValues[j] = newLowerBound;\n                }\n                else {\n                    normalizedValues[j] = newLowerBound +\n                        newRange * (inputValues[j] - curLowerBound) / curRange;\n                }\n            }\n            newExamples.push(ndarray_1.NDArray.make(example.shape, { values: normalizedValues }));\n        });\n        return newExamples;\n    };\n    InMemoryDataset.prototype.computeBounds = function (dataIndex) {\n        var _this = this;\n        if (this.dataset == null) {\n            throw new Error('Data is null.');\n        }\n        var size = util.sizeFromShape(this.dataset[dataIndex][0].shape);\n        this.normalizationInfo[dataIndex] = {\n            isNormalized: false,\n            minValues: new Float32Array(size),\n            maxValues: new Float32Array(size)\n        };\n        for (var i = 0; i < size; i++) {\n            this.normalizationInfo[dataIndex].minValues[i] = Number.POSITIVE_INFINITY;\n            this.normalizationInfo[dataIndex].maxValues[i] = Number.NEGATIVE_INFINITY;\n        }\n        this.dataset[dataIndex].forEach(function (example) {\n            var inputValues = example.getValues();\n            for (var k = 0; k < size; k++) {\n                _this.normalizationInfo[dataIndex].minValues[k] = Math.min(_this.normalizationInfo[dataIndex].minValues[k], inputValues[k]);\n                _this.normalizationInfo[dataIndex].maxValues[k] = Math.max(_this.normalizationInfo[dataIndex].maxValues[k], inputValues[k]);\n            }\n        });\n    };\n    InMemoryDataset.prototype.normalizeWithinBounds = function (dataIndex, lowerBound, upperBound) {\n        if (this.dataset == null) {\n            throw new Error('Data is null.');\n        }\n        if (dataIndex >= this.dataset.length) {\n            throw new Error('dataIndex out of bounds.');\n        }\n        if (this.normalizationInfo[dataIndex] == null) {\n            this.computeBounds(dataIndex);\n        }\n        var curLowerBounds;\n        var curUpperBounds;\n        if (this.normalizationInfo[dataIndex].isNormalized) {\n            curLowerBounds = this.normalizationInfo[dataIndex].lowerBound;\n            curUpperBounds = this.normalizationInfo[dataIndex].upperBound;\n        }\n        else {\n            curLowerBounds = this.normalizationInfo[dataIndex].minValues;\n            curUpperBounds = this.normalizationInfo[dataIndex].maxValues;\n        }\n        this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], curLowerBounds, curUpperBounds, lowerBound, upperBound);\n        this.normalizationInfo[dataIndex].isNormalized = true;\n        this.normalizationInfo[dataIndex].lowerBound = lowerBound;\n        this.normalizationInfo[dataIndex].upperBound = upperBound;\n    };\n    InMemoryDataset.prototype.isNormalized = function (dataIndex) {\n        return this.normalizationInfo != null &&\n            this.normalizationInfo[dataIndex].isNormalized;\n    };\n    InMemoryDataset.prototype.removeNormalization = function (dataIndex) {\n        if (this.dataset == null) {\n            throw new Error('Training or test data is null.');\n        }\n        if (!this.isNormalized(dataIndex)) {\n            return;\n        }\n        this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);\n        this.normalizationInfo[dataIndex].isNormalized = false;\n    };\n    InMemoryDataset.prototype.unnormalizeExamples = function (examples, dataIndex) {\n        if (!this.isNormalized(dataIndex)) {\n            return examples;\n        }\n        return this.normalizeExamplesToRange(examples, this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);\n    };\n    InMemoryDataset.prototype.dispose = function () {\n        if (this.dataset == null) {\n            return;\n        }\n        for (var i = 0; i < this.dataset.length; i++) {\n            for (var j = 0; j < this.dataset[i].length; j++) {\n                this.dataset[i][j].dispose();\n            }\n        }\n        this.dataset = [];\n    };\n    return InMemoryDataset;\n}());\nexports.InMemoryDataset = InMemoryDataset;\n//# sourceMappingURL=dataset.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2RhdGEvZGF0YXNldC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZGF0YS9kYXRhc2V0LmpzPzk5OTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgU1RBVFNfU0FNUExFX1BFUkNFTlRBR0UgPSAwLjE7XG52YXIgSW5NZW1vcnlEYXRhc2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbk1lbW9yeURhdGFzZXQoZGF0YVNoYXBlcykge1xuICAgICAgICB0aGlzLmRhdGFTaGFwZXMgPSBkYXRhU2hhcGVzO1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvID0ge307XG4gICAgfVxuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUuZ2V0RGF0YVNoYXBlID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU2hhcGVzW2RhdGFJbmRleF07XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFzZXQ7XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kYXRhc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBpcyBudWxsLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFzZXQubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBfdGhpcy5nZXRTdGF0c0ZvckRhdGEoZCk7IH0pO1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5nZXRTdGF0c0ZvckRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgaW5wdXRNaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHZhciBpbnB1dE1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgdmFyIGV4YW1wbGVJbmRpY2VzID0gZGF0YS5tYXAoZnVuY3Rpb24gKGV4YW1wbGUsIGkpIHsgcmV0dXJuIGk7IH0pO1xuICAgICAgICB1dGlsLnNodWZmbGUoZXhhbXBsZUluZGljZXMpO1xuICAgICAgICBleGFtcGxlSW5kaWNlcyA9XG4gICAgICAgICAgICBleGFtcGxlSW5kaWNlcy5zbGljZShleGFtcGxlSW5kaWNlcy5sZW5ndGggKiBTVEFUU19TQU1QTEVfUEVSQ0VOVEFHRSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhhbXBsZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbnB1dFZhbHVlcyA9IGRhdGFbZXhhbXBsZUluZGljZXNbaV1dLmdldFZhbHVlcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnB1dFZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlucHV0TWluID0gTWF0aC5taW4oaW5wdXRNaW4sIGlucHV0VmFsdWVzW2pdKTtcbiAgICAgICAgICAgICAgICBpbnB1dE1heCA9IE1hdGgubWF4KGlucHV0TWF4LCBpbnB1dFZhbHVlc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0TWluOiBpbnB1dE1pbixcbiAgICAgICAgICAgIGlucHV0TWF4OiBpbnB1dE1heCxcbiAgICAgICAgICAgIGV4YW1wbGVDb3VudDogZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICBzaGFwZTogZGF0YVswXS5zaGFwZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUubm9ybWFsaXplRXhhbXBsZXNUb1JhbmdlID0gZnVuY3Rpb24gKGV4YW1wbGVzLCBjdXJMb3dlckJvdW5kcywgY3VyVXBwZXJCb3VuZHMsIG5ld0xvd2VyQm91bmRzLCBuZXdVcHBlckJvdW5kcykge1xuICAgICAgICB2YXIgY3VyQm91bmRzSXNQZXJEaW1lbnNpb24gPSAoY3VyVXBwZXJCb3VuZHMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgJiZcbiAgICAgICAgICAgIGN1ckxvd2VyQm91bmRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KTtcbiAgICAgICAgdmFyIG5ld0JvdW5kc0lzUGVyRGltZW5zaW9uID0gKG5ld0xvd2VyQm91bmRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICYmXG4gICAgICAgICAgICBuZXdVcHBlckJvdW5kcyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSk7XG4gICAgICAgIHZhciBpbnB1dFNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoZXhhbXBsZXNbMF0uc2hhcGUpO1xuICAgICAgICB2YXIgbmV3RXhhbXBsZXMgPSBbXTtcbiAgICAgICAgZXhhbXBsZXMuZm9yRWFjaChmdW5jdGlvbiAoZXhhbXBsZSkge1xuICAgICAgICAgICAgdmFyIGlucHV0VmFsdWVzID0gZXhhbXBsZS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShpbnB1dFNpemUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnB1dFNpemU7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJMb3dlckJvdW5kID0gY3VyQm91bmRzSXNQZXJEaW1lbnNpb24gP1xuICAgICAgICAgICAgICAgICAgICBjdXJMb3dlckJvdW5kc1tqXSA6XG4gICAgICAgICAgICAgICAgICAgIGN1ckxvd2VyQm91bmRzO1xuICAgICAgICAgICAgICAgIHZhciBjdXJVcHBlckJvdW5kID0gY3VyQm91bmRzSXNQZXJEaW1lbnNpb24gP1xuICAgICAgICAgICAgICAgICAgICBjdXJVcHBlckJvdW5kc1tqXSA6XG4gICAgICAgICAgICAgICAgICAgIGN1clVwcGVyQm91bmRzO1xuICAgICAgICAgICAgICAgIHZhciBjdXJSYW5nZSA9IGN1clVwcGVyQm91bmQgLSBjdXJMb3dlckJvdW5kO1xuICAgICAgICAgICAgICAgIHZhciBuZXdMb3dlckJvdW5kID0gbmV3Qm91bmRzSXNQZXJEaW1lbnNpb24gP1xuICAgICAgICAgICAgICAgICAgICBuZXdMb3dlckJvdW5kc1tqXSA6XG4gICAgICAgICAgICAgICAgICAgIG5ld0xvd2VyQm91bmRzO1xuICAgICAgICAgICAgICAgIHZhciBuZXdVcHBlckJvdW5kID0gbmV3Qm91bmRzSXNQZXJEaW1lbnNpb24gP1xuICAgICAgICAgICAgICAgICAgICBuZXdVcHBlckJvdW5kc1tqXSA6XG4gICAgICAgICAgICAgICAgICAgIG5ld1VwcGVyQm91bmRzO1xuICAgICAgICAgICAgICAgIHZhciBuZXdSYW5nZSA9IG5ld1VwcGVyQm91bmQgLSBuZXdMb3dlckJvdW5kO1xuICAgICAgICAgICAgICAgIGlmIChjdXJSYW5nZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkVmFsdWVzW2pdID0gbmV3TG93ZXJCb3VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRWYWx1ZXNbal0gPSBuZXdMb3dlckJvdW5kICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1JhbmdlICogKGlucHV0VmFsdWVzW2pdIC0gY3VyTG93ZXJCb3VuZCkgLyBjdXJSYW5nZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdFeGFtcGxlcy5wdXNoKG5kYXJyYXlfMS5OREFycmF5Lm1ha2UoZXhhbXBsZS5zaGFwZSwgeyB2YWx1ZXM6IG5vcm1hbGl6ZWRWYWx1ZXMgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld0V4YW1wbGVzO1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5jb21wdXRlQm91bmRzID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kYXRhc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBpcyBudWxsLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMuZGF0YXNldFtkYXRhSW5kZXhdWzBdLnNoYXBlKTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdID0ge1xuICAgICAgICAgICAgaXNOb3JtYWxpemVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1pblZhbHVlczogbmV3IEZsb2F0MzJBcnJheShzaXplKSxcbiAgICAgICAgICAgIG1heFZhbHVlczogbmV3IEZsb2F0MzJBcnJheShzaXplKVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1pblZhbHVlc1tpXSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5tYXhWYWx1ZXNbaV0gPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhc2V0W2RhdGFJbmRleF0uZm9yRWFjaChmdW5jdGlvbiAoZXhhbXBsZSkge1xuICAgICAgICAgICAgdmFyIGlucHV0VmFsdWVzID0gZXhhbXBsZS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2l6ZTsgaysrKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5taW5WYWx1ZXNba10gPSBNYXRoLm1pbihfdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1pblZhbHVlc1trXSwgaW5wdXRWYWx1ZXNba10pO1xuICAgICAgICAgICAgICAgIF90aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzW2tdID0gTWF0aC5tYXgoX3RoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5tYXhWYWx1ZXNba10sIGlucHV0VmFsdWVzW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLm5vcm1hbGl6ZVdpdGhpbkJvdW5kcyA9IGZ1bmN0aW9uIChkYXRhSW5kZXgsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgaXMgbnVsbC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YUluZGV4ID49IHRoaXMuZGF0YXNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGF0YUluZGV4IG91dCBvZiBib3VuZHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCb3VuZHMoZGF0YUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VyTG93ZXJCb3VuZHM7XG4gICAgICAgIHZhciBjdXJVcHBlckJvdW5kcztcbiAgICAgICAgaWYgKHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5pc05vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgIGN1ckxvd2VyQm91bmRzID0gdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmxvd2VyQm91bmQ7XG4gICAgICAgICAgICBjdXJVcHBlckJvdW5kcyA9IHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS51cHBlckJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VyTG93ZXJCb3VuZHMgPSB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzO1xuICAgICAgICAgICAgY3VyVXBwZXJCb3VuZHMgPSB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YXNldFtkYXRhSW5kZXhdID0gdGhpcy5ub3JtYWxpemVFeGFtcGxlc1RvUmFuZ2UodGhpcy5kYXRhc2V0W2RhdGFJbmRleF0sIGN1ckxvd2VyQm91bmRzLCBjdXJVcHBlckJvdW5kcywgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCk7XG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5pc05vcm1hbGl6ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubG93ZXJCb3VuZCA9IGxvd2VyQm91bmQ7XG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS51cHBlckJvdW5kID0gdXBwZXJCb3VuZDtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUuaXNOb3JtYWxpemVkID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemF0aW9uSW5mbyAhPSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0uaXNOb3JtYWxpemVkO1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5yZW1vdmVOb3JtYWxpemF0aW9uID0gZnVuY3Rpb24gKGRhdGFJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhaW5pbmcgb3IgdGVzdCBkYXRhIGlzIG51bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzTm9ybWFsaXplZChkYXRhSW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhc2V0W2RhdGFJbmRleF0gPSB0aGlzLm5vcm1hbGl6ZUV4YW1wbGVzVG9SYW5nZSh0aGlzLmRhdGFzZXRbZGF0YUluZGV4XSwgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmxvd2VyQm91bmQsIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS51cHBlckJvdW5kLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzKTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmlzTm9ybWFsaXplZCA9IGZhbHNlO1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS51bm5vcm1hbGl6ZUV4YW1wbGVzID0gZnVuY3Rpb24gKGV4YW1wbGVzLCBkYXRhSW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTm9ybWFsaXplZChkYXRhSW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhhbXBsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplRXhhbXBsZXNUb1JhbmdlKGV4YW1wbGVzLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubG93ZXJCb3VuZCwgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLnVwcGVyQm91bmQsIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5taW5WYWx1ZXMsIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5tYXhWYWx1ZXMpO1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YXNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmRhdGFzZXRbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFzZXRbaV1bal0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YXNldCA9IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIEluTWVtb3J5RGF0YXNldDtcbn0oKSk7XG5leHBvcnRzLkluTWVtb3J5RGF0YXNldCA9IEluTWVtb3J5RGF0YXNldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGFzZXQuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/data/dataset.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/data/input_provider.js":
/*!****************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/data/input_provider.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar InMemoryShuffledInputProviderBuilder = (function () {\n    function InMemoryShuffledInputProviderBuilder(inputs) {\n        this.inputs = inputs;\n        this.idx = 0;\n        this.inputCounter = 0;\n        this.epoch = 0;\n        this.shuffledIndices = util.createShuffledIndices(inputs[0].length);\n        this.numInputs = inputs.length;\n        var numExamples = this.inputs[0].length;\n        for (var i = 0; i < this.numInputs; i++) {\n            util.assert(this.inputs[i].length === numExamples, 'Number of examples must match across different inputs.');\n        }\n        for (var i = 0; i < this.numInputs; i++) {\n            var inputShape = this.inputs[i][0].shape;\n            for (var j = 0; j < this.inputs[i].length; j++) {\n                util.assertShapesMatch(inputShape, this.inputs[i][j].shape);\n            }\n        }\n    }\n    InMemoryShuffledInputProviderBuilder.prototype.getCurrentExampleIndex = function () {\n        var returnIdx = this.idx;\n        this.inputCounter++;\n        if (this.inputCounter >= this.numInputs) {\n            this.idx++;\n            this.inputCounter = 0;\n            if (this.idx >= this.inputs[0].length) {\n                this.idx = 0;\n                this.epoch++;\n            }\n        }\n        return returnIdx;\n    };\n    InMemoryShuffledInputProviderBuilder.prototype.getNextInput = function (inputId) {\n        var currentExampleIndex = this.getCurrentExampleIndex();\n        return this.inputs[inputId][this.shuffledIndices[currentExampleIndex]];\n    };\n    InMemoryShuffledInputProviderBuilder.prototype.getEpoch = function () {\n        return this.epoch;\n    };\n    InMemoryShuffledInputProviderBuilder.prototype.getInputProviders = function () {\n        var inputProviders = [];\n        for (var i = 0; i < this.numInputs; i++) {\n            inputProviders.push(this.getInputProvider(i));\n        }\n        return inputProviders;\n    };\n    return InMemoryShuffledInputProviderBuilder;\n}());\nexports.InMemoryShuffledInputProviderBuilder = InMemoryShuffledInputProviderBuilder;\nvar InCPUMemoryShuffledInputProviderBuilder = (function (_super) {\n    __extends(InCPUMemoryShuffledInputProviderBuilder, _super);\n    function InCPUMemoryShuffledInputProviderBuilder() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    InCPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {\n        var shuffledInputProvider = this;\n        return {\n            getNextCopy: function (math) {\n                return ndarray_1.NDArray.like(shuffledInputProvider.getNextInput(inputId));\n            },\n            disposeCopy: function (math, copy) {\n                copy.dispose();\n            }\n        };\n    };\n    return InCPUMemoryShuffledInputProviderBuilder;\n}(InMemoryShuffledInputProviderBuilder));\nexports.InCPUMemoryShuffledInputProviderBuilder = InCPUMemoryShuffledInputProviderBuilder;\nvar InGPUMemoryShuffledInputProviderBuilder = (function (_super) {\n    __extends(InGPUMemoryShuffledInputProviderBuilder, _super);\n    function InGPUMemoryShuffledInputProviderBuilder() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    InGPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {\n        var shuffledInputProvider = this;\n        return {\n            getNextCopy: function (math) {\n                return math.clone(shuffledInputProvider.getNextInput(inputId));\n            },\n            disposeCopy: function (math, copy) {\n                copy.dispose();\n            }\n        };\n    };\n    return InGPUMemoryShuffledInputProviderBuilder;\n}(InMemoryShuffledInputProviderBuilder));\nexports.InGPUMemoryShuffledInputProviderBuilder = InGPUMemoryShuffledInputProviderBuilder;\n//# sourceMappingURL=input_provider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2RhdGEvaW5wdXRfcHJvdmlkZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2RhdGEvaW5wdXRfcHJvdmlkZXIuanM/ZWE4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyKGlucHV0cykge1xuICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgdGhpcy5pZHggPSAwO1xuICAgICAgICB0aGlzLmlucHV0Q291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuZXBvY2ggPSAwO1xuICAgICAgICB0aGlzLnNodWZmbGVkSW5kaWNlcyA9IHV0aWwuY3JlYXRlU2h1ZmZsZWRJbmRpY2VzKGlucHV0c1swXS5sZW5ndGgpO1xuICAgICAgICB0aGlzLm51bUlucHV0cyA9IGlucHV0cy5sZW5ndGg7XG4gICAgICAgIHZhciBudW1FeGFtcGxlcyA9IHRoaXMuaW5wdXRzWzBdLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bUlucHV0czsgaSsrKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh0aGlzLmlucHV0c1tpXS5sZW5ndGggPT09IG51bUV4YW1wbGVzLCAnTnVtYmVyIG9mIGV4YW1wbGVzIG11c3QgbWF0Y2ggYWNyb3NzIGRpZmZlcmVudCBpbnB1dHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bUlucHV0czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRTaGFwZSA9IHRoaXMuaW5wdXRzW2ldWzBdLnNoYXBlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmlucHV0c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goaW5wdXRTaGFwZSwgdGhpcy5pbnB1dHNbaV1bal0uc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUuZ2V0Q3VycmVudEV4YW1wbGVJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJldHVybklkeCA9IHRoaXMuaWR4O1xuICAgICAgICB0aGlzLmlucHV0Q291bnRlcisrO1xuICAgICAgICBpZiAodGhpcy5pbnB1dENvdW50ZXIgPj0gdGhpcy5udW1JbnB1dHMpIHtcbiAgICAgICAgICAgIHRoaXMuaWR4Kys7XG4gICAgICAgICAgICB0aGlzLmlucHV0Q291bnRlciA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5pZHggPj0gdGhpcy5pbnB1dHNbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuZXBvY2grKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuSWR4O1xuICAgIH07XG4gICAgSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLnByb3RvdHlwZS5nZXROZXh0SW5wdXQgPSBmdW5jdGlvbiAoaW5wdXRJZCkge1xuICAgICAgICB2YXIgY3VycmVudEV4YW1wbGVJbmRleCA9IHRoaXMuZ2V0Q3VycmVudEV4YW1wbGVJbmRleCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dHNbaW5wdXRJZF1bdGhpcy5zaHVmZmxlZEluZGljZXNbY3VycmVudEV4YW1wbGVJbmRleF1dO1xuICAgIH07XG4gICAgSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLnByb3RvdHlwZS5nZXRFcG9jaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXBvY2g7XG4gICAgfTtcbiAgICBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIucHJvdG90eXBlLmdldElucHV0UHJvdmlkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5wdXRQcm92aWRlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bUlucHV0czsgaSsrKSB7XG4gICAgICAgICAgICBpbnB1dFByb3ZpZGVycy5wdXNoKHRoaXMuZ2V0SW5wdXRQcm92aWRlcihpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0UHJvdmlkZXJzO1xuICAgIH07XG4gICAgcmV0dXJuIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcjtcbn0oKSk7XG5leHBvcnRzLkluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciA9IEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcjtcbnZhciBJbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUuZ2V0SW5wdXRQcm92aWRlciA9IGZ1bmN0aW9uIChpbnB1dElkKSB7XG4gICAgICAgIHZhciBzaHVmZmxlZElucHV0UHJvdmlkZXIgPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0TmV4dENvcHk6IGZ1bmN0aW9uIChtYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lmxpa2Uoc2h1ZmZsZWRJbnB1dFByb3ZpZGVyLmdldE5leHRJbnB1dChpbnB1dElkKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzcG9zZUNvcHk6IGZ1bmN0aW9uIChtYXRoLCBjb3B5KSB7XG4gICAgICAgICAgICAgICAgY29weS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyO1xufShJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIpKTtcbmV4cG9ydHMuSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID0gSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyO1xudmFyIEluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLnByb3RvdHlwZS5nZXRJbnB1dFByb3ZpZGVyID0gZnVuY3Rpb24gKGlucHV0SWQpIHtcbiAgICAgICAgdmFyIHNodWZmbGVkSW5wdXRQcm92aWRlciA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXROZXh0Q29weTogZnVuY3Rpb24gKG1hdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0aC5jbG9uZShzaHVmZmxlZElucHV0UHJvdmlkZXIuZ2V0TmV4dElucHV0KGlucHV0SWQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwb3NlQ29weTogZnVuY3Rpb24gKG1hdGgsIGNvcHkpIHtcbiAgICAgICAgICAgICAgICBjb3B5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBJbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG59KEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcikpO1xuZXhwb3J0cy5JbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSBJbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnB1dF9wcm92aWRlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/data/input_provider.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/data/xhr-dataset.js":
/*!*************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/data/xhr-dataset.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar dataset_1 = __webpack_require__(/*! ./dataset */ \"./node_modules/deeplearn/dist/src/data/dataset.js\");\nvar PARSING_IMAGE_CANVAS_HEIGHT_PX = 1000;\nfunction getXhrDatasetConfig(jsonConfigPath) {\n    return new Promise(function (resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', jsonConfigPath);\n        xhr.onload = function () {\n            resolve(JSON.parse(xhr.responseText));\n        };\n        xhr.onerror = function (error) {\n            reject(error);\n        };\n        xhr.send();\n    });\n}\nexports.getXhrDatasetConfig = getXhrDatasetConfig;\nvar XhrDataset = (function (_super) {\n    __extends(XhrDataset, _super);\n    function XhrDataset(xhrDatasetConfig) {\n        var _this = _super.call(this, xhrDatasetConfig.data.map(function (x) { return x.shape; })) || this;\n        _this.xhrDatasetConfig = xhrDatasetConfig;\n        return _this;\n    }\n    XhrDataset.prototype.getNDArray = function (info) {\n        var dataPromise = info.dataType === 'png' ?\n            parseTypedArrayFromPng(info, info.shape) :\n            parseTypedArrayFromBinary(info);\n        return dataPromise.then(function (data) {\n            var inputSize = util.sizeFromShape(info.shape);\n            var ndarrays = [];\n            for (var i = 0; i < data.length / inputSize; i++) {\n                var values = data.subarray(i * inputSize, (i + 1) * inputSize);\n                var ndarray = ndarray_1.NDArray.make(info.shape, { values: new Float32Array(values) });\n                ndarrays.push(ndarray);\n            }\n            return ndarrays;\n        });\n    };\n    XhrDataset.prototype.fetchData = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var promises = _this.xhrDatasetConfig.data.map(function (x) { return _this.getNDArray(x); });\n            Promise.all(promises).then(function (data) {\n                _this.dataset = data;\n                resolve();\n            });\n        });\n    };\n    return XhrDataset;\n}(dataset_1.InMemoryDataset));\nexports.XhrDataset = XhrDataset;\nfunction parseTypedArrayFromBinary(info) {\n    return new Promise(function (resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', info.path);\n        xhr.responseType = 'arraybuffer';\n        xhr.onload = function (event) {\n            var data = (info.dataType === 'float32') ?\n                new Float32Array(xhr.response) :\n                new Uint8Array(xhr.response);\n            resolve(data);\n        };\n        xhr.onerror = function (err) { return reject(err); };\n        xhr.send();\n    });\n}\nfunction parseGrayscaleImageData(data, result, resultOffset) {\n    var idx = resultOffset;\n    for (var i = 0; i < data.length; i += 4) {\n        result[idx++] = data[i];\n    }\n}\nfunction parseRGBImageData(data, result, resultOffset) {\n    var idx = resultOffset;\n    for (var i = 0; i < data.length; i += 4) {\n        result[idx] = data[i];\n        result[idx + 1] = data[i + 1];\n        result[idx + 2] = data[i + 2];\n        idx += 3;\n    }\n}\nfunction parseImage(img, shape) {\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var N = img.height;\n    var inputSize = util.sizeFromShape(shape);\n    var result = new Uint8Array(N * inputSize);\n    if (img.width !== shape[0] * shape[1]) {\n        throw new Error(\"Image width (\" + img.width + \") must be multiple of \" +\n            (\"rows*columns (\" + shape[0] + \"*\" + shape[1] + \") of the ndarray\"));\n    }\n    canvas.width = img.width;\n    canvas.height = PARSING_IMAGE_CANVAS_HEIGHT_PX;\n    var sx = 0;\n    var sWidth = canvas.width;\n    var sHeight = canvas.height;\n    var dx = 0;\n    var dy = 0;\n    var dWidth = sWidth;\n    var dHeight = sHeight;\n    var depth = shape[2];\n    var offset = 0;\n    var numPasses = Math.ceil(N / canvas.height);\n    for (var pass = 0; pass < numPasses; ++pass) {\n        var sy = pass * canvas.height;\n        if ((pass === numPasses - 1) && (N % canvas.height > 0)) {\n            canvas.height = N % canvas.height;\n            sHeight = canvas.height;\n            dHeight = sHeight;\n        }\n        ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n        var data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n        (depth === 1) ? parseGrayscaleImageData(data, result, offset) :\n            parseRGBImageData(data, result, offset);\n        offset += canvas.height * inputSize;\n    }\n    return result;\n}\nfunction parseTypedArrayFromPng(info, shape) {\n    return new Promise(function (resolve, reject) {\n        var img = new Image();\n        img.setAttribute('crossOrigin', '');\n        img.onload = function () {\n            var result = parseImage(img, shape);\n            img.src = '';\n            img = null;\n            resolve(result);\n        };\n        img.src = info.path;\n    });\n}\n//# sourceMappingURL=xhr-dataset.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2RhdGEveGhyLWRhdGFzZXQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2RhdGEveGhyLWRhdGFzZXQuanM/Zjk3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGRhdGFzZXRfMSA9IHJlcXVpcmUoXCIuL2RhdGFzZXRcIik7XG52YXIgUEFSU0lOR19JTUFHRV9DQU5WQVNfSEVJR0hUX1BYID0gMTAwMDtcbmZ1bmN0aW9uIGdldFhockRhdGFzZXRDb25maWcoanNvbkNvbmZpZ1BhdGgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBqc29uQ29uZmlnUGF0aCk7XG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCkpO1xuICAgICAgICB9O1xuICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLnNlbmQoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0WGhyRGF0YXNldENvbmZpZyA9IGdldFhockRhdGFzZXRDb25maWc7XG52YXIgWGhyRGF0YXNldCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFhockRhdGFzZXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWGhyRGF0YXNldCh4aHJEYXRhc2V0Q29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHhockRhdGFzZXRDb25maWcuZGF0YS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2hhcGU7IH0pKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54aHJEYXRhc2V0Q29uZmlnID0geGhyRGF0YXNldENvbmZpZztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBYaHJEYXRhc2V0LnByb3RvdHlwZS5nZXROREFycmF5ID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgdmFyIGRhdGFQcm9taXNlID0gaW5mby5kYXRhVHlwZSA9PT0gJ3BuZycgP1xuICAgICAgICAgICAgcGFyc2VUeXBlZEFycmF5RnJvbVBuZyhpbmZvLCBpbmZvLnNoYXBlKSA6XG4gICAgICAgICAgICBwYXJzZVR5cGVkQXJyYXlGcm9tQmluYXJ5KGluZm8pO1xuICAgICAgICByZXR1cm4gZGF0YVByb21pc2UudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGlucHV0U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShpbmZvLnNoYXBlKTtcbiAgICAgICAgICAgIHZhciBuZGFycmF5cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAvIGlucHV0U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGRhdGEuc3ViYXJyYXkoaSAqIGlucHV0U2l6ZSwgKGkgKyAxKSAqIGlucHV0U2l6ZSk7XG4gICAgICAgICAgICAgICAgdmFyIG5kYXJyYXkgPSBuZGFycmF5XzEuTkRBcnJheS5tYWtlKGluZm8uc2hhcGUsIHsgdmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcykgfSk7XG4gICAgICAgICAgICAgICAgbmRhcnJheXMucHVzaChuZGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZGFycmF5cztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBYaHJEYXRhc2V0LnByb3RvdHlwZS5mZXRjaERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBfdGhpcy54aHJEYXRhc2V0Q29uZmlnLmRhdGEubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBfdGhpcy5nZXROREFycmF5KHgpOyB9KTtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGF0YXNldCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFhockRhdGFzZXQ7XG59KGRhdGFzZXRfMS5Jbk1lbW9yeURhdGFzZXQpKTtcbmV4cG9ydHMuWGhyRGF0YXNldCA9IFhockRhdGFzZXQ7XG5mdW5jdGlvbiBwYXJzZVR5cGVkQXJyYXlGcm9tQmluYXJ5KGluZm8pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBpbmZvLnBhdGgpO1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSAoaW5mby5kYXRhVHlwZSA9PT0gJ2Zsb2F0MzInKSA/XG4gICAgICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheSh4aHIucmVzcG9uc2UpIDpcbiAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByZWplY3QoZXJyKTsgfTtcbiAgICAgICAgeGhyLnNlbmQoKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlR3JheXNjYWxlSW1hZ2VEYXRhKGRhdGEsIHJlc3VsdCwgcmVzdWx0T2Zmc2V0KSB7XG4gICAgdmFyIGlkeCA9IHJlc3VsdE9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgcmVzdWx0W2lkeCsrXSA9IGRhdGFbaV07XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VSR0JJbWFnZURhdGEoZGF0YSwgcmVzdWx0LCByZXN1bHRPZmZzZXQpIHtcbiAgICB2YXIgaWR4ID0gcmVzdWx0T2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICByZXN1bHRbaWR4XSA9IGRhdGFbaV07XG4gICAgICAgIHJlc3VsdFtpZHggKyAxXSA9IGRhdGFbaSArIDFdO1xuICAgICAgICByZXN1bHRbaWR4ICsgMl0gPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgaWR4ICs9IDM7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VJbWFnZShpbWcsIHNoYXBlKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgTiA9IGltZy5oZWlnaHQ7XG4gICAgdmFyIGlucHV0U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSk7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KE4gKiBpbnB1dFNpemUpO1xuICAgIGlmIChpbWcud2lkdGggIT09IHNoYXBlWzBdICogc2hhcGVbMV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2Ugd2lkdGggKFwiICsgaW1nLndpZHRoICsgXCIpIG11c3QgYmUgbXVsdGlwbGUgb2YgXCIgK1xuICAgICAgICAgICAgKFwicm93cypjb2x1bW5zIChcIiArIHNoYXBlWzBdICsgXCIqXCIgKyBzaGFwZVsxXSArIFwiKSBvZiB0aGUgbmRhcnJheVwiKSk7XG4gICAgfVxuICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gUEFSU0lOR19JTUFHRV9DQU5WQVNfSEVJR0hUX1BYO1xuICAgIHZhciBzeCA9IDA7XG4gICAgdmFyIHNXaWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICB2YXIgc0hlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgdmFyIGR4ID0gMDtcbiAgICB2YXIgZHkgPSAwO1xuICAgIHZhciBkV2lkdGggPSBzV2lkdGg7XG4gICAgdmFyIGRIZWlnaHQgPSBzSGVpZ2h0O1xuICAgIHZhciBkZXB0aCA9IHNoYXBlWzJdO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBudW1QYXNzZXMgPSBNYXRoLmNlaWwoTiAvIGNhbnZhcy5oZWlnaHQpO1xuICAgIGZvciAodmFyIHBhc3MgPSAwOyBwYXNzIDwgbnVtUGFzc2VzOyArK3Bhc3MpIHtcbiAgICAgICAgdmFyIHN5ID0gcGFzcyAqIGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIGlmICgocGFzcyA9PT0gbnVtUGFzc2VzIC0gMSkgJiYgKE4gJSBjYW52YXMuaGVpZ2h0ID4gMCkpIHtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBOICUgY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgIHNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgZEhlaWdodCA9IHNIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIHN4LCBzeSwgc1dpZHRoLCBzSGVpZ2h0LCBkeCwgZHksIGRXaWR0aCwgZEhlaWdodCk7XG4gICAgICAgIHZhciBkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpLmRhdGE7XG4gICAgICAgIChkZXB0aCA9PT0gMSkgPyBwYXJzZUdyYXlzY2FsZUltYWdlRGF0YShkYXRhLCByZXN1bHQsIG9mZnNldCkgOlxuICAgICAgICAgICAgcGFyc2VSR0JJbWFnZURhdGEoZGF0YSwgcmVzdWx0LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gY2FudmFzLmhlaWdodCAqIGlucHV0U2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlVHlwZWRBcnJheUZyb21QbmcoaW5mbywgc2hhcGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ2Nyb3NzT3JpZ2luJywgJycpO1xuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW1hZ2UoaW1nLCBzaGFwZSk7XG4gICAgICAgICAgICBpbWcuc3JjID0gJyc7XG4gICAgICAgICAgICBpbWcgPSBudWxsO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBpbWcuc3JjID0gaW5mby5wYXRoO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eGhyLWRhdGFzZXQuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/data/xhr-dataset.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/device_util.js":
/*!********************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/device_util.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isMobile() {\n    var a = navigator.userAgent || navigator.vendor || window.opera;\n    return /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i\n        .test(a) ||\n        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i\n            .test(a.substr(0, 4));\n}\nexports.isMobile = isMobile;\n//# sourceMappingURL=device_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2RldmljZV91dGlsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9kZXZpY2VfdXRpbC5qcz80NmI0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gaXNNb2JpbGUoKSB7XG4gICAgdmFyIGEgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8IG5hdmlnYXRvci52ZW5kb3IgfHwgd2luZG93Lm9wZXJhO1xuICAgIHJldHVybiAvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vL2lcbiAgICAgICAgLnRlc3QoYSkgfHxcbiAgICAgICAgLzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2lcbiAgICAgICAgICAgIC50ZXN0KGEuc3Vic3RyKDAsIDQpKTtcbn1cbmV4cG9ydHMuaXNNb2JpbGUgPSBpc01vYmlsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldmljZV91dGlsLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/device_util.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/environment.js":
/*!********************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/environment.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar device_util = __webpack_require__(/*! ./device_util */ \"./node_modules/deeplearn/dist/src/device_util.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar Type;\n(function (Type) {\n    Type[Type[\"NUMBER\"] = 0] = \"NUMBER\";\n    Type[Type[\"BOOLEAN\"] = 1] = \"BOOLEAN\";\n})(Type = exports.Type || (exports.Type = {}));\nexports.URL_PROPERTIES = [\n    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED', type: Type.BOOLEAN },\n    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', type: Type.BOOLEAN },\n    { name: 'WEBGL_VERSION', type: Type.NUMBER },\n    { name: 'WEBGL_FLOAT_TEXTURE_ENABLED', type: Type.BOOLEAN }\n];\nfunction getWebGLRenderingContext(webGLVersion) {\n    if (webGLVersion === 0) {\n        throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');\n    }\n    var tempCanvas = document.createElement('canvas');\n    if (webGLVersion === 1) {\n        return (tempCanvas.getContext('webgl') ||\n            tempCanvas.getContext('experimental-webgl'));\n    }\n    return tempCanvas.getContext('webgl2');\n}\nfunction loseContext(gl) {\n    if (gl != null) {\n        var loseContextExtension = gl.getExtension('WEBGL_lose_context');\n        if (loseContextExtension == null) {\n            throw new Error('Extension WEBGL_lose_context not supported on this browser.');\n        }\n        loseContextExtension.loseContext();\n    }\n}\nfunction isWebGLVersionEnabled(webGLVersion) {\n    var gl = getWebGLRenderingContext(webGLVersion);\n    if (gl != null) {\n        loseContext(gl);\n        return true;\n    }\n    return false;\n}\nfunction isWebGLDisjointQueryTimerEnabled(webGLVersion) {\n    var gl = getWebGLRenderingContext(webGLVersion);\n    var extensionName = webGLVersion === 1 ? 'EXT_disjoint_timer_query' :\n        'EXT_disjoint_timer_query_webgl2';\n    var ext = gl.getExtension(extensionName);\n    var isExtEnabled = ext != null;\n    if (gl != null) {\n        loseContext(gl);\n    }\n    return isExtEnabled;\n}\nfunction isFloatTextureReadPixelsEnabled(webGLVersion) {\n    if (webGLVersion === 0) {\n        return false;\n    }\n    var gl = getWebGLRenderingContext(webGLVersion);\n    var floatExtension;\n    var colorBufferFloatExtension;\n    if (webGLVersion === 1) {\n        floatExtension = gl.getExtension('OES_texture_float');\n        colorBufferFloatExtension = gl.getExtension('WEBGL_color_buffer_float');\n        if (floatExtension == null || colorBufferFloatExtension == null) {\n            return false;\n        }\n    }\n    else {\n        colorBufferFloatExtension = gl.getExtension('EXT_color_buffer_float');\n        if (colorBufferFloatExtension == null) {\n            return false;\n        }\n    }\n    var frameBuffer = gl.createFramebuffer();\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    var internalFormat = webGLVersion === 2 ? gl.RGBA32F : gl.RGBA;\n    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    var frameBufferComplete = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE);\n    loseContext(gl);\n    return frameBufferComplete;\n}\nvar Environment = (function () {\n    function Environment(features) {\n        this.features = {};\n        if (features != null) {\n            this.features = features;\n        }\n    }\n    Environment.prototype.get = function (feature) {\n        if (feature in this.features) {\n            return this.features[feature];\n        }\n        this.features[feature] = this.evaluateFeature(feature);\n        return this.features[feature];\n    };\n    Environment.prototype.evaluateFeature = function (feature) {\n        if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED') {\n            var webGLVersion = this.get('WEBGL_VERSION');\n            if (webGLVersion === 0) {\n                return false;\n            }\n            return isWebGLDisjointQueryTimerEnabled(webGLVersion);\n        }\n        else if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') {\n            return this.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED') &&\n                !device_util.isMobile();\n        }\n        else if (feature === 'WEBGL_VERSION') {\n            if (isWebGLVersionEnabled(2)) {\n                return 2;\n            }\n            else if (isWebGLVersionEnabled(1)) {\n                return 1;\n            }\n            return 0;\n        }\n        else if (feature === 'WEBGL_FLOAT_TEXTURE_ENABLED') {\n            return isFloatTextureReadPixelsEnabled(this.get('WEBGL_VERSION'));\n        }\n        throw new Error(\"Unknown feature \" + feature + \".\");\n    };\n    return Environment;\n}());\nexports.Environment = Environment;\nvar DEEPLEARNJS_FLAGS_PREFIX = 'dljsflags';\nfunction getFeaturesFromURL() {\n    var features = {};\n    if (typeof window === 'undefined') {\n        return features;\n    }\n    var urlParams = util.getQueryParams(window.location.search);\n    if (DEEPLEARNJS_FLAGS_PREFIX in urlParams) {\n        var urlFlags_1 = {};\n        var keyValues = urlParams[DEEPLEARNJS_FLAGS_PREFIX].split(',');\n        keyValues.forEach(function (keyValue) {\n            var _a = keyValue.split(':'), key = _a[0], value = _a[1];\n            urlFlags_1[key] = value;\n        });\n        exports.URL_PROPERTIES.forEach(function (urlProperty) {\n            if (urlProperty.name in urlFlags_1) {\n                console.log(\"Setting feature override from URL \" + urlProperty.name + \": \" +\n                    (\"\" + urlFlags_1[urlProperty.name]));\n                if (urlProperty.type === Type.NUMBER) {\n                    features[urlProperty.name] = +urlFlags_1[urlProperty.name];\n                }\n                else if (urlProperty.type === Type.BOOLEAN) {\n                    features[urlProperty.name] = urlFlags_1[urlProperty.name] === 'true';\n                }\n                else {\n                    console.warn(\"Unknown URL param: \" + urlProperty.name + \".\");\n                }\n            }\n        });\n    }\n    return features;\n}\nexports.ENV = new Environment(getFeaturesFromURL());\nfunction setEnvironment(environment) {\n    exports.ENV = environment;\n}\nexports.setEnvironment = setEnvironment;\n//# sourceMappingURL=environment.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2Vudmlyb25tZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9lbnZpcm9ubWVudC5qcz9iNDgyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRldmljZV91dGlsID0gcmVxdWlyZShcIi4vZGV2aWNlX3V0aWxcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIFR5cGVbVHlwZVtcIk5VTUJFUlwiXSA9IDBdID0gXCJOVU1CRVJcIjtcbiAgICBUeXBlW1R5cGVbXCJCT09MRUFOXCJdID0gMV0gPSBcIkJPT0xFQU5cIjtcbn0pKFR5cGUgPSBleHBvcnRzLlR5cGUgfHwgKGV4cG9ydHMuVHlwZSA9IHt9KSk7XG5leHBvcnRzLlVSTF9QUk9QRVJUSUVTID0gW1xuICAgIHsgbmFtZTogJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9FTkFCTEVEJywgdHlwZTogVHlwZS5CT09MRUFOIH0sXG4gICAgeyBuYW1lOiAnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFJywgdHlwZTogVHlwZS5CT09MRUFOIH0sXG4gICAgeyBuYW1lOiAnV0VCR0xfVkVSU0lPTicsIHR5cGU6IFR5cGUuTlVNQkVSIH0sXG4gICAgeyBuYW1lOiAnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJywgdHlwZTogVHlwZS5CT09MRUFOIH1cbl07XG5mdW5jdGlvbiBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQod2ViR0xWZXJzaW9uKSB7XG4gICAgaWYgKHdlYkdMVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBnZXQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQsIFdlYkdMIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgICB2YXIgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICh0ZW1wQ2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHxcbiAgICAgICAgICAgIHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJykpO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcENhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInKTtcbn1cbmZ1bmN0aW9uIGxvc2VDb250ZXh0KGdsKSB7XG4gICAgaWYgKGdsICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGxvc2VDb250ZXh0RXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKTtcbiAgICAgICAgaWYgKGxvc2VDb250ZXh0RXh0ZW5zaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXh0ZW5zaW9uIFdFQkdMX2xvc2VfY29udGV4dCBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBsb3NlQ29udGV4dEV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzV2ViR0xWZXJzaW9uRW5hYmxlZCh3ZWJHTFZlcnNpb24pIHtcbiAgICB2YXIgZ2wgPSBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQod2ViR0xWZXJzaW9uKTtcbiAgICBpZiAoZ2wgIT0gbnVsbCkge1xuICAgICAgICBsb3NlQ29udGV4dChnbCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1dlYkdMRGlzam9pbnRRdWVyeVRpbWVyRW5hYmxlZCh3ZWJHTFZlcnNpb24pIHtcbiAgICB2YXIgZ2wgPSBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQod2ViR0xWZXJzaW9uKTtcbiAgICB2YXIgZXh0ZW5zaW9uTmFtZSA9IHdlYkdMVmVyc2lvbiA9PT0gMSA/ICdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnknIDpcbiAgICAgICAgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInO1xuICAgIHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oZXh0ZW5zaW9uTmFtZSk7XG4gICAgdmFyIGlzRXh0RW5hYmxlZCA9IGV4dCAhPSBudWxsO1xuICAgIGlmIChnbCAhPSBudWxsKSB7XG4gICAgICAgIGxvc2VDb250ZXh0KGdsKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRXh0RW5hYmxlZDtcbn1cbmZ1bmN0aW9uIGlzRmxvYXRUZXh0dXJlUmVhZFBpeGVsc0VuYWJsZWQod2ViR0xWZXJzaW9uKSB7XG4gICAgaWYgKHdlYkdMVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBnbCA9IGdldFdlYkdMUmVuZGVyaW5nQ29udGV4dCh3ZWJHTFZlcnNpb24pO1xuICAgIHZhciBmbG9hdEV4dGVuc2lvbjtcbiAgICB2YXIgY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbjtcbiAgICBpZiAod2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIGZsb2F0RXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpO1xuICAgICAgICBjb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcbiAgICAgICAgaWYgKGZsb2F0RXh0ZW5zaW9uID09IG51bGwgfHwgY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcbiAgICAgICAgaWYgKGNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBmcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgdmFyIGludGVybmFsRm9ybWF0ID0gd2ViR0xWZXJzaW9uID09PSAyID8gZ2wuUkdCQTMyRiA6IGdsLlJHQkE7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG4gICAgdmFyIGZyYW1lQnVmZmVyQ29tcGxldGUgPSAoZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUikgPT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKTtcbiAgICBsb3NlQ29udGV4dChnbCk7XG4gICAgcmV0dXJuIGZyYW1lQnVmZmVyQ29tcGxldGU7XG59XG52YXIgRW52aXJvbm1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVudmlyb25tZW50KGZlYXR1cmVzKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSB7fTtcbiAgICAgICAgaWYgKGZlYXR1cmVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKGZlYXR1cmUgaW4gdGhpcy5mZWF0dXJlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNbZmVhdHVyZV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mZWF0dXJlc1tmZWF0dXJlXSA9IHRoaXMuZXZhbHVhdGVGZWF0dXJlKGZlYXR1cmUpO1xuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1tmZWF0dXJlXTtcbiAgICB9O1xuICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5ldmFsdWF0ZUZlYXR1cmUgPSBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICBpZiAoZmVhdHVyZSA9PT0gJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9FTkFCTEVEJykge1xuICAgICAgICAgICAgdmFyIHdlYkdMVmVyc2lvbiA9IHRoaXMuZ2V0KCdXRUJHTF9WRVJTSU9OJyk7XG4gICAgICAgICAgICBpZiAod2ViR0xWZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzV2ViR0xEaXNqb2ludFF1ZXJ5VGltZXJFbmFibGVkKHdlYkdMVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX0VOQUJMRUQnKSAmJlxuICAgICAgICAgICAgICAgICFkZXZpY2VfdXRpbC5pc01vYmlsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZlYXR1cmUgPT09ICdXRUJHTF9WRVJTSU9OJykge1xuICAgICAgICAgICAgaWYgKGlzV2ViR0xWZXJzaW9uRW5hYmxlZCgyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNXZWJHTFZlcnNpb25FbmFibGVkKDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmZWF0dXJlID09PSAnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykge1xuICAgICAgICAgICAgcmV0dXJuIGlzRmxvYXRUZXh0dXJlUmVhZFBpeGVsc0VuYWJsZWQodGhpcy5nZXQoJ1dFQkdMX1ZFUlNJT04nKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBmZWF0dXJlIFwiICsgZmVhdHVyZSArIFwiLlwiKTtcbiAgICB9O1xuICAgIHJldHVybiBFbnZpcm9ubWVudDtcbn0oKSk7XG5leHBvcnRzLkVudmlyb25tZW50ID0gRW52aXJvbm1lbnQ7XG52YXIgREVFUExFQVJOSlNfRkxBR1NfUFJFRklYID0gJ2RsanNmbGFncyc7XG5mdW5jdGlvbiBnZXRGZWF0dXJlc0Zyb21VUkwoKSB7XG4gICAgdmFyIGZlYXR1cmVzID0ge307XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICB9XG4gICAgdmFyIHVybFBhcmFtcyA9IHV0aWwuZ2V0UXVlcnlQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgaWYgKERFRVBMRUFSTkpTX0ZMQUdTX1BSRUZJWCBpbiB1cmxQYXJhbXMpIHtcbiAgICAgICAgdmFyIHVybEZsYWdzXzEgPSB7fTtcbiAgICAgICAgdmFyIGtleVZhbHVlcyA9IHVybFBhcmFtc1tERUVQTEVBUk5KU19GTEFHU19QUkVGSVhdLnNwbGl0KCcsJyk7XG4gICAgICAgIGtleVZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIF9hID0ga2V5VmFsdWUuc3BsaXQoJzonKSwga2V5ID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XG4gICAgICAgICAgICB1cmxGbGFnc18xW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cG9ydHMuVVJMX1BST1BFUlRJRVMuZm9yRWFjaChmdW5jdGlvbiAodXJsUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGlmICh1cmxQcm9wZXJ0eS5uYW1lIGluIHVybEZsYWdzXzEpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNldHRpbmcgZmVhdHVyZSBvdmVycmlkZSBmcm9tIFVSTCBcIiArIHVybFByb3BlcnR5Lm5hbWUgKyBcIjogXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJcIiArIHVybEZsYWdzXzFbdXJsUHJvcGVydHkubmFtZV0pKTtcbiAgICAgICAgICAgICAgICBpZiAodXJsUHJvcGVydHkudHlwZSA9PT0gVHlwZS5OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXNbdXJsUHJvcGVydHkubmFtZV0gPSArdXJsRmxhZ3NfMVt1cmxQcm9wZXJ0eS5uYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXJsUHJvcGVydHkudHlwZSA9PT0gVHlwZS5CT09MRUFOKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzW3VybFByb3BlcnR5Lm5hbWVdID0gdXJsRmxhZ3NfMVt1cmxQcm9wZXJ0eS5uYW1lXSA9PT0gJ3RydWUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBVUkwgcGFyYW06IFwiICsgdXJsUHJvcGVydHkubmFtZSArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZXM7XG59XG5leHBvcnRzLkVOViA9IG5ldyBFbnZpcm9ubWVudChnZXRGZWF0dXJlc0Zyb21VUkwoKSk7XG5mdW5jdGlvbiBzZXRFbnZpcm9ubWVudChlbnZpcm9ubWVudCkge1xuICAgIGV4cG9ydHMuRU5WID0gZW52aXJvbm1lbnQ7XG59XG5leHBvcnRzLnNldEVudmlyb25tZW50ID0gc2V0RW52aXJvbm1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnZpcm9ubWVudC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/environment.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/graph.js":
/*!********************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/graph.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar initializers_1 = __webpack_require__(/*! ../initializers */ \"./node_modules/deeplearn/dist/src/initializers.js\");\nvar concat_util = __webpack_require__(/*! ../math/concat_util */ \"./node_modules/deeplearn/dist/src/math/concat_util.js\");\nvar conv_util = __webpack_require__(/*! ../math/conv_util */ \"./node_modules/deeplearn/dist/src/math/conv_util.js\");\nvar ndarray_1 = __webpack_require__(/*! ../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar GraphLayers = (function () {\n    function GraphLayers(g) {\n        this.g = g;\n    }\n    GraphLayers.prototype.dense = function (name, x, units, activation, useBias, kernelInitializer, biasInitializer) {\n        if (activation === void 0) { activation = null; }\n        if (useBias === void 0) { useBias = true; }\n        if (kernelInitializer === void 0) { kernelInitializer = new initializers_1.VarianceScalingInitializer(); }\n        if (biasInitializer === void 0) { biasInitializer = new initializers_1.ZerosInitializer(); }\n        var weights = this.g.variable(name + '-weights', kernelInitializer.initialize([x.shape[0], units], x.shape[0], units));\n        var out = this.g.matmul(x, weights);\n        if (useBias) {\n            var bias = this.g.variable(name + '-bias', biasInitializer.initialize([units], x.shape[0], units));\n            out = this.g.add(out, bias);\n        }\n        if (activation != null) {\n            out = activation(out);\n        }\n        return out;\n    };\n    return GraphLayers;\n}());\nexports.GraphLayers = GraphLayers;\nvar Graph = (function () {\n    function Graph() {\n        this.nodes = [];\n        this.layers = new GraphLayers(this);\n    }\n    Graph.prototype.variable = function (name, data) {\n        return this.addNodeAndReturnOutput(new VariableNode(this, name, data));\n    };\n    Graph.prototype.placeholder = function (name, shape) {\n        return this.addNodeAndReturnOutput(new PlaceholderNode(this, name, shape));\n    };\n    Graph.prototype.constant = function (value) {\n        var finalValue;\n        if (typeof value === 'number') {\n            finalValue = ndarray_1.Scalar.new(value);\n        }\n        else if (value instanceof ndarray_1.NDArray) {\n            finalValue = value;\n        }\n        else if (value instanceof Array) {\n            var vals = new Float32Array(util.flatten(value));\n            finalValue = ndarray_1.NDArray.make(util.inferShape(value), { values: vals });\n        }\n        else {\n            throw new Error('unimplemented constant type.');\n        }\n        return this.addNodeAndReturnOutput(new ConstantNode(this, finalValue));\n    };\n    Graph.prototype.reshape = function (x, shape) {\n        return this.addNodeAndReturnOutput(new ReshapeNode(this, 'Reshape', x, shape));\n    };\n    Graph.prototype.fusedLinearCombination = function (x1, x2, c1, c2) {\n        return this.addNodeAndReturnOutput(new FusedLinearCombinationNode(this, x1, x2, c1, c2));\n    };\n    Graph.prototype.add = function (x1, x2) {\n        return this.addNodeAndReturnOutput(new AddNode(this, x1, x2));\n    };\n    Graph.prototype.subtract = function (x1, x2) {\n        return this.addNodeAndReturnOutput(new SubtractNode(this, x1, x2));\n    };\n    Graph.prototype.multiply = function (x1, x2) {\n        return this.addNodeAndReturnOutput(new MultiplyNode(this, x1, x2));\n    };\n    Graph.prototype.divide = function (x1, x2) {\n        return this.addNodeAndReturnOutput(new DivideNode(this, x1, x2));\n    };\n    Graph.prototype.reduceSum = function (x) {\n        return this.addNodeAndReturnOutput(new ReduceSumNode(this, x));\n    };\n    Graph.prototype.concat3d = function (x1, x2, axis) {\n        return this.addNodeAndReturnOutput(new Concat3DNode(this, x1, x2, axis));\n    };\n    Graph.prototype.matmul = function (x1, x2) {\n        return this.addNodeAndReturnOutput(new MatMulNode(this, x1, x2));\n    };\n    Graph.prototype.conv2d = function (x, w, b, fieldSize, outputDepth, stride, zeroPad) {\n        if (stride === void 0) { stride = 1; }\n        return this.addNodeAndReturnOutput(new Convolution2DNode(this, x, w, b, fieldSize, outputDepth, stride, zeroPad));\n    };\n    Graph.prototype.maxPool = function (x, fieldSize, stride, zeroPad) {\n        if (stride === void 0) { stride = 1; }\n        return this.addNodeAndReturnOutput(new MaxPoolNode(this, x, fieldSize, stride, zeroPad));\n    };\n    Graph.prototype.exp = function (x) {\n        return this.addNodeAndReturnOutput(new ExpNode(this, x));\n    };\n    Graph.prototype.log = function (x) {\n        return this.addNodeAndReturnOutput(new LogNode(this, x));\n    };\n    Graph.prototype.relu = function (x) {\n        return this.addNodeAndReturnOutput(new ReLUNode(this, x));\n    };\n    Graph.prototype.tanh = function (x) {\n        return this.addNodeAndReturnOutput(new TanHNode(this, x));\n    };\n    Graph.prototype.sigmoid = function (x) {\n        return this.addNodeAndReturnOutput(new SigmoidNode(this, x));\n    };\n    Graph.prototype.square = function (x) {\n        return this.addNodeAndReturnOutput(new SquareNode(this, x));\n    };\n    Graph.prototype.softmax = function (x) {\n        return this.addNodeAndReturnOutput(new SoftmaxNode(this, x));\n    };\n    Graph.prototype.softmaxCrossEntropyCost = function (x, target) {\n        return this.addNodeAndReturnOutput(new SoftmaxCrossEntropyCostNode(this, x, target));\n    };\n    Graph.prototype.meanSquaredCost = function (label, prediction) {\n        return this.addNodeAndReturnOutput(new MeanSquaredCostNode(this, label, prediction));\n    };\n    Graph.prototype.argmax = function (x) {\n        return this.addNodeAndReturnOutput(new ArgMaxNode(this, x));\n    };\n    Graph.prototype.argmaxEquals = function (x1, x2) {\n        return this.addNodeAndReturnOutput(new ArgMaxEqualsNode(this, x1, x2));\n    };\n    Graph.prototype.addNodeAndReturnOutput = function (node) {\n        this.nodes.push(node);\n        node.validate();\n        return node.output;\n    };\n    Graph.prototype.getNodes = function () {\n        return this.nodes;\n    };\n    return Graph;\n}());\nexports.Graph = Graph;\nvar Tensor = (function () {\n    function Tensor(shape) {\n        this.shape = shape;\n        this.id = Tensor.nextID++;\n    }\n    Tensor.nextID = 0;\n    return Tensor;\n}());\nexports.Tensor = Tensor;\nvar Node = (function () {\n    function Node(graph, name, inputs, output) {\n        this.graph = graph;\n        this.name = name;\n        this.inputs = inputs;\n        this.output = output;\n        this.id = Node.nextID++;\n        output.node = this;\n    }\n    Node.nextID = 0;\n    return Node;\n}());\nexports.Node = Node;\nvar VariableNode = (function (_super) {\n    __extends(VariableNode, _super);\n    function VariableNode(graph, name, data) {\n        var _this = _super.call(this, graph, name, {}, new Tensor(data.shape)) || this;\n        _this.data = data;\n        return _this;\n    }\n    VariableNode.prototype.validate = function () {\n        util.assert(this.data != null, 'Error adding variable op: Data for variable \\'' + this.name +\n            '\\' is null or undefined');\n    };\n    return VariableNode;\n}(Node));\nexports.VariableNode = VariableNode;\nvar PlaceholderNode = (function (_super) {\n    __extends(PlaceholderNode, _super);\n    function PlaceholderNode(graph, name, shape) {\n        return _super.call(this, graph, name, {}, new Tensor(shape)) || this;\n    }\n    PlaceholderNode.prototype.validate = function () { };\n    return PlaceholderNode;\n}(Node));\nexports.PlaceholderNode = PlaceholderNode;\nvar ConstantNode = (function (_super) {\n    __extends(ConstantNode, _super);\n    function ConstantNode(graph, data) {\n        var _this = _super.call(this, graph, 'Constant', {}, new Tensor(data.shape)) || this;\n        _this.data = data;\n        return _this;\n    }\n    ConstantNode.prototype.validate = function () {\n        util.assert(this.data != null, 'Error adding constant: data for placeholder \\'' + this.name +\n            '\\' is null or undefined');\n    };\n    return ConstantNode;\n}(Node));\nexports.ConstantNode = ConstantNode;\nvar ReshapeNode = (function (_super) {\n    __extends(ReshapeNode, _super);\n    function ReshapeNode(graph, name, x, shape) {\n        var _this = _super.call(this, graph, name, { x: x }, new Tensor(shape)) || this;\n        _this.name = name;\n        _this.x = x;\n        _this.shape = shape;\n        return _this;\n    }\n    ReshapeNode.prototype.validate = function () {\n        var xSize = util.sizeFromShape(this.x.shape);\n        var shapeSize = util.sizeFromShape(this.shape);\n        util.assert(xSize === shapeSize, 'Error making reshape operation: input Tensor to reshape \\'' +\n            this.name + '\\' of shape (' + this.x.shape +\n            ') does not match size of requested shape ' + this.shape + '.');\n    };\n    ReshapeNode.X = 'x';\n    return ReshapeNode;\n}(Node));\nexports.ReshapeNode = ReshapeNode;\nvar FusedLinearCombinationNode = (function (_super) {\n    __extends(FusedLinearCombinationNode, _super);\n    function FusedLinearCombinationNode(graph, t1, t2, c1, c2) {\n        var _this = _super.call(this, graph, 'Linear Combination', { t1: t1, t2: t2, c1: c1, c2: c2 }, new Tensor(t1.shape)) || this;\n        _this.t1 = t1;\n        _this.t2 = t2;\n        _this.c1 = c1;\n        _this.c2 = c2;\n        return _this;\n    }\n    FusedLinearCombinationNode.prototype.validate = function () {\n        util.assertShapesMatch(this.t1.shape, this.t2.shape);\n        if (!util.isScalarShape(this.c1.shape)) {\n            throw new Error('Error adding fusedLinearCombination: c1 is not a scalar, got ' +\n                'shape: ' + this.c1.shape);\n        }\n        if (!util.isScalarShape(this.c2.shape)) {\n            throw new Error('Error adding fusedLinearCombination: c2 is not a scalar, got ' +\n                'shape: ' + this.c2.shape);\n        }\n    };\n    FusedLinearCombinationNode.T1 = 't1';\n    FusedLinearCombinationNode.T2 = 't2';\n    FusedLinearCombinationNode.C1 = 'c1';\n    FusedLinearCombinationNode.C2 = 'c2';\n    return FusedLinearCombinationNode;\n}(Node));\nexports.FusedLinearCombinationNode = FusedLinearCombinationNode;\nvar AddNode = (function (_super) {\n    __extends(AddNode, _super);\n    function AddNode(graph, t1, t2) {\n        var _this = _super.call(this, graph, 'Add', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;\n        _this.t1 = t1;\n        _this.t2 = t2;\n        return _this;\n    }\n    AddNode.prototype.validate = function () {\n        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||\n            util.sizeFromShape(this.t2.shape) === 1 ||\n            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding add operation op: one of inputs must be scalar or the ' +\n            'shapes ' + this.t1.shape + ' and ' + this.t2.shape +\n            ' must match.');\n    };\n    AddNode.T1 = 't1';\n    AddNode.T2 = 't2';\n    return AddNode;\n}(Node));\nexports.AddNode = AddNode;\nvar SubtractNode = (function (_super) {\n    __extends(SubtractNode, _super);\n    function SubtractNode(graph, t1, t2) {\n        var _this = _super.call(this, graph, 'Subtract', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;\n        _this.t1 = t1;\n        _this.t2 = t2;\n        return _this;\n    }\n    SubtractNode.prototype.validate = function () {\n        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||\n            util.sizeFromShape(this.t2.shape) === 1 ||\n            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding subtract op: one of inputs must be scalar or the ' +\n            'shapes ' + this.t1.shape + ' and ' + this.t2.shape +\n            ' must match.');\n    };\n    SubtractNode.T1 = 't1';\n    SubtractNode.T2 = 't2';\n    return SubtractNode;\n}(Node));\nexports.SubtractNode = SubtractNode;\nvar MultiplyNode = (function (_super) {\n    __extends(MultiplyNode, _super);\n    function MultiplyNode(graph, t1, t2) {\n        var _this = _super.call(this, graph, 'Multiply', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;\n        _this.t1 = t1;\n        _this.t2 = t2;\n        return _this;\n    }\n    MultiplyNode.prototype.validate = function () {\n        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||\n            util.sizeFromShape(this.t2.shape) === 1 ||\n            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding multiply op: one of inputs must be scalar or the ' +\n            'shapes ' + this.t1.shape + ' and ' + this.t2.shape +\n            ' must match.');\n    };\n    MultiplyNode.T1 = 't1';\n    MultiplyNode.T2 = 't2';\n    return MultiplyNode;\n}(Node));\nexports.MultiplyNode = MultiplyNode;\nvar DivideNode = (function (_super) {\n    __extends(DivideNode, _super);\n    function DivideNode(graph, t1, t2) {\n        var _this = _super.call(this, graph, 'Divide', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;\n        _this.t1 = t1;\n        _this.t2 = t2;\n        return _this;\n    }\n    DivideNode.prototype.validate = function () {\n        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||\n            util.sizeFromShape(this.t2.shape) === 1 ||\n            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding divide op: one of inputs must be scalar or the ' +\n            'shapes ' + this.t1.shape + ' and ' + this.t2.shape +\n            ' must match.');\n    };\n    DivideNode.T1 = 't1';\n    DivideNode.T2 = 't2';\n    return DivideNode;\n}(Node));\nexports.DivideNode = DivideNode;\nvar ReduceSumNode = (function (_super) {\n    __extends(ReduceSumNode, _super);\n    function ReduceSumNode(graph, x) {\n        return _super.call(this, graph, 'ReduceSum', { x: x }, new Tensor([])) || this;\n    }\n    ReduceSumNode.prototype.validate = function () { };\n    ReduceSumNode.X = 'x';\n    return ReduceSumNode;\n}(Node));\nexports.ReduceSumNode = ReduceSumNode;\nvar Concat3DNode = (function (_super) {\n    __extends(Concat3DNode, _super);\n    function Concat3DNode(graph, x1, x2, axis) {\n        var _this = _super.call(this, graph, 'Concat3D', { x1: x1, x2: x2 }, new Tensor(concat_util.computeOutShape(x1.shape, x2.shape, axis))) || this;\n        _this.x1 = x1;\n        _this.x2 = x2;\n        _this.axis = axis;\n        return _this;\n    }\n    Concat3DNode.prototype.validate = function () {\n        concat_util.assertParams(this.x1.shape, this.x2.shape, this.axis);\n    };\n    Concat3DNode.X1 = 'x1';\n    Concat3DNode.X2 = 'x2';\n    Concat3DNode.AXIS = 'axis';\n    return Concat3DNode;\n}(Node));\nexports.Concat3DNode = Concat3DNode;\nfunction getMatMulOutputShape(x1Shape, x2Shape) {\n    if (x1Shape.length === 1 && x2Shape.length === 1) {\n        return [1];\n    }\n    else if (x1Shape.length === 1 && x2Shape.length === 2) {\n        return [x2Shape[1]];\n    }\n    else if (x1Shape.length === 2 && x2Shape.length === 1) {\n        return [x1Shape[0]];\n    }\n    return [x1Shape[0], x2Shape[1]];\n}\nvar MatMulNode = (function (_super) {\n    __extends(MatMulNode, _super);\n    function MatMulNode(graph, x1, x2) {\n        var _this = _super.call(this, graph, 'MatMul', { x1: x1, x2: x2 }, new Tensor(getMatMulOutputShape(x1.shape, x2.shape))) || this;\n        _this.x1 = x1;\n        _this.x2 = x2;\n        return _this;\n    }\n    MatMulNode.prototype.validate = function () {\n        if (this.x1.shape.length === 2 && this.x2.shape.length === 2) {\n            util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: inner shapes of matrices with shapes ' +\n                this.x1.shape + ' and ' + this.x2.shape + ' must match.');\n        }\n        else if (this.x1.shape.length === 2 && this.x2.shape.length === 1) {\n            util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: second dimension of matrix with shape ' +\n                this.x1.shape + ' must match size of vector with shape ' +\n                this.x2.shape + '.');\n        }\n        else if (this.x1.shape.length === 1 && this.x2.shape.length === 2) {\n            util.assert(this.x1.shape[0] === this.x2.shape[0], 'Error adding matmul op: size of vector with shape ' + this.x1.shape +\n                ' must match first dimension of matrix with ' +\n                'shape ' + this.x2.shape + '.');\n        }\n        else {\n            throw new Error('Error adding matmul op: inputs must be vectors or matrices.');\n        }\n    };\n    MatMulNode.X1 = 'x1';\n    MatMulNode.X2 = 'x2';\n    return MatMulNode;\n}(Node));\nexports.MatMulNode = MatMulNode;\nvar Convolution2DNode = (function (_super) {\n    __extends(Convolution2DNode, _super);\n    function Convolution2DNode(graph, x, w, b, fieldSize, outputDepth, stride, zeroPad) {\n        if (stride === void 0) { stride = 1; }\n        var _this = _super.call(this, graph, 'Convolution 2D', { x: x, w: w, b: b }, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, outputDepth, stride, zeroPad))) || this;\n        _this.x = x;\n        _this.w = w;\n        _this.b = b;\n        _this.fieldSize = fieldSize;\n        _this.outputDepth = outputDepth;\n        _this.stride = stride;\n        _this.zeroPad = zeroPad;\n        return _this;\n    }\n    Convolution2DNode.prototype.validate = function () {\n        util.assert(this.x.shape.length === 3, 'Error adding conv2d op: input must be of rank 3, but got shape: ' +\n            this.x.shape + '.');\n        util.assert(this.w.shape.length === 4, 'Error adding conv2d op: weights must be of rank 4, but got shape: ' +\n            this.w.shape + '.');\n        util.assert(this.b.shape.length === 1, 'Error adding conv2d op: biases must be of rank 1, but got shape: ' +\n            this.b.shape + '.');\n        util.assert(this.x.shape[2] === this.w.shape[2], 'Error adding conv2d op: depth of input (' + this.x.shape[2] +\n            ') must match input depth for weights (' + this.w.shape[2] + ').');\n    };\n    Convolution2DNode.X = 'x';\n    Convolution2DNode.W = 'w';\n    Convolution2DNode.B = 'b';\n    return Convolution2DNode;\n}(Node));\nexports.Convolution2DNode = Convolution2DNode;\nvar MaxPoolNode = (function (_super) {\n    __extends(MaxPoolNode, _super);\n    function MaxPoolNode(graph, x, fieldSize, stride, zeroPad) {\n        if (stride === void 0) { stride = 1; }\n        var _this = _super.call(this, graph, 'Max pool', { x: x }, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, x.shape[2], stride, zeroPad))) || this;\n        _this.x = x;\n        _this.fieldSize = fieldSize;\n        _this.stride = stride;\n        _this.zeroPad = zeroPad;\n        return _this;\n    }\n    MaxPoolNode.prototype.validate = function () {\n        util.assert(this.x.shape.length === 3, 'Error adding maxPool op: input must be of rank 3, but got shape: ' +\n            this.x.shape + '.');\n    };\n    MaxPoolNode.X = 'x';\n    return MaxPoolNode;\n}(Node));\nexports.MaxPoolNode = MaxPoolNode;\nvar ReLUNode = (function (_super) {\n    __extends(ReLUNode, _super);\n    function ReLUNode(graph, x) {\n        return _super.call(this, graph, 'ReLU', { x: x }, new Tensor(x.shape)) || this;\n    }\n    ReLUNode.prototype.validate = function () { };\n    ReLUNode.X = 'x';\n    return ReLUNode;\n}(Node));\nexports.ReLUNode = ReLUNode;\nvar ExpNode = (function (_super) {\n    __extends(ExpNode, _super);\n    function ExpNode(graph, x) {\n        return _super.call(this, graph, 'Exp', { x: x }, new Tensor(x.shape)) || this;\n    }\n    ExpNode.prototype.validate = function () { };\n    ExpNode.X = 'x';\n    return ExpNode;\n}(Node));\nexports.ExpNode = ExpNode;\nvar LogNode = (function (_super) {\n    __extends(LogNode, _super);\n    function LogNode(graph, x) {\n        return _super.call(this, graph, 'Log', { x: x }, new Tensor(x.shape)) || this;\n    }\n    LogNode.prototype.validate = function () { };\n    LogNode.X = 'x';\n    return LogNode;\n}(Node));\nexports.LogNode = LogNode;\nvar TanHNode = (function (_super) {\n    __extends(TanHNode, _super);\n    function TanHNode(graph, x) {\n        return _super.call(this, graph, 'TanH', { x: x }, new Tensor(x.shape)) || this;\n    }\n    TanHNode.prototype.validate = function () { };\n    TanHNode.X = 'x';\n    return TanHNode;\n}(Node));\nexports.TanHNode = TanHNode;\nvar SigmoidNode = (function (_super) {\n    __extends(SigmoidNode, _super);\n    function SigmoidNode(graph, x) {\n        return _super.call(this, graph, 'Sigmoid', { x: x }, new Tensor(x.shape)) || this;\n    }\n    SigmoidNode.prototype.validate = function () { };\n    SigmoidNode.X = 'x';\n    return SigmoidNode;\n}(Node));\nexports.SigmoidNode = SigmoidNode;\nvar SquareNode = (function (_super) {\n    __extends(SquareNode, _super);\n    function SquareNode(graph, x) {\n        return _super.call(this, graph, 'Square', { x: x }, new Tensor(x.shape)) || this;\n    }\n    SquareNode.prototype.validate = function () { };\n    SquareNode.X = 'x';\n    return SquareNode;\n}(Node));\nexports.SquareNode = SquareNode;\nvar SoftmaxCrossEntropyCostNode = (function (_super) {\n    __extends(SoftmaxCrossEntropyCostNode, _super);\n    function SoftmaxCrossEntropyCostNode(graph, x, target) {\n        var _this = _super.call(this, graph, 'SoftmaxCrossEntropyCost', { x: x, target: target }, new Tensor([])) || this;\n        _this.x = x;\n        _this.target = target;\n        return _this;\n    }\n    SoftmaxCrossEntropyCostNode.prototype.validate = function () {\n        util.assert(util.arraysEqual(this.x.shape, this.target.shape), 'Error adding softmaxCrossEntropyCost op: x shape (' + this.x.shape +\n            ') must match target shape (' + this.target.shape + ').');\n    };\n    SoftmaxCrossEntropyCostNode.X = 'x';\n    SoftmaxCrossEntropyCostNode.TARGET = 'target';\n    return SoftmaxCrossEntropyCostNode;\n}(Node));\nexports.SoftmaxCrossEntropyCostNode = SoftmaxCrossEntropyCostNode;\nvar SoftmaxNode = (function (_super) {\n    __extends(SoftmaxNode, _super);\n    function SoftmaxNode(graph, x) {\n        var _this = _super.call(this, graph, 'Softmax', { x: x }, new Tensor(x.shape)) || this;\n        _this.x = x;\n        return _this;\n    }\n    SoftmaxNode.prototype.validate = function () {\n        util.assert(this.x.shape.length === 1, 'The input to a softmax must be a 1-D tensor');\n        util.assert(this.x.shape[0] >= 2, 'The input to a softmax must have at least 2 values');\n    };\n    SoftmaxNode.X = 'x';\n    return SoftmaxNode;\n}(Node));\nexports.SoftmaxNode = SoftmaxNode;\nvar MeanSquaredCostNode = (function (_super) {\n    __extends(MeanSquaredCostNode, _super);\n    function MeanSquaredCostNode(graph, label, prediction) {\n        var _this = _super.call(this, graph, 'Mean Squared Cost', { label: label, prediction: prediction }, new Tensor([])) || this;\n        _this.label = label;\n        _this.prediction = prediction;\n        return _this;\n    }\n    MeanSquaredCostNode.prototype.validate = function () {\n        util.assert(util.arraysEqual(this.label.shape, this.prediction.shape), 'Error adding meanSquaredCost op: label shape (' + this.label.shape +\n            ') must match prediction shape (' + this.prediction.shape + ').');\n    };\n    MeanSquaredCostNode.LABEL = 'label';\n    MeanSquaredCostNode.PREDICTION = 'prediction';\n    return MeanSquaredCostNode;\n}(Node));\nexports.MeanSquaredCostNode = MeanSquaredCostNode;\nvar ArgMaxNode = (function (_super) {\n    __extends(ArgMaxNode, _super);\n    function ArgMaxNode(graph, x) {\n        var _this = _super.call(this, graph, 'ArgMax', { x: x }, new Tensor([1])) || this;\n        _this.x = x;\n        return _this;\n    }\n    ArgMaxNode.prototype.validate = function () {\n        util.assert(util.sizeFromShape(this.x.shape) > 0, 'Error adding argmax op: input tensor must have at least one entry.');\n    };\n    ArgMaxNode.X = 'x';\n    return ArgMaxNode;\n}(Node));\nexports.ArgMaxNode = ArgMaxNode;\nvar ArgMaxEqualsNode = (function (_super) {\n    __extends(ArgMaxEqualsNode, _super);\n    function ArgMaxEqualsNode(graph, x1, x2) {\n        var _this = _super.call(this, graph, 'ArgMaxEquals', { x1: x1, x2: x2 }, new Tensor([1])) || this;\n        _this.x1 = x1;\n        _this.x2 = x2;\n        return _this;\n    }\n    ArgMaxEqualsNode.prototype.validate = function () {\n        util.assert(util.arraysEqual(this.x1.shape, this.x2.shape), 'Error adding ArgMaxEquals op: x1 shape (' + this.x1.shape +\n            ') must match x2 shape (' + this.x2.shape + ').');\n    };\n    ArgMaxEqualsNode.X1 = 'x1';\n    ArgMaxEqualsNode.X2 = 'x2';\n    return ArgMaxEqualsNode;\n}(Node));\nexports.ArgMaxEqualsNode = ArgMaxEqualsNode;\n//# sourceMappingURL=graph.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL2dyYXBoLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9ncmFwaC5qcz9jNTVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaW5pdGlhbGl6ZXJzXzEgPSByZXF1aXJlKFwiLi4vaW5pdGlhbGl6ZXJzXCIpO1xudmFyIGNvbmNhdF91dGlsID0gcmVxdWlyZShcIi4uL21hdGgvY29uY2F0X3V0aWxcIik7XG52YXIgY29udl91dGlsID0gcmVxdWlyZShcIi4uL21hdGgvY29udl91dGlsXCIpO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIEdyYXBoTGF5ZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHcmFwaExheWVycyhnKSB7XG4gICAgICAgIHRoaXMuZyA9IGc7XG4gICAgfVxuICAgIEdyYXBoTGF5ZXJzLnByb3RvdHlwZS5kZW5zZSA9IGZ1bmN0aW9uIChuYW1lLCB4LCB1bml0cywgYWN0aXZhdGlvbiwgdXNlQmlhcywga2VybmVsSW5pdGlhbGl6ZXIsIGJpYXNJbml0aWFsaXplcikge1xuICAgICAgICBpZiAoYWN0aXZhdGlvbiA9PT0gdm9pZCAwKSB7IGFjdGl2YXRpb24gPSBudWxsOyB9XG4gICAgICAgIGlmICh1c2VCaWFzID09PSB2b2lkIDApIHsgdXNlQmlhcyA9IHRydWU7IH1cbiAgICAgICAgaWYgKGtlcm5lbEluaXRpYWxpemVyID09PSB2b2lkIDApIHsga2VybmVsSW5pdGlhbGl6ZXIgPSBuZXcgaW5pdGlhbGl6ZXJzXzEuVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXIoKTsgfVxuICAgICAgICBpZiAoYmlhc0luaXRpYWxpemVyID09PSB2b2lkIDApIHsgYmlhc0luaXRpYWxpemVyID0gbmV3IGluaXRpYWxpemVyc18xLlplcm9zSW5pdGlhbGl6ZXIoKTsgfVxuICAgICAgICB2YXIgd2VpZ2h0cyA9IHRoaXMuZy52YXJpYWJsZShuYW1lICsgJy13ZWlnaHRzJywga2VybmVsSW5pdGlhbGl6ZXIuaW5pdGlhbGl6ZShbeC5zaGFwZVswXSwgdW5pdHNdLCB4LnNoYXBlWzBdLCB1bml0cykpO1xuICAgICAgICB2YXIgb3V0ID0gdGhpcy5nLm1hdG11bCh4LCB3ZWlnaHRzKTtcbiAgICAgICAgaWYgKHVzZUJpYXMpIHtcbiAgICAgICAgICAgIHZhciBiaWFzID0gdGhpcy5nLnZhcmlhYmxlKG5hbWUgKyAnLWJpYXMnLCBiaWFzSW5pdGlhbGl6ZXIuaW5pdGlhbGl6ZShbdW5pdHNdLCB4LnNoYXBlWzBdLCB1bml0cykpO1xuICAgICAgICAgICAgb3V0ID0gdGhpcy5nLmFkZChvdXQsIGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIG91dCA9IGFjdGl2YXRpb24ob3V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgcmV0dXJuIEdyYXBoTGF5ZXJzO1xufSgpKTtcbmV4cG9ydHMuR3JhcGhMYXllcnMgPSBHcmFwaExheWVycztcbnZhciBHcmFwaCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JhcGgoKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5sYXllcnMgPSBuZXcgR3JhcGhMYXllcnModGhpcyk7XG4gICAgfVxuICAgIEdyYXBoLnByb3RvdHlwZS52YXJpYWJsZSA9IGZ1bmN0aW9uIChuYW1lLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFZhcmlhYmxlTm9kZSh0aGlzLCBuYW1lLCBkYXRhKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUucGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAobmFtZSwgc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgUGxhY2Vob2xkZXJOb2RlKHRoaXMsIG5hbWUsIHNoYXBlKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuY29uc3RhbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpbmFsVmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gbmRhcnJheV8xLlNjYWxhci5uZXcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpIHtcbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB2YXIgdmFscyA9IG5ldyBGbG9hdDMyQXJyYXkodXRpbC5mbGF0dGVuKHZhbHVlKSk7XG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gbmRhcnJheV8xLk5EQXJyYXkubWFrZSh1dGlsLmluZmVyU2hhcGUodmFsdWUpLCB7IHZhbHVlczogdmFscyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5pbXBsZW1lbnRlZCBjb25zdGFudCB0eXBlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IENvbnN0YW50Tm9kZSh0aGlzLCBmaW5hbFZhbHVlKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUucmVzaGFwZSA9IGZ1bmN0aW9uICh4LCBzaGFwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBSZXNoYXBlTm9kZSh0aGlzLCAnUmVzaGFwZScsIHgsIHNoYXBlKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuZnVzZWRMaW5lYXJDb21iaW5hdGlvbiA9IGZ1bmN0aW9uICh4MSwgeDIsIGMxLCBjMikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZSh0aGlzLCB4MSwgeDIsIGMxLCBjMikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh4MSwgeDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQWRkTm9kZSh0aGlzLCB4MSwgeDIpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uICh4MSwgeDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgU3VidHJhY3ROb2RlKHRoaXMsIHgxLCB4MikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBNdWx0aXBseU5vZGUodGhpcywgeDEsIHgyKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBEaXZpZGVOb2RlKHRoaXMsIHgxLCB4MikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnJlZHVjZVN1bSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFJlZHVjZVN1bU5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmNvbmNhdDNkID0gZnVuY3Rpb24gKHgxLCB4MiwgYXhpcykge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBDb25jYXQzRE5vZGUodGhpcywgeDEsIHgyLCBheGlzKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUubWF0bXVsID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBNYXRNdWxOb2RlKHRoaXMsIHgxLCB4MikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmNvbnYyZCA9IGZ1bmN0aW9uICh4LCB3LCBiLCBmaWVsZFNpemUsIG91dHB1dERlcHRoLCBzdHJpZGUsIHplcm9QYWQpIHtcbiAgICAgICAgaWYgKHN0cmlkZSA9PT0gdm9pZCAwKSB7IHN0cmlkZSA9IDE7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQ29udm9sdXRpb24yRE5vZGUodGhpcywgeCwgdywgYiwgZmllbGRTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUubWF4UG9vbCA9IGZ1bmN0aW9uICh4LCBmaWVsZFNpemUsIHN0cmlkZSwgemVyb1BhZCkge1xuICAgICAgICBpZiAoc3RyaWRlID09PSB2b2lkIDApIHsgc3RyaWRlID0gMTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBNYXhQb29sTm9kZSh0aGlzLCB4LCBmaWVsZFNpemUsIHN0cmlkZSwgemVyb1BhZCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IEV4cE5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IExvZ05vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnJlbHUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBSZUxVTm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUudGFuaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFRhbkhOb2RlKHRoaXMsIHgpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5zaWdtb2lkID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgU2lnbW9pZE5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFNxdWFyZU5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnNvZnRtYXggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBTb2Z0bWF4Tm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuc29mdG1heENyb3NzRW50cm9weUNvc3QgPSBmdW5jdGlvbiAoeCwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZSh0aGlzLCB4LCB0YXJnZXQpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5tZWFuU3F1YXJlZENvc3QgPSBmdW5jdGlvbiAobGFiZWwsIHByZWRpY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgTWVhblNxdWFyZWRDb3N0Tm9kZSh0aGlzLCBsYWJlbCwgcHJlZGljdGlvbikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmFyZ21heCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IEFyZ01heE5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmFyZ21heEVxdWFscyA9IGZ1bmN0aW9uICh4MSwgeDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQXJnTWF4RXF1YWxzTm9kZSh0aGlzLCB4MSwgeDIpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5hZGROb2RlQW5kUmV0dXJuT3V0cHV0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICBub2RlLnZhbGlkYXRlKCk7XG4gICAgICAgIHJldHVybiBub2RlLm91dHB1dDtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5nZXROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXM7XG4gICAgfTtcbiAgICByZXR1cm4gR3JhcGg7XG59KCkpO1xuZXhwb3J0cy5HcmFwaCA9IEdyYXBoO1xudmFyIFRlbnNvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVuc29yKHNoYXBlKSB7XG4gICAgICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcbiAgICAgICAgdGhpcy5pZCA9IFRlbnNvci5uZXh0SUQrKztcbiAgICB9XG4gICAgVGVuc29yLm5leHRJRCA9IDA7XG4gICAgcmV0dXJuIFRlbnNvcjtcbn0oKSk7XG5leHBvcnRzLlRlbnNvciA9IFRlbnNvcjtcbnZhciBOb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlKGdyYXBoLCBuYW1lLCBpbnB1dHMsIG91dHB1dCkge1xuICAgICAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICAgICAgdGhpcy5pZCA9IE5vZGUubmV4dElEKys7XG4gICAgICAgIG91dHB1dC5ub2RlID0gdGhpcztcbiAgICB9XG4gICAgTm9kZS5uZXh0SUQgPSAwO1xuICAgIHJldHVybiBOb2RlO1xufSgpKTtcbmV4cG9ydHMuTm9kZSA9IE5vZGU7XG52YXIgVmFyaWFibGVOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmFyaWFibGVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZhcmlhYmxlTm9kZShncmFwaCwgbmFtZSwgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgbmFtZSwge30sIG5ldyBUZW5zb3IoZGF0YS5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFZhcmlhYmxlTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMuZGF0YSAhPSBudWxsLCAnRXJyb3IgYWRkaW5nIHZhcmlhYmxlIG9wOiBEYXRhIGZvciB2YXJpYWJsZSBcXCcnICsgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICdcXCcgaXMgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICB9O1xuICAgIHJldHVybiBWYXJpYWJsZU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuVmFyaWFibGVOb2RlID0gVmFyaWFibGVOb2RlO1xudmFyIFBsYWNlaG9sZGVyTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBsYWNlaG9sZGVyTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQbGFjZWhvbGRlck5vZGUoZ3JhcGgsIG5hbWUsIHNoYXBlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgbmFtZSwge30sIG5ldyBUZW5zb3Ioc2hhcGUpKSB8fCB0aGlzO1xuICAgIH1cbiAgICBQbGFjZWhvbGRlck5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBQbGFjZWhvbGRlck5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuUGxhY2Vob2xkZXJOb2RlID0gUGxhY2Vob2xkZXJOb2RlO1xudmFyIENvbnN0YW50Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnN0YW50Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25zdGFudE5vZGUoZ3JhcGgsIGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdDb25zdGFudCcsIHt9LCBuZXcgVGVuc29yKGRhdGEuc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25zdGFudE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLmRhdGEgIT0gbnVsbCwgJ0Vycm9yIGFkZGluZyBjb25zdGFudDogZGF0YSBmb3IgcGxhY2Vob2xkZXIgXFwnJyArIHRoaXMubmFtZSArXG4gICAgICAgICAgICAnXFwnIGlzIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uc3RhbnROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkNvbnN0YW50Tm9kZSA9IENvbnN0YW50Tm9kZTtcbnZhciBSZXNoYXBlTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlc2hhcGVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc2hhcGVOb2RlKGdyYXBoLCBuYW1lLCB4LCBzaGFwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgbmFtZSwgeyB4OiB4IH0sIG5ldyBUZW5zb3Ioc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMueCA9IHg7XG4gICAgICAgIF90aGlzLnNoYXBlID0gc2hhcGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVzaGFwZU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeFNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy54LnNoYXBlKTtcbiAgICAgICAgdmFyIHNoYXBlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnNoYXBlKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoeFNpemUgPT09IHNoYXBlU2l6ZSwgJ0Vycm9yIG1ha2luZyByZXNoYXBlIG9wZXJhdGlvbjogaW5wdXQgVGVuc29yIHRvIHJlc2hhcGUgXFwnJyArXG4gICAgICAgICAgICB0aGlzLm5hbWUgKyAnXFwnIG9mIHNoYXBlICgnICsgdGhpcy54LnNoYXBlICtcbiAgICAgICAgICAgICcpIGRvZXMgbm90IG1hdGNoIHNpemUgb2YgcmVxdWVzdGVkIHNoYXBlICcgKyB0aGlzLnNoYXBlICsgJy4nKTtcbiAgICB9O1xuICAgIFJlc2hhcGVOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIFJlc2hhcGVOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlJlc2hhcGVOb2RlID0gUmVzaGFwZU5vZGU7XG52YXIgRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZShncmFwaCwgdDEsIHQyLCBjMSwgYzIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdMaW5lYXIgQ29tYmluYXRpb24nLCB7IHQxOiB0MSwgdDI6IHQyLCBjMTogYzEsIGMyOiBjMiB9LCBuZXcgVGVuc29yKHQxLnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudDEgPSB0MTtcbiAgICAgICAgX3RoaXMudDIgPSB0MjtcbiAgICAgICAgX3RoaXMuYzEgPSBjMTtcbiAgICAgICAgX3RoaXMuYzIgPSBjMjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2godGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSk7XG4gICAgICAgIGlmICghdXRpbC5pc1NjYWxhclNoYXBlKHRoaXMuYzEuc2hhcGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGFkZGluZyBmdXNlZExpbmVhckNvbWJpbmF0aW9uOiBjMSBpcyBub3QgYSBzY2FsYXIsIGdvdCAnICtcbiAgICAgICAgICAgICAgICAnc2hhcGU6ICcgKyB0aGlzLmMxLnNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXJTaGFwZSh0aGlzLmMyLnNoYXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZGRpbmcgZnVzZWRMaW5lYXJDb21iaW5hdGlvbjogYzIgaXMgbm90IGEgc2NhbGFyLCBnb3QgJyArXG4gICAgICAgICAgICAgICAgJ3NoYXBlOiAnICsgdGhpcy5jMi5zaGFwZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLlQxID0gJ3QxJztcbiAgICBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5UMiA9ICd0Mic7XG4gICAgRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuQzEgPSAnYzEnO1xuICAgIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLkMyID0gJ2MyJztcbiAgICByZXR1cm4gRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUgPSBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZTtcbnZhciBBZGROb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWRkTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZGROb2RlKGdyYXBoLCB0MSwgdDIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdBZGQnLCB7IHQxOiB0MSwgdDI6IHQyIH0sIG5ldyBUZW5zb3IodXRpbC5zaXplRnJvbVNoYXBlKHQxLnNoYXBlKSA9PT0gMSA/IHQyLnNoYXBlIDogdDEuc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50MSA9IHQxO1xuICAgICAgICBfdGhpcy50MiA9IHQyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFkZE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50MS5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQyLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh0aGlzLnQxLnNoYXBlLCB0aGlzLnQyLnNoYXBlKSwgJ0Vycm9yIGFkZGluZyBhZGQgb3BlcmF0aW9uIG9wOiBvbmUgb2YgaW5wdXRzIG11c3QgYmUgc2NhbGFyIG9yIHRoZSAnICtcbiAgICAgICAgICAgICdzaGFwZXMgJyArIHRoaXMudDEuc2hhcGUgKyAnIGFuZCAnICsgdGhpcy50Mi5zaGFwZSArXG4gICAgICAgICAgICAnIG11c3QgbWF0Y2guJyk7XG4gICAgfTtcbiAgICBBZGROb2RlLlQxID0gJ3QxJztcbiAgICBBZGROb2RlLlQyID0gJ3QyJztcbiAgICByZXR1cm4gQWRkTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5BZGROb2RlID0gQWRkTm9kZTtcbnZhciBTdWJ0cmFjdE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJ0cmFjdE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3VidHJhY3ROb2RlKGdyYXBoLCB0MSwgdDIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdTdWJ0cmFjdCcsIHsgdDE6IHQxLCB0MjogdDIgfSwgbmV3IFRlbnNvcih1dGlsLnNpemVGcm9tU2hhcGUodDEuc2hhcGUpID09PSAxID8gdDIuc2hhcGUgOiB0MS5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnQxID0gdDE7XG4gICAgICAgIF90aGlzLnQyID0gdDI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3VidHJhY3ROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDEuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSksICdFcnJvciBhZGRpbmcgc3VidHJhY3Qgb3A6IG9uZSBvZiBpbnB1dHMgbXVzdCBiZSBzY2FsYXIgb3IgdGhlICcgK1xuICAgICAgICAgICAgJ3NoYXBlcyAnICsgdGhpcy50MS5zaGFwZSArICcgYW5kICcgKyB0aGlzLnQyLnNoYXBlICtcbiAgICAgICAgICAgICcgbXVzdCBtYXRjaC4nKTtcbiAgICB9O1xuICAgIFN1YnRyYWN0Tm9kZS5UMSA9ICd0MSc7XG4gICAgU3VidHJhY3ROb2RlLlQyID0gJ3QyJztcbiAgICByZXR1cm4gU3VidHJhY3ROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlN1YnRyYWN0Tm9kZSA9IFN1YnRyYWN0Tm9kZTtcbnZhciBNdWx0aXBseU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNdWx0aXBseU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTXVsdGlwbHlOb2RlKGdyYXBoLCB0MSwgdDIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdNdWx0aXBseScsIHsgdDE6IHQxLCB0MjogdDIgfSwgbmV3IFRlbnNvcih1dGlsLnNpemVGcm9tU2hhcGUodDEuc2hhcGUpID09PSAxID8gdDIuc2hhcGUgOiB0MS5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnQxID0gdDE7XG4gICAgICAgIF90aGlzLnQyID0gdDI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTXVsdGlwbHlOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDEuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSksICdFcnJvciBhZGRpbmcgbXVsdGlwbHkgb3A6IG9uZSBvZiBpbnB1dHMgbXVzdCBiZSBzY2FsYXIgb3IgdGhlICcgK1xuICAgICAgICAgICAgJ3NoYXBlcyAnICsgdGhpcy50MS5zaGFwZSArICcgYW5kICcgKyB0aGlzLnQyLnNoYXBlICtcbiAgICAgICAgICAgICcgbXVzdCBtYXRjaC4nKTtcbiAgICB9O1xuICAgIE11bHRpcGx5Tm9kZS5UMSA9ICd0MSc7XG4gICAgTXVsdGlwbHlOb2RlLlQyID0gJ3QyJztcbiAgICByZXR1cm4gTXVsdGlwbHlOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLk11bHRpcGx5Tm9kZSA9IE11bHRpcGx5Tm9kZTtcbnZhciBEaXZpZGVOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGl2aWRlTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaXZpZGVOb2RlKGdyYXBoLCB0MSwgdDIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdEaXZpZGUnLCB7IHQxOiB0MSwgdDI6IHQyIH0sIG5ldyBUZW5zb3IodXRpbC5zaXplRnJvbVNoYXBlKHQxLnNoYXBlKSA9PT0gMSA/IHQyLnNoYXBlIDogdDEuc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50MSA9IHQxO1xuICAgICAgICBfdGhpcy50MiA9IHQyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERpdmlkZU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50MS5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQyLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh0aGlzLnQxLnNoYXBlLCB0aGlzLnQyLnNoYXBlKSwgJ0Vycm9yIGFkZGluZyBkaXZpZGUgb3A6IG9uZSBvZiBpbnB1dHMgbXVzdCBiZSBzY2FsYXIgb3IgdGhlICcgK1xuICAgICAgICAgICAgJ3NoYXBlcyAnICsgdGhpcy50MS5zaGFwZSArICcgYW5kICcgKyB0aGlzLnQyLnNoYXBlICtcbiAgICAgICAgICAgICcgbXVzdCBtYXRjaC4nKTtcbiAgICB9O1xuICAgIERpdmlkZU5vZGUuVDEgPSAndDEnO1xuICAgIERpdmlkZU5vZGUuVDIgPSAndDInO1xuICAgIHJldHVybiBEaXZpZGVOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkRpdmlkZU5vZGUgPSBEaXZpZGVOb2RlO1xudmFyIFJlZHVjZVN1bU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWR1Y2VTdW1Ob2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZHVjZVN1bU5vZGUoZ3JhcGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnUmVkdWNlU3VtJywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoW10pKSB8fCB0aGlzO1xuICAgIH1cbiAgICBSZWR1Y2VTdW1Ob2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBSZWR1Y2VTdW1Ob2RlLlggPSAneCc7XG4gICAgcmV0dXJuIFJlZHVjZVN1bU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuUmVkdWNlU3VtTm9kZSA9IFJlZHVjZVN1bU5vZGU7XG52YXIgQ29uY2F0M0ROb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uY2F0M0ROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmNhdDNETm9kZShncmFwaCwgeDEsIHgyLCBheGlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnQ29uY2F0M0QnLCB7IHgxOiB4MSwgeDI6IHgyIH0sIG5ldyBUZW5zb3IoY29uY2F0X3V0aWwuY29tcHV0ZU91dFNoYXBlKHgxLnNoYXBlLCB4Mi5zaGFwZSwgYXhpcykpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MSA9IHgxO1xuICAgICAgICBfdGhpcy54MiA9IHgyO1xuICAgICAgICBfdGhpcy5heGlzID0gYXhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25jYXQzRE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25jYXRfdXRpbC5hc3NlcnRQYXJhbXModGhpcy54MS5zaGFwZSwgdGhpcy54Mi5zaGFwZSwgdGhpcy5heGlzKTtcbiAgICB9O1xuICAgIENvbmNhdDNETm9kZS5YMSA9ICd4MSc7XG4gICAgQ29uY2F0M0ROb2RlLlgyID0gJ3gyJztcbiAgICBDb25jYXQzRE5vZGUuQVhJUyA9ICdheGlzJztcbiAgICByZXR1cm4gQ29uY2F0M0ROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkNvbmNhdDNETm9kZSA9IENvbmNhdDNETm9kZTtcbmZ1bmN0aW9uIGdldE1hdE11bE91dHB1dFNoYXBlKHgxU2hhcGUsIHgyU2hhcGUpIHtcbiAgICBpZiAoeDFTaGFwZS5sZW5ndGggPT09IDEgJiYgeDJTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFsxXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeDFTaGFwZS5sZW5ndGggPT09IDEgJiYgeDJTaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIFt4MlNoYXBlWzFdXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeDFTaGFwZS5sZW5ndGggPT09IDIgJiYgeDJTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFt4MVNoYXBlWzBdXTtcbiAgICB9XG4gICAgcmV0dXJuIFt4MVNoYXBlWzBdLCB4MlNoYXBlWzFdXTtcbn1cbnZhciBNYXRNdWxOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF0TXVsTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXRNdWxOb2RlKGdyYXBoLCB4MSwgeDIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdNYXRNdWwnLCB7IHgxOiB4MSwgeDI6IHgyIH0sIG5ldyBUZW5zb3IoZ2V0TWF0TXVsT3V0cHV0U2hhcGUoeDEuc2hhcGUsIHgyLnNoYXBlKSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxID0geDE7XG4gICAgICAgIF90aGlzLngyID0geDI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWF0TXVsTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLngxLnNoYXBlLmxlbmd0aCA9PT0gMiAmJiB0aGlzLngyLnNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54MS5zaGFwZVsxXSA9PT0gdGhpcy54Mi5zaGFwZVswXSwgJ0Vycm9yIGFkZGluZyBtYXRtdWwgb3A6IGlubmVyIHNoYXBlcyBvZiBtYXRyaWNlcyB3aXRoIHNoYXBlcyAnICtcbiAgICAgICAgICAgICAgICB0aGlzLngxLnNoYXBlICsgJyBhbmQgJyArIHRoaXMueDIuc2hhcGUgKyAnIG11c3QgbWF0Y2guJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy54MS5zaGFwZS5sZW5ndGggPT09IDIgJiYgdGhpcy54Mi5zaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMueDEuc2hhcGVbMV0gPT09IHRoaXMueDIuc2hhcGVbMF0sICdFcnJvciBhZGRpbmcgbWF0bXVsIG9wOiBzZWNvbmQgZGltZW5zaW9uIG9mIG1hdHJpeCB3aXRoIHNoYXBlICcgK1xuICAgICAgICAgICAgICAgIHRoaXMueDEuc2hhcGUgKyAnIG11c3QgbWF0Y2ggc2l6ZSBvZiB2ZWN0b3Igd2l0aCBzaGFwZSAnICtcbiAgICAgICAgICAgICAgICB0aGlzLngyLnNoYXBlICsgJy4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLngxLnNoYXBlLmxlbmd0aCA9PT0gMSAmJiB0aGlzLngyLnNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54MS5zaGFwZVswXSA9PT0gdGhpcy54Mi5zaGFwZVswXSwgJ0Vycm9yIGFkZGluZyBtYXRtdWwgb3A6IHNpemUgb2YgdmVjdG9yIHdpdGggc2hhcGUgJyArIHRoaXMueDEuc2hhcGUgK1xuICAgICAgICAgICAgICAgICcgbXVzdCBtYXRjaCBmaXJzdCBkaW1lbnNpb24gb2YgbWF0cml4IHdpdGggJyArXG4gICAgICAgICAgICAgICAgJ3NoYXBlICcgKyB0aGlzLngyLnNoYXBlICsgJy4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYWRkaW5nIG1hdG11bCBvcDogaW5wdXRzIG11c3QgYmUgdmVjdG9ycyBvciBtYXRyaWNlcy4nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWF0TXVsTm9kZS5YMSA9ICd4MSc7XG4gICAgTWF0TXVsTm9kZS5YMiA9ICd4Mic7XG4gICAgcmV0dXJuIE1hdE11bE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuTWF0TXVsTm9kZSA9IE1hdE11bE5vZGU7XG52YXIgQ29udm9sdXRpb24yRE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb252b2x1dGlvbjJETm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb252b2x1dGlvbjJETm9kZShncmFwaCwgeCwgdywgYiwgZmllbGRTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkKSB7XG4gICAgICAgIGlmIChzdHJpZGUgPT09IHZvaWQgMCkgeyBzdHJpZGUgPSAxOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnQ29udm9sdXRpb24gMkQnLCB7IHg6IHgsIHc6IHcsIGI6IGIgfSwgbmV3IFRlbnNvcihjb252X3V0aWwuY29tcHV0ZU91dHB1dFNoYXBlM0QoeC5zaGFwZSwgZmllbGRTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkKSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnggPSB4O1xuICAgICAgICBfdGhpcy53ID0gdztcbiAgICAgICAgX3RoaXMuYiA9IGI7XG4gICAgICAgIF90aGlzLmZpZWxkU2l6ZSA9IGZpZWxkU2l6ZTtcbiAgICAgICAgX3RoaXMub3V0cHV0RGVwdGggPSBvdXRwdXREZXB0aDtcbiAgICAgICAgX3RoaXMuc3RyaWRlID0gc3RyaWRlO1xuICAgICAgICBfdGhpcy56ZXJvUGFkID0gemVyb1BhZDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb252b2x1dGlvbjJETm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMueC5zaGFwZS5sZW5ndGggPT09IDMsICdFcnJvciBhZGRpbmcgY29udjJkIG9wOiBpbnB1dCBtdXN0IGJlIG9mIHJhbmsgMywgYnV0IGdvdCBzaGFwZTogJyArXG4gICAgICAgICAgICB0aGlzLnguc2hhcGUgKyAnLicpO1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLncuc2hhcGUubGVuZ3RoID09PSA0LCAnRXJyb3IgYWRkaW5nIGNvbnYyZCBvcDogd2VpZ2h0cyBtdXN0IGJlIG9mIHJhbmsgNCwgYnV0IGdvdCBzaGFwZTogJyArXG4gICAgICAgICAgICB0aGlzLncuc2hhcGUgKyAnLicpO1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLmIuc2hhcGUubGVuZ3RoID09PSAxLCAnRXJyb3IgYWRkaW5nIGNvbnYyZCBvcDogYmlhc2VzIG11c3QgYmUgb2YgcmFuayAxLCBidXQgZ290IHNoYXBlOiAnICtcbiAgICAgICAgICAgIHRoaXMuYi5zaGFwZSArICcuJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMueC5zaGFwZVsyXSA9PT0gdGhpcy53LnNoYXBlWzJdLCAnRXJyb3IgYWRkaW5nIGNvbnYyZCBvcDogZGVwdGggb2YgaW5wdXQgKCcgKyB0aGlzLnguc2hhcGVbMl0gK1xuICAgICAgICAgICAgJykgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3Igd2VpZ2h0cyAoJyArIHRoaXMudy5zaGFwZVsyXSArICcpLicpO1xuICAgIH07XG4gICAgQ29udm9sdXRpb24yRE5vZGUuWCA9ICd4JztcbiAgICBDb252b2x1dGlvbjJETm9kZS5XID0gJ3cnO1xuICAgIENvbnZvbHV0aW9uMkROb2RlLkIgPSAnYic7XG4gICAgcmV0dXJuIENvbnZvbHV0aW9uMkROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkNvbnZvbHV0aW9uMkROb2RlID0gQ29udm9sdXRpb24yRE5vZGU7XG52YXIgTWF4UG9vbE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXhQb29sTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXhQb29sTm9kZShncmFwaCwgeCwgZmllbGRTaXplLCBzdHJpZGUsIHplcm9QYWQpIHtcbiAgICAgICAgaWYgKHN0cmlkZSA9PT0gdm9pZCAwKSB7IHN0cmlkZSA9IDE7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdNYXggcG9vbCcsIHsgeDogeCB9LCBuZXcgVGVuc29yKGNvbnZfdXRpbC5jb21wdXRlT3V0cHV0U2hhcGUzRCh4LnNoYXBlLCBmaWVsZFNpemUsIHguc2hhcGVbMl0sIHN0cmlkZSwgemVyb1BhZCkpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54ID0geDtcbiAgICAgICAgX3RoaXMuZmllbGRTaXplID0gZmllbGRTaXplO1xuICAgICAgICBfdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG4gICAgICAgIF90aGlzLnplcm9QYWQgPSB6ZXJvUGFkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1heFBvb2xOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54LnNoYXBlLmxlbmd0aCA9PT0gMywgJ0Vycm9yIGFkZGluZyBtYXhQb29sIG9wOiBpbnB1dCBtdXN0IGJlIG9mIHJhbmsgMywgYnV0IGdvdCBzaGFwZTogJyArXG4gICAgICAgICAgICB0aGlzLnguc2hhcGUgKyAnLicpO1xuICAgIH07XG4gICAgTWF4UG9vbE5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gTWF4UG9vbE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuTWF4UG9vbE5vZGUgPSBNYXhQb29sTm9kZTtcbnZhciBSZUxVTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlTFVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlTFVOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1JlTFUnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICB9XG4gICAgUmVMVU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFJlTFVOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIFJlTFVOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlJlTFVOb2RlID0gUmVMVU5vZGU7XG52YXIgRXhwTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4cE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXhwTm9kZShncmFwaCwgeCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdFeHAnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICB9XG4gICAgRXhwTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgRXhwTm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBFeHBOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkV4cE5vZGUgPSBFeHBOb2RlO1xudmFyIExvZ05vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2dOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExvZ05vZGUoZ3JhcGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnTG9nJywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIExvZ05vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIExvZ05vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gTG9nTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5Mb2dOb2RlID0gTG9nTm9kZTtcbnZhciBUYW5ITm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhbkhOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhbkhOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1RhbkgnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICB9XG4gICAgVGFuSE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFRhbkhOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIFRhbkhOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlRhbkhOb2RlID0gVGFuSE5vZGU7XG52YXIgU2lnbW9pZE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaWdtb2lkTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaWdtb2lkTm9kZShncmFwaCwgeCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdTaWdtb2lkJywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIFNpZ21vaWROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBTaWdtb2lkTm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBTaWdtb2lkTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5TaWdtb2lkTm9kZSA9IFNpZ21vaWROb2RlO1xudmFyIFNxdWFyZU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTcXVhcmVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNxdWFyZU5vZGUoZ3JhcGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnU3F1YXJlJywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIFNxdWFyZU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFNxdWFyZU5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gU3F1YXJlTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5TcXVhcmVOb2RlID0gU3F1YXJlTm9kZTtcbnZhciBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlKGdyYXBoLCB4LCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCcsIHsgeDogeCwgdGFyZ2V0OiB0YXJnZXQgfSwgbmV3IFRlbnNvcihbXSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnggPSB4O1xuICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5hcnJheXNFcXVhbCh0aGlzLnguc2hhcGUsIHRoaXMudGFyZ2V0LnNoYXBlKSwgJ0Vycm9yIGFkZGluZyBzb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCBvcDogeCBzaGFwZSAoJyArIHRoaXMueC5zaGFwZSArXG4gICAgICAgICAgICAnKSBtdXN0IG1hdGNoIHRhcmdldCBzaGFwZSAoJyArIHRoaXMudGFyZ2V0LnNoYXBlICsgJykuJyk7XG4gICAgfTtcbiAgICBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUuWCA9ICd4JztcbiAgICBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUuVEFSR0VUID0gJ3RhcmdldCc7XG4gICAgcmV0dXJuIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5Tb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUgPSBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGU7XG52YXIgU29mdG1heE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTb2Z0bWF4Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTb2Z0bWF4Tm9kZShncmFwaCwgeCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1NvZnRtYXgnLCB7IHg6IHggfSwgbmV3IFRlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueCA9IHg7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU29mdG1heE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLnguc2hhcGUubGVuZ3RoID09PSAxLCAnVGhlIGlucHV0IHRvIGEgc29mdG1heCBtdXN0IGJlIGEgMS1EIHRlbnNvcicpO1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLnguc2hhcGVbMF0gPj0gMiwgJ1RoZSBpbnB1dCB0byBhIHNvZnRtYXggbXVzdCBoYXZlIGF0IGxlYXN0IDIgdmFsdWVzJyk7XG4gICAgfTtcbiAgICBTb2Z0bWF4Tm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBTb2Z0bWF4Tm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5Tb2Z0bWF4Tm9kZSA9IFNvZnRtYXhOb2RlO1xudmFyIE1lYW5TcXVhcmVkQ29zdE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZWFuU3F1YXJlZENvc3ROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lYW5TcXVhcmVkQ29zdE5vZGUoZ3JhcGgsIGxhYmVsLCBwcmVkaWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnTWVhbiBTcXVhcmVkIENvc3QnLCB7IGxhYmVsOiBsYWJlbCwgcHJlZGljdGlvbjogcHJlZGljdGlvbiB9LCBuZXcgVGVuc29yKFtdKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgX3RoaXMucHJlZGljdGlvbiA9IHByZWRpY3Rpb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWVhblNxdWFyZWRDb3N0Tm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuYXJyYXlzRXF1YWwodGhpcy5sYWJlbC5zaGFwZSwgdGhpcy5wcmVkaWN0aW9uLnNoYXBlKSwgJ0Vycm9yIGFkZGluZyBtZWFuU3F1YXJlZENvc3Qgb3A6IGxhYmVsIHNoYXBlICgnICsgdGhpcy5sYWJlbC5zaGFwZSArXG4gICAgICAgICAgICAnKSBtdXN0IG1hdGNoIHByZWRpY3Rpb24gc2hhcGUgKCcgKyB0aGlzLnByZWRpY3Rpb24uc2hhcGUgKyAnKS4nKTtcbiAgICB9O1xuICAgIE1lYW5TcXVhcmVkQ29zdE5vZGUuTEFCRUwgPSAnbGFiZWwnO1xuICAgIE1lYW5TcXVhcmVkQ29zdE5vZGUuUFJFRElDVElPTiA9ICdwcmVkaWN0aW9uJztcbiAgICByZXR1cm4gTWVhblNxdWFyZWRDb3N0Tm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5NZWFuU3F1YXJlZENvc3ROb2RlID0gTWVhblNxdWFyZWRDb3N0Tm9kZTtcbnZhciBBcmdNYXhOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJnTWF4Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcmdNYXhOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnQXJnTWF4JywgeyB4OiB4IH0sIG5ldyBUZW5zb3IoWzFdKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueCA9IHg7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXJnTWF4Tm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnguc2hhcGUpID4gMCwgJ0Vycm9yIGFkZGluZyBhcmdtYXggb3A6IGlucHV0IHRlbnNvciBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVudHJ5LicpO1xuICAgIH07XG4gICAgQXJnTWF4Tm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBBcmdNYXhOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkFyZ01heE5vZGUgPSBBcmdNYXhOb2RlO1xudmFyIEFyZ01heEVxdWFsc05vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcmdNYXhFcXVhbHNOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFyZ01heEVxdWFsc05vZGUoZ3JhcGgsIHgxLCB4Mikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0FyZ01heEVxdWFscycsIHsgeDE6IHgxLCB4MjogeDIgfSwgbmV3IFRlbnNvcihbMV0pKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MSA9IHgxO1xuICAgICAgICBfdGhpcy54MiA9IHgyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFyZ01heEVxdWFsc05vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmFycmF5c0VxdWFsKHRoaXMueDEuc2hhcGUsIHRoaXMueDIuc2hhcGUpLCAnRXJyb3IgYWRkaW5nIEFyZ01heEVxdWFscyBvcDogeDEgc2hhcGUgKCcgKyB0aGlzLngxLnNoYXBlICtcbiAgICAgICAgICAgICcpIG11c3QgbWF0Y2ggeDIgc2hhcGUgKCcgKyB0aGlzLngyLnNoYXBlICsgJykuJyk7XG4gICAgfTtcbiAgICBBcmdNYXhFcXVhbHNOb2RlLlgxID0gJ3gxJztcbiAgICBBcmdNYXhFcXVhbHNOb2RlLlgyID0gJ3gyJztcbiAgICByZXR1cm4gQXJnTWF4RXF1YWxzTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5BcmdNYXhFcXVhbHNOb2RlID0gQXJnTWF4RXF1YWxzTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyYXBoLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/graph.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/graph_util.js":
/*!*************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/graph_util.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graph_1 = __webpack_require__(/*! ./graph */ \"./node_modules/deeplearn/dist/src/graph/graph.js\");\nvar priority_queue = __webpack_require__(/*! ./priority_queue */ \"./node_modules/deeplearn/dist/src/graph/priority_queue.js\");\nvar priority_queue_1 = __webpack_require__(/*! ./priority_queue */ \"./node_modules/deeplearn/dist/src/graph/priority_queue.js\");\nfunction getUnorderedEvaluationSet(nodes, terminatingNodes) {\n    var terminatingNodeMap = {};\n    var seen = {};\n    var set = [];\n    var visit = nodes.slice();\n    terminatingNodes.forEach(function (node) { return terminatingNodeMap[node.id] = node; });\n    var _loop_1 = function () {\n        var cur = visit.pop();\n        if (seen[cur.id] == null) {\n            if (terminatingNodeMap[cur.id] == null) {\n                Object.keys(cur.inputs)\n                    .map(function (inputName) { return cur.inputs[inputName]; })\n                    .forEach(function (input) { return visit.push(input.node); });\n            }\n            set.push(cur);\n            seen[cur.id] = cur;\n        }\n    };\n    while (visit.length !== 0) {\n        _loop_1();\n    }\n    return set;\n}\nexports.getUnorderedEvaluationSet = getUnorderedEvaluationSet;\nfunction getOrderedEvaluationSet(unorderedEvaluationSet) {\n    var set = [];\n    var nodeIndices = {};\n    var pendingDependencies = {};\n    var nodeQueue = new priority_queue_1.PriorityQueue(function (a, b) { return priority_queue.defaultCompare(pendingDependencies[a.id], pendingDependencies[b.id]); }, function (node, newIndex) { return nodeIndices[node.id] = newIndex; });\n    unorderedEvaluationSet.forEach(function (node) { return pendingDependencies[node.id] = 0; });\n    unorderedEvaluationSet.forEach(function (node) { return Object.keys(node.inputs)\n        .map(function (key) { return node.inputs[key]; })\n        .forEach(function (input) {\n        if (unorderedEvaluationSet.indexOf(input.node) !== -1) {\n            pendingDependencies[input.node.id]++;\n        }\n    }); });\n    unorderedEvaluationSet.forEach(function (node) { return nodeQueue.enqueue(node); });\n    while (!nodeQueue.empty()) {\n        set.unshift(nodeQueue.dequeue());\n        Object.keys(set[0].inputs).map(function (key) { return set[0].inputs[key]; }).forEach(function (input) {\n            if (unorderedEvaluationSet.indexOf(input.node) === -1) {\n                return;\n            }\n            pendingDependencies[input.node.id]--;\n            nodeQueue.update(input.node, nodeIndices[input.node.id]);\n        });\n    }\n    return set;\n}\nexports.getOrderedEvaluationSet = getOrderedEvaluationSet;\nfunction isInputNode(node) {\n    return Object.keys(node.inputs).length === 0;\n}\nexports.isInputNode = isInputNode;\nfunction shouldBackProp(t) {\n    return !(t.node instanceof graph_1.ConstantNode);\n}\nexports.shouldBackProp = shouldBackProp;\nfunction isPassthroughNode(node, map) {\n    var keys = Object.keys(node.inputs);\n    for (var i = 0; i < keys.length; i++) {\n        var input = node.inputs[keys[i]];\n        if (map.get(input, true) === map.get(node.output, true)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.isPassthroughNode = isPassthroughNode;\n//# sourceMappingURL=graph_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL2dyYXBoX3V0aWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL2dyYXBoX3V0aWwuanM/NjQxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmFwaF8xID0gcmVxdWlyZShcIi4vZ3JhcGhcIik7XG52YXIgcHJpb3JpdHlfcXVldWUgPSByZXF1aXJlKFwiLi9wcmlvcml0eV9xdWV1ZVwiKTtcbnZhciBwcmlvcml0eV9xdWV1ZV8xID0gcmVxdWlyZShcIi4vcHJpb3JpdHlfcXVldWVcIik7XG5mdW5jdGlvbiBnZXRVbm9yZGVyZWRFdmFsdWF0aW9uU2V0KG5vZGVzLCB0ZXJtaW5hdGluZ05vZGVzKSB7XG4gICAgdmFyIHRlcm1pbmF0aW5nTm9kZU1hcCA9IHt9O1xuICAgIHZhciBzZWVuID0ge307XG4gICAgdmFyIHNldCA9IFtdO1xuICAgIHZhciB2aXNpdCA9IG5vZGVzLnNsaWNlKCk7XG4gICAgdGVybWluYXRpbmdOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiB0ZXJtaW5hdGluZ05vZGVNYXBbbm9kZS5pZF0gPSBub2RlOyB9KTtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1ciA9IHZpc2l0LnBvcCgpO1xuICAgICAgICBpZiAoc2VlbltjdXIuaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0ZXJtaW5hdGluZ05vZGVNYXBbY3VyLmlkXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY3VyLmlucHV0cylcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaW5wdXROYW1lKSB7IHJldHVybiBjdXIuaW5wdXRzW2lucHV0TmFtZV07IH0pXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gdmlzaXQucHVzaChpbnB1dC5ub2RlKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXQucHVzaChjdXIpO1xuICAgICAgICAgICAgc2VlbltjdXIuaWRdID0gY3VyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAodmlzaXQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIF9sb29wXzEoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNldDtcbn1cbmV4cG9ydHMuZ2V0VW5vcmRlcmVkRXZhbHVhdGlvblNldCA9IGdldFVub3JkZXJlZEV2YWx1YXRpb25TZXQ7XG5mdW5jdGlvbiBnZXRPcmRlcmVkRXZhbHVhdGlvblNldCh1bm9yZGVyZWRFdmFsdWF0aW9uU2V0KSB7XG4gICAgdmFyIHNldCA9IFtdO1xuICAgIHZhciBub2RlSW5kaWNlcyA9IHt9O1xuICAgIHZhciBwZW5kaW5nRGVwZW5kZW5jaWVzID0ge307XG4gICAgdmFyIG5vZGVRdWV1ZSA9IG5ldyBwcmlvcml0eV9xdWV1ZV8xLlByaW9yaXR5UXVldWUoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHByaW9yaXR5X3F1ZXVlLmRlZmF1bHRDb21wYXJlKHBlbmRpbmdEZXBlbmRlbmNpZXNbYS5pZF0sIHBlbmRpbmdEZXBlbmRlbmNpZXNbYi5pZF0pOyB9LCBmdW5jdGlvbiAobm9kZSwgbmV3SW5kZXgpIHsgcmV0dXJuIG5vZGVJbmRpY2VzW25vZGUuaWRdID0gbmV3SW5kZXg7IH0pO1xuICAgIHVub3JkZXJlZEV2YWx1YXRpb25TZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gcGVuZGluZ0RlcGVuZGVuY2llc1tub2RlLmlkXSA9IDA7IH0pO1xuICAgIHVub3JkZXJlZEV2YWx1YXRpb25TZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gT2JqZWN0LmtleXMobm9kZS5pbnB1dHMpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbm9kZS5pbnB1dHNba2V5XTsgfSlcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIGlmICh1bm9yZGVyZWRFdmFsdWF0aW9uU2V0LmluZGV4T2YoaW5wdXQubm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBwZW5kaW5nRGVwZW5kZW5jaWVzW2lucHV0Lm5vZGUuaWRdKys7XG4gICAgICAgIH1cbiAgICB9KTsgfSk7XG4gICAgdW5vcmRlcmVkRXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlUXVldWUuZW5xdWV1ZShub2RlKTsgfSk7XG4gICAgd2hpbGUgKCFub2RlUXVldWUuZW1wdHkoKSkge1xuICAgICAgICBzZXQudW5zaGlmdChub2RlUXVldWUuZGVxdWV1ZSgpKTtcbiAgICAgICAgT2JqZWN0LmtleXMoc2V0WzBdLmlucHV0cykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHNldFswXS5pbnB1dHNba2V5XTsgfSkuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICh1bm9yZGVyZWRFdmFsdWF0aW9uU2V0LmluZGV4T2YoaW5wdXQubm9kZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVuZGluZ0RlcGVuZGVuY2llc1tpbnB1dC5ub2RlLmlkXS0tO1xuICAgICAgICAgICAgbm9kZVF1ZXVlLnVwZGF0ZShpbnB1dC5ub2RlLCBub2RlSW5kaWNlc1tpbnB1dC5ub2RlLmlkXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2V0O1xufVxuZXhwb3J0cy5nZXRPcmRlcmVkRXZhbHVhdGlvblNldCA9IGdldE9yZGVyZWRFdmFsdWF0aW9uU2V0O1xuZnVuY3Rpb24gaXNJbnB1dE5vZGUobm9kZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhub2RlLmlucHV0cykubGVuZ3RoID09PSAwO1xufVxuZXhwb3J0cy5pc0lucHV0Tm9kZSA9IGlzSW5wdXROb2RlO1xuZnVuY3Rpb24gc2hvdWxkQmFja1Byb3AodCkge1xuICAgIHJldHVybiAhKHQubm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQ29uc3RhbnROb2RlKTtcbn1cbmV4cG9ydHMuc2hvdWxkQmFja1Byb3AgPSBzaG91bGRCYWNrUHJvcDtcbmZ1bmN0aW9uIGlzUGFzc3Rocm91Z2hOb2RlKG5vZGUsIG1hcCkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5pbnB1dHMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5wdXQgPSBub2RlLmlucHV0c1trZXlzW2ldXTtcbiAgICAgICAgaWYgKG1hcC5nZXQoaW5wdXQsIHRydWUpID09PSBtYXAuZ2V0KG5vZGUub3V0cHV0LCB0cnVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc1Bhc3N0aHJvdWdoTm9kZSA9IGlzUGFzc3Rocm91Z2hOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JhcGhfdXRpbC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/graph_util.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/operation_emitter.js":
/*!********************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/operation_emitter.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graph_1 = __webpack_require__(/*! ./graph */ \"./node_modules/deeplearn/dist/src/graph/graph.js\");\nvar graph_util = __webpack_require__(/*! ./graph_util */ \"./node_modules/deeplearn/dist/src/graph/graph_util.js\");\nvar add_1 = __webpack_require__(/*! ./ops/add */ \"./node_modules/deeplearn/dist/src/graph/ops/add.js\");\nvar argmax_1 = __webpack_require__(/*! ./ops/argmax */ \"./node_modules/deeplearn/dist/src/graph/ops/argmax.js\");\nvar argmaxequals_1 = __webpack_require__(/*! ./ops/argmaxequals */ \"./node_modules/deeplearn/dist/src/graph/ops/argmaxequals.js\");\nvar concat3d_1 = __webpack_require__(/*! ./ops/concat3d */ \"./node_modules/deeplearn/dist/src/graph/ops/concat3d.js\");\nvar convolution_1 = __webpack_require__(/*! ./ops/convolution */ \"./node_modules/deeplearn/dist/src/graph/ops/convolution.js\");\nvar divide_1 = __webpack_require__(/*! ./ops/divide */ \"./node_modules/deeplearn/dist/src/graph/ops/divide.js\");\nvar element_wise_activation_1 = __webpack_require__(/*! ./ops/element_wise_activation */ \"./node_modules/deeplearn/dist/src/graph/ops/element_wise_activation.js\");\nvar element_wise_cost_1 = __webpack_require__(/*! ./ops/element_wise_cost */ \"./node_modules/deeplearn/dist/src/graph/ops/element_wise_cost.js\");\nvar exp_1 = __webpack_require__(/*! ./ops/exp */ \"./node_modules/deeplearn/dist/src/graph/ops/exp.js\");\nvar linear_combination_1 = __webpack_require__(/*! ./ops/linear_combination */ \"./node_modules/deeplearn/dist/src/graph/ops/linear_combination.js\");\nvar log_1 = __webpack_require__(/*! ./ops/log */ \"./node_modules/deeplearn/dist/src/graph/ops/log.js\");\nvar matmul_1 = __webpack_require__(/*! ./ops/matmul */ \"./node_modules/deeplearn/dist/src/graph/ops/matmul.js\");\nvar max_pool_1 = __webpack_require__(/*! ./ops/max_pool */ \"./node_modules/deeplearn/dist/src/graph/ops/max_pool.js\");\nvar multiply_1 = __webpack_require__(/*! ./ops/multiply */ \"./node_modules/deeplearn/dist/src/graph/ops/multiply.js\");\nvar reduce_sum_1 = __webpack_require__(/*! ./ops/reduce_sum */ \"./node_modules/deeplearn/dist/src/graph/ops/reduce_sum.js\");\nvar reshape_1 = __webpack_require__(/*! ./ops/reshape */ \"./node_modules/deeplearn/dist/src/graph/ops/reshape.js\");\nvar softmax_1 = __webpack_require__(/*! ./ops/softmax */ \"./node_modules/deeplearn/dist/src/graph/ops/softmax.js\");\nvar subtract_1 = __webpack_require__(/*! ./ops/subtract */ \"./node_modules/deeplearn/dist/src/graph/ops/subtract.js\");\nfunction emitFromGraphNodes(nodes) {\n    var ops = [];\n    nodes.forEach(function (node) { return Array.prototype.push.apply(ops, emitOpFromNode(node)); });\n    return ops;\n}\nexports.emitFromGraphNodes = emitFromGraphNodes;\nfunction emitOpFromNode(node) {\n    if (node instanceof graph_1.ReshapeNode) {\n        return [new reshape_1.Reshape(node.inputs[graph_1.ReshapeNode.X], node.output)];\n    }\n    else if (node instanceof graph_1.MatMulNode) {\n        var x1 = node.inputs[graph_1.MatMulNode.X1];\n        var x2 = node.inputs[graph_1.MatMulNode.X2];\n        return [new matmul_1.MatMul(x1, x2, node.output)];\n    }\n    else if (node instanceof graph_1.Convolution2DNode) {\n        var w = node.inputs[graph_1.Convolution2DNode.W];\n        var x = node.inputs[graph_1.Convolution2DNode.X];\n        var b = node.inputs[graph_1.Convolution2DNode.B];\n        return [new convolution_1.Convolution2D(w, x, b, node.output, node.fieldSize, node.outputDepth, node.stride, node.zeroPad)];\n    }\n    else if (node instanceof graph_1.MaxPoolNode) {\n        var x = node.inputs[graph_1.MaxPoolNode.X];\n        return [new max_pool_1.MaxPool(x, node.output, node.fieldSize, node.stride, node.zeroPad)];\n    }\n    else if (node instanceof graph_1.ExpNode) {\n        return [new exp_1.Exp(node.inputs[graph_1.ExpNode.X], node.output)];\n    }\n    else if (node instanceof graph_1.LogNode) {\n        return [new log_1.Log(node.inputs[graph_1.LogNode.X], node.output)];\n    }\n    else if (node instanceof graph_1.ReLUNode) {\n        return [new element_wise_activation_1.ReLU(node.inputs[graph_1.ReLUNode.X], node.output)];\n    }\n    else if (node instanceof graph_1.TanHNode) {\n        return [new element_wise_activation_1.TanH(node.inputs[graph_1.TanHNode.X], node.output)];\n    }\n    else if (node instanceof graph_1.SigmoidNode) {\n        return [new element_wise_activation_1.Sigmoid(node.inputs[graph_1.SigmoidNode.X], node.output)];\n    }\n    else if (node instanceof graph_1.SoftmaxCrossEntropyCostNode) {\n        var x = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.X];\n        var target = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.TARGET];\n        return [new softmax_1.SoftmaxCrossEntropyCost(x, target, node.output)];\n    }\n    else if (node instanceof graph_1.SoftmaxNode) {\n        return [new softmax_1.Softmax(node.inputs[graph_1.SoftmaxNode.X], node.output)];\n    }\n    else if (node instanceof graph_1.MeanSquaredCostNode) {\n        var label = node.inputs[graph_1.MeanSquaredCostNode.LABEL];\n        var prediction = node.inputs[graph_1.MeanSquaredCostNode.PREDICTION];\n        return [new element_wise_cost_1.MeanSquaredCost(label, prediction, node.output)];\n    }\n    else if (node instanceof graph_1.ArgMaxEqualsNode) {\n        return [new argmaxequals_1.ArgMaxEquals(node.inputs[graph_1.ArgMaxEqualsNode.X1], node.inputs[graph_1.ArgMaxEqualsNode.X2], node.output)];\n    }\n    else if (node instanceof graph_1.ArgMaxNode) {\n        return [new argmax_1.ArgMax(node.x, node.output)];\n    }\n    else if (node instanceof graph_1.FusedLinearCombinationNode) {\n        return [new linear_combination_1.LinearCombination(node.inputs[graph_1.FusedLinearCombinationNode.T1], node.inputs[graph_1.FusedLinearCombinationNode.T2], node.inputs[graph_1.FusedLinearCombinationNode.C1], node.inputs[graph_1.FusedLinearCombinationNode.C2], node.output)];\n    }\n    else if (node instanceof graph_1.Concat3DNode) {\n        return [new concat3d_1.Concat3D(node.inputs[graph_1.Concat3DNode.X1], node.inputs[graph_1.Concat3DNode.X2], node.axis, node.output)];\n    }\n    else if (node instanceof graph_1.SquareNode) {\n        return [new element_wise_activation_1.Square(node.inputs[graph_1.SquareNode.X], node.output)];\n    }\n    else if (node instanceof graph_1.AddNode) {\n        return [new add_1.Add(node.inputs[graph_1.AddNode.T1], node.inputs[graph_1.AddNode.T2], node.output)];\n    }\n    else if (node instanceof graph_1.SubtractNode) {\n        return [new subtract_1.Subtract(node.inputs[graph_1.SubtractNode.T1], node.inputs[graph_1.SubtractNode.T2], node.output)];\n    }\n    else if (node instanceof graph_1.MultiplyNode) {\n        return [new multiply_1.Multiply(node.inputs[graph_1.MultiplyNode.T1], node.inputs[graph_1.MultiplyNode.T2], node.output)];\n    }\n    else if (node instanceof graph_1.DivideNode) {\n        return [new divide_1.Divide(node.inputs[graph_1.DivideNode.T1], node.inputs[graph_1.DivideNode.T2], node.output)];\n    }\n    else if (node instanceof graph_1.ReduceSumNode) {\n        return [new reduce_sum_1.ReduceSum(node.inputs[graph_1.ReduceSumNode.X], node.output)];\n    }\n    else if (graph_util.isInputNode(node)) {\n        return [];\n    }\n    else {\n        throw Error('Unsupported node type: ' + node.constructor.name);\n    }\n}\n//# sourceMappingURL=operation_emitter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wZXJhdGlvbl9lbWl0dGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcGVyYXRpb25fZW1pdHRlci5qcz9kNWY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyYXBoXzEgPSByZXF1aXJlKFwiLi9ncmFwaFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBhZGRfMSA9IHJlcXVpcmUoXCIuL29wcy9hZGRcIik7XG52YXIgYXJnbWF4XzEgPSByZXF1aXJlKFwiLi9vcHMvYXJnbWF4XCIpO1xudmFyIGFyZ21heGVxdWFsc18xID0gcmVxdWlyZShcIi4vb3BzL2FyZ21heGVxdWFsc1wiKTtcbnZhciBjb25jYXQzZF8xID0gcmVxdWlyZShcIi4vb3BzL2NvbmNhdDNkXCIpO1xudmFyIGNvbnZvbHV0aW9uXzEgPSByZXF1aXJlKFwiLi9vcHMvY29udm9sdXRpb25cIik7XG52YXIgZGl2aWRlXzEgPSByZXF1aXJlKFwiLi9vcHMvZGl2aWRlXCIpO1xudmFyIGVsZW1lbnRfd2lzZV9hY3RpdmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcHMvZWxlbWVudF93aXNlX2FjdGl2YXRpb25cIik7XG52YXIgZWxlbWVudF93aXNlX2Nvc3RfMSA9IHJlcXVpcmUoXCIuL29wcy9lbGVtZW50X3dpc2VfY29zdFwiKTtcbnZhciBleHBfMSA9IHJlcXVpcmUoXCIuL29wcy9leHBcIik7XG52YXIgbGluZWFyX2NvbWJpbmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcHMvbGluZWFyX2NvbWJpbmF0aW9uXCIpO1xudmFyIGxvZ18xID0gcmVxdWlyZShcIi4vb3BzL2xvZ1wiKTtcbnZhciBtYXRtdWxfMSA9IHJlcXVpcmUoXCIuL29wcy9tYXRtdWxcIik7XG52YXIgbWF4X3Bvb2xfMSA9IHJlcXVpcmUoXCIuL29wcy9tYXhfcG9vbFwiKTtcbnZhciBtdWx0aXBseV8xID0gcmVxdWlyZShcIi4vb3BzL211bHRpcGx5XCIpO1xudmFyIHJlZHVjZV9zdW1fMSA9IHJlcXVpcmUoXCIuL29wcy9yZWR1Y2Vfc3VtXCIpO1xudmFyIHJlc2hhcGVfMSA9IHJlcXVpcmUoXCIuL29wcy9yZXNoYXBlXCIpO1xudmFyIHNvZnRtYXhfMSA9IHJlcXVpcmUoXCIuL29wcy9zb2Z0bWF4XCIpO1xudmFyIHN1YnRyYWN0XzEgPSByZXF1aXJlKFwiLi9vcHMvc3VidHJhY3RcIik7XG5mdW5jdGlvbiBlbWl0RnJvbUdyYXBoTm9kZXMobm9kZXMpIHtcbiAgICB2YXIgb3BzID0gW107XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkob3BzLCBlbWl0T3BGcm9tTm9kZShub2RlKSk7IH0pO1xuICAgIHJldHVybiBvcHM7XG59XG5leHBvcnRzLmVtaXRGcm9tR3JhcGhOb2RlcyA9IGVtaXRGcm9tR3JhcGhOb2RlcztcbmZ1bmN0aW9uIGVtaXRPcEZyb21Ob2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuUmVzaGFwZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgcmVzaGFwZV8xLlJlc2hhcGUobm9kZS5pbnB1dHNbZ3JhcGhfMS5SZXNoYXBlTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuTWF0TXVsTm9kZSkge1xuICAgICAgICB2YXIgeDEgPSBub2RlLmlucHV0c1tncmFwaF8xLk1hdE11bE5vZGUuWDFdO1xuICAgICAgICB2YXIgeDIgPSBub2RlLmlucHV0c1tncmFwaF8xLk1hdE11bE5vZGUuWDJdO1xuICAgICAgICByZXR1cm4gW25ldyBtYXRtdWxfMS5NYXRNdWwoeDEsIHgyLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5Db252b2x1dGlvbjJETm9kZSkge1xuICAgICAgICB2YXIgdyA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuQ29udm9sdXRpb24yRE5vZGUuV107XG4gICAgICAgIHZhciB4ID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5Db252b2x1dGlvbjJETm9kZS5YXTtcbiAgICAgICAgdmFyIGIgPSBub2RlLmlucHV0c1tncmFwaF8xLkNvbnZvbHV0aW9uMkROb2RlLkJdO1xuICAgICAgICByZXR1cm4gW25ldyBjb252b2x1dGlvbl8xLkNvbnZvbHV0aW9uMkQodywgeCwgYiwgbm9kZS5vdXRwdXQsIG5vZGUuZmllbGRTaXplLCBub2RlLm91dHB1dERlcHRoLCBub2RlLnN0cmlkZSwgbm9kZS56ZXJvUGFkKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLk1heFBvb2xOb2RlKSB7XG4gICAgICAgIHZhciB4ID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5NYXhQb29sTm9kZS5YXTtcbiAgICAgICAgcmV0dXJuIFtuZXcgbWF4X3Bvb2xfMS5NYXhQb29sKHgsIG5vZGUub3V0cHV0LCBub2RlLmZpZWxkU2l6ZSwgbm9kZS5zdHJpZGUsIG5vZGUuemVyb1BhZCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5FeHBOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGV4cF8xLkV4cChub2RlLmlucHV0c1tncmFwaF8xLkV4cE5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkxvZ05vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgbG9nXzEuTG9nKG5vZGUuaW5wdXRzW2dyYXBoXzEuTG9nTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuUmVMVU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgZWxlbWVudF93aXNlX2FjdGl2YXRpb25fMS5SZUxVKG5vZGUuaW5wdXRzW2dyYXBoXzEuUmVMVU5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlRhbkhOb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGVsZW1lbnRfd2lzZV9hY3RpdmF0aW9uXzEuVGFuSChub2RlLmlucHV0c1tncmFwaF8xLlRhbkhOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5TaWdtb2lkTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfYWN0aXZhdGlvbl8xLlNpZ21vaWQobm9kZS5pbnB1dHNbZ3JhcGhfMS5TaWdtb2lkTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlKSB7XG4gICAgICAgIHZhciB4ID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5Tb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUuWF07XG4gICAgICAgIHZhciB0YXJnZXQgPSBub2RlLmlucHV0c1tncmFwaF8xLlNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZS5UQVJHRVRdO1xuICAgICAgICByZXR1cm4gW25ldyBzb2Z0bWF4XzEuU29mdG1heENyb3NzRW50cm9weUNvc3QoeCwgdGFyZ2V0LCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5Tb2Z0bWF4Tm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBzb2Z0bWF4XzEuU29mdG1heChub2RlLmlucHV0c1tncmFwaF8xLlNvZnRtYXhOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5NZWFuU3F1YXJlZENvc3ROb2RlKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuTWVhblNxdWFyZWRDb3N0Tm9kZS5MQUJFTF07XG4gICAgICAgIHZhciBwcmVkaWN0aW9uID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5NZWFuU3F1YXJlZENvc3ROb2RlLlBSRURJQ1RJT05dO1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfY29zdF8xLk1lYW5TcXVhcmVkQ29zdChsYWJlbCwgcHJlZGljdGlvbiwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQXJnTWF4RXF1YWxzTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBhcmdtYXhlcXVhbHNfMS5BcmdNYXhFcXVhbHMobm9kZS5pbnB1dHNbZ3JhcGhfMS5BcmdNYXhFcXVhbHNOb2RlLlgxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5BcmdNYXhFcXVhbHNOb2RlLlgyXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQXJnTWF4Tm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBhcmdtYXhfMS5BcmdNYXgobm9kZS54LCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5GdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBsaW5lYXJfY29tYmluYXRpb25fMS5MaW5lYXJDb21iaW5hdGlvbihub2RlLmlucHV0c1tncmFwaF8xLkZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLlQxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5GdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5UMl0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuQzFdLCBub2RlLmlucHV0c1tncmFwaF8xLkZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLkMyXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQ29uY2F0M0ROb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGNvbmNhdDNkXzEuQ29uY2F0M0Qobm9kZS5pbnB1dHNbZ3JhcGhfMS5Db25jYXQzRE5vZGUuWDFdLCBub2RlLmlucHV0c1tncmFwaF8xLkNvbmNhdDNETm9kZS5YMl0sIG5vZGUuYXhpcywgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuU3F1YXJlTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfYWN0aXZhdGlvbl8xLlNxdWFyZShub2RlLmlucHV0c1tncmFwaF8xLlNxdWFyZU5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkFkZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgYWRkXzEuQWRkKG5vZGUuaW5wdXRzW2dyYXBoXzEuQWRkTm9kZS5UMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuQWRkTm9kZS5UMl0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlN1YnRyYWN0Tm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBzdWJ0cmFjdF8xLlN1YnRyYWN0KG5vZGUuaW5wdXRzW2dyYXBoXzEuU3VidHJhY3ROb2RlLlQxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5TdWJ0cmFjdE5vZGUuVDJdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5NdWx0aXBseU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgbXVsdGlwbHlfMS5NdWx0aXBseShub2RlLmlucHV0c1tncmFwaF8xLk11bHRpcGx5Tm9kZS5UMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuTXVsdGlwbHlOb2RlLlQyXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuRGl2aWRlTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBkaXZpZGVfMS5EaXZpZGUobm9kZS5pbnB1dHNbZ3JhcGhfMS5EaXZpZGVOb2RlLlQxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5EaXZpZGVOb2RlLlQyXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuUmVkdWNlU3VtTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyByZWR1Y2Vfc3VtXzEuUmVkdWNlU3VtKG5vZGUuaW5wdXRzW2dyYXBoXzEuUmVkdWNlU3VtTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ3JhcGhfdXRpbC5pc0lucHV0Tm9kZShub2RlKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgbm9kZSB0eXBlOiAnICsgbm9kZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGVyYXRpb25fZW1pdHRlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/operation_emitter.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/add.js":
/*!**********************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/add.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ../../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar graph_util = __webpack_require__(/*! ../graph_util */ \"./node_modules/deeplearn/dist/src/graph/graph_util.js\");\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar Add = (function (_super) {\n    __extends(Add, _super);\n    function Add(x1Tensor, x2Tensor, yTensor) {\n        var _this = _super.call(this) || this;\n        _this.x1Tensor = x1Tensor;\n        _this.x2Tensor = x2Tensor;\n        _this.yTensor = yTensor;\n        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||\n            util.sizeFromShape(x2Tensor.shape) === 1 ||\n            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +\n            'the same shape');\n        return _this;\n    }\n    Add.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var x1 = inferenceArrays.get(this.x1Tensor);\n        var x2 = inferenceArrays.get(this.x2Tensor);\n        math.scope(function (keep) {\n            var result;\n            if (util.isScalarShape(x1.shape)) {\n                result = math.scalarPlusArray(x1, x2);\n            }\n            else if (util.isScalarShape(x2.shape)) {\n                result = math.scalarPlusArray(x2, x1);\n            }\n            else {\n                result = math.add(x1, x2);\n            }\n            inferenceArrays.set(_this.yTensor, keep(result));\n        });\n    };\n    Add.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        var _this = this;\n        var dy = gradientArrays.get(this.yTensor);\n        math.scope(function () {\n            if (graph_util.shouldBackProp(_this.x1Tensor)) {\n                if (util.isScalarShape(_this.x1Tensor.shape)) {\n                    var sum = math.sum(dy);\n                    if (_this.dySizeScalar == null) {\n                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);\n                    }\n                    gradientArrays.add(_this.x1Tensor, math.divide(sum, _this.dySizeScalar));\n                }\n                else {\n                    gradientArrays.add(_this.x1Tensor, math.clone(dy));\n                }\n            }\n            if (graph_util.shouldBackProp(_this.x2Tensor)) {\n                if (util.isScalarShape(_this.x2Tensor.shape)) {\n                    var sum = math.sum(dy);\n                    if (_this.dySizeScalar == null) {\n                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);\n                    }\n                    gradientArrays.add(_this.x2Tensor, math.divide(sum, _this.dySizeScalar));\n                }\n                else {\n                    gradientArrays.add(_this.x2Tensor, math.clone(dy));\n                }\n            }\n        });\n    };\n    Add.prototype.dispose = function () {\n        if (this.dySizeScalar != null) {\n            this.dySizeScalar.dispose();\n        }\n    };\n    return Add;\n}(op_1.Operation));\nexports.Add = Add;\n//# sourceMappingURL=add.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9hZGQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9hZGQuanM/NTRkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgQWRkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWRkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFkZCh4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh4MVRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh4MlRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwoeDFUZW5zb3Iuc2hhcGUsIHgyVGVuc29yLnNoYXBlKSwgJ09uZSBvZiB0MSBvciB0MiBtdXN0IGJlIGEgc2NhbGFyLCBvciB0MSBhbmQgdDIgbXVzdCBoYXZlICcgK1xuICAgICAgICAgICAgJ3RoZSBzYW1lIHNoYXBlJyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQWRkLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoeDEuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5zY2FsYXJQbHVzQXJyYXkoeDEsIHgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh4Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhclBsdXNBcnJheSh4MiwgeDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5hZGQoeDEsIHgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChyZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBZGQucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZShfdGhpcy54MVRlbnNvci5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IG1hdGguc3VtKGR5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmR5U2l6ZVNjYWxhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5keVNpemVTY2FsYXIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhkeS5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIG1hdGguZGl2aWRlKHN1bSwgX3RoaXMuZHlTaXplU2NhbGFyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIG1hdGguY2xvbmUoZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKF90aGlzLngyVGVuc29yLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VtID0gbWF0aC5zdW0oZHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZHlTaXplU2NhbGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmR5U2l6ZVNjYWxhciA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KGR5LnNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgbWF0aC5kaXZpZGUoc3VtLCBfdGhpcy5keVNpemVTY2FsYXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgbWF0aC5jbG9uZShkeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBZGQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmR5U2l6ZVNjYWxhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmR5U2l6ZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBZGQ7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkFkZCA9IEFkZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/add.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/argmax.js":
/*!*************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/argmax.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar ArgMax = (function (_super) {\n    __extends(ArgMax, _super);\n    function ArgMax(xTensor, yTensor) {\n        var _this = _super.call(this) || this;\n        _this.xTensor = xTensor;\n        _this.yTensor = yTensor;\n        return _this;\n    }\n    ArgMax.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var x = inferenceArrays.get(this.xTensor);\n        math.scope(function (keep) {\n            inferenceArrays.set(_this.yTensor, keep(math.argMax(x)));\n        });\n    };\n    ArgMax.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        throw new Error('ArgMax backprop unimplemented');\n    };\n    return ArgMax;\n}(op_1.Operation));\nexports.ArgMax = ArgMax;\n//# sourceMappingURL=argmax.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9hcmdtYXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9hcmdtYXguanM/YmUwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBBcmdNYXggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcmdNYXgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJnTWF4KHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueFRlbnNvciA9IHhUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFyZ01heC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5hcmdNYXgoeCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBcmdNYXgucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmdNYXggYmFja3Byb3AgdW5pbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIEFyZ01heDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuQXJnTWF4ID0gQXJnTWF4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJnbWF4LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/argmax.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/argmaxequals.js":
/*!*******************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/argmaxequals.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar ArgMaxEquals = (function (_super) {\n    __extends(ArgMaxEquals, _super);\n    function ArgMaxEquals(x1Tensor, x2Tensor, yTensor) {\n        var _this = _super.call(this) || this;\n        _this.x1Tensor = x1Tensor;\n        _this.x2Tensor = x2Tensor;\n        _this.yTensor = yTensor;\n        return _this;\n    }\n    ArgMaxEquals.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var x1 = inferenceArrays.get(this.x1Tensor);\n        var x2 = inferenceArrays.get(this.x2Tensor);\n        math.scope(function (keep) {\n            inferenceArrays.set(_this.yTensor, keep(math.argMaxEquals(x1, x2)));\n        });\n    };\n    ArgMaxEquals.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        throw new Error('ArgMaxEquals backprop unimplemented');\n    };\n    return ArgMaxEquals;\n}(op_1.Operation));\nexports.ArgMaxEquals = ArgMaxEquals;\n//# sourceMappingURL=argmaxequals.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9hcmdtYXhlcXVhbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9hcmdtYXhlcXVhbHMuanM/YzRlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBBcmdNYXhFcXVhbHMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcmdNYXhFcXVhbHMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJnTWF4RXF1YWxzKHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBcmdNYXhFcXVhbHMucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5hcmdNYXhFcXVhbHMoeDEsIHgyKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFyZ01heEVxdWFscy5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ01heEVxdWFscyBiYWNrcHJvcCB1bmltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gQXJnTWF4RXF1YWxzO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5BcmdNYXhFcXVhbHMgPSBBcmdNYXhFcXVhbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcmdtYXhlcXVhbHMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/argmaxequals.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/concat3d.js":
/*!***************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/concat3d.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar concat_util = __webpack_require__(/*! ../../math/concat_util */ \"./node_modules/deeplearn/dist/src/math/concat_util.js\");\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar Concat3D = (function (_super) {\n    __extends(Concat3D, _super);\n    function Concat3D(x1Tensor, x2Tensor, axis, yTensor) {\n        var _this = _super.call(this) || this;\n        _this.x1Tensor = x1Tensor;\n        _this.x2Tensor = x2Tensor;\n        _this.axis = axis;\n        _this.yTensor = yTensor;\n        concat_util.assertParams(x1Tensor.shape, x2Tensor.shape, axis);\n        return _this;\n    }\n    Concat3D.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var x1 = inferenceArrays.get(this.x1Tensor);\n        var x2 = inferenceArrays.get(this.x2Tensor);\n        math.scope(function (keep) {\n            var concatResult = math.concat3D(x1, x2, _this.axis);\n            inferenceArrays.set(_this.yTensor, keep(concatResult));\n        });\n    };\n    Concat3D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        throw new Error('Concat3D backprop not implemented.');\n    };\n    return Concat3D;\n}(op_1.Operation));\nexports.Concat3D = Concat3D;\n//# sourceMappingURL=concat3d.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9jb25jYXQzZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL2NvbmNhdDNkLmpzPzBhYjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb25jYXRfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL2NvbmNhdF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBDb25jYXQzRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmNhdDNELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmNhdDNEKHgxVGVuc29yLCB4MlRlbnNvciwgYXhpcywgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy5heGlzID0gYXhpcztcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIGNvbmNhdF91dGlsLmFzc2VydFBhcmFtcyh4MVRlbnNvci5zaGFwZSwgeDJUZW5zb3Iuc2hhcGUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbmNhdDNELnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIGNvbmNhdFJlc3VsdCA9IG1hdGguY29uY2F0M0QoeDEsIHgyLCBfdGhpcy5heGlzKTtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChjb25jYXRSZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25jYXQzRC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmNhdDNEIGJhY2twcm9wIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9O1xuICAgIHJldHVybiBDb25jYXQzRDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuQ29uY2F0M0QgPSBDb25jYXQzRDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdDNkLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/concat3d.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/convolution.js":
/*!******************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/convolution.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar conv_util = __webpack_require__(/*! ../../math/conv_util */ \"./node_modules/deeplearn/dist/src/math/conv_util.js\");\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar Convolution2D = (function (_super) {\n    __extends(Convolution2D, _super);\n    function Convolution2D(wTensor, xTensor, bTensor, yTensor, fieldSize, outputDepth, stride, zeroPad) {\n        if (stride === void 0) { stride = 1; }\n        var _this = _super.call(this) || this;\n        _this.wTensor = wTensor;\n        _this.xTensor = xTensor;\n        _this.bTensor = bTensor;\n        _this.yTensor = yTensor;\n        _this.fieldSize = fieldSize;\n        _this.outputDepth = outputDepth;\n        _this.stride = stride;\n        _this.assertWeightsShape(wTensor.shape);\n        _this.zeroPad = zeroPad != null ?\n            zeroPad :\n            conv_util.computeDefaultPad(_this.xTensor.shape, _this.fieldSize, _this.stride);\n        util.assert(util.isInt(_this.zeroPad), \"The zero padding (\" + _this.zeroPad + \") must be an integer. Change the \" +\n            \"stride and/or zero pad parameters\");\n        return _this;\n    }\n    Convolution2D.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var weights = inferenceArrays.get(this.wTensor);\n        var biases = inferenceArrays.get(this.bTensor);\n        var x = inferenceArrays.get(this.xTensor);\n        math.scope(function (keep) {\n            inferenceArrays.set(_this.yTensor, keep(math.conv2d(x, weights, biases, _this.stride, _this.zeroPad)));\n        });\n    };\n    Convolution2D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        var _this = this;\n        var weights = inferenceArrays.get(this.wTensor);\n        var x = inferenceArrays.get(this.xTensor);\n        var dy = gradientArrays.get(this.yTensor);\n        math.scope(function () {\n            var _a = math.conv2dBackProp(x, dy, weights, _this.stride, _this.zeroPad), dw = _a.dw, db = _a.db, dx = _a.dx;\n            gradientArrays.add(_this.wTensor, dw);\n            gradientArrays.add(_this.bTensor, db);\n            gradientArrays.add(_this.xTensor, dx);\n        });\n    };\n    Convolution2D.prototype.assertWeightsShape = function (weightsShape) {\n        util.assert(weightsShape[0] === this.fieldSize &&\n            weightsShape[1] === this.fieldSize &&\n            weightsShape[2] === this.xTensor.shape[2] &&\n            weightsShape[3] === this.outputDepth, \"weights must be of shape [\" + this.fieldSize + \",\" + this.fieldSize + \",\" +\n            (this.xTensor.shape[2] + \",\" + this.outputDepth + \"] but they are of\") +\n            (\"shape [\" + weightsShape + \"]\"));\n    };\n    return Convolution2D;\n}(op_1.Operation));\nexports.Convolution2D = Convolution2D;\n//# sourceMappingURL=convolution.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9jb252b2x1dGlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL2NvbnZvbHV0aW9uLmpzPzFiZDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb252X3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9jb252X3V0aWxcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBDb252b2x1dGlvbjJEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29udm9sdXRpb24yRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb252b2x1dGlvbjJEKHdUZW5zb3IsIHhUZW5zb3IsIGJUZW5zb3IsIHlUZW5zb3IsIGZpZWxkU2l6ZSwgb3V0cHV0RGVwdGgsIHN0cmlkZSwgemVyb1BhZCkge1xuICAgICAgICBpZiAoc3RyaWRlID09PSB2b2lkIDApIHsgc3RyaWRlID0gMTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy53VGVuc29yID0gd1RlbnNvcjtcbiAgICAgICAgX3RoaXMueFRlbnNvciA9IHhUZW5zb3I7XG4gICAgICAgIF90aGlzLmJUZW5zb3IgPSBiVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgX3RoaXMuZmllbGRTaXplID0gZmllbGRTaXplO1xuICAgICAgICBfdGhpcy5vdXRwdXREZXB0aCA9IG91dHB1dERlcHRoO1xuICAgICAgICBfdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG4gICAgICAgIF90aGlzLmFzc2VydFdlaWdodHNTaGFwZSh3VGVuc29yLnNoYXBlKTtcbiAgICAgICAgX3RoaXMuemVyb1BhZCA9IHplcm9QYWQgIT0gbnVsbCA/XG4gICAgICAgICAgICB6ZXJvUGFkIDpcbiAgICAgICAgICAgIGNvbnZfdXRpbC5jb21wdXRlRGVmYXVsdFBhZChfdGhpcy54VGVuc29yLnNoYXBlLCBfdGhpcy5maWVsZFNpemUsIF90aGlzLnN0cmlkZSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQoX3RoaXMuemVyb1BhZCksIFwiVGhlIHplcm8gcGFkZGluZyAoXCIgKyBfdGhpcy56ZXJvUGFkICsgXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBcIiArXG4gICAgICAgICAgICBcInN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb252b2x1dGlvbjJELnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHdlaWdodHMgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMud1RlbnNvcik7XG4gICAgICAgIHZhciBiaWFzZXMgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuYlRlbnNvcik7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5jb252MmQoeCwgd2VpZ2h0cywgYmlhc2VzLCBfdGhpcy5zdHJpZGUsIF90aGlzLnplcm9QYWQpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udm9sdXRpb24yRC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgd2VpZ2h0cyA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy53VGVuc29yKTtcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IG1hdGguY29udjJkQmFja1Byb3AoeCwgZHksIHdlaWdodHMsIF90aGlzLnN0cmlkZSwgX3RoaXMuemVyb1BhZCksIGR3ID0gX2EuZHcsIGRiID0gX2EuZGIsIGR4ID0gX2EuZHg7XG4gICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMud1RlbnNvciwgZHcpO1xuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLmJUZW5zb3IsIGRiKTtcbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54VGVuc29yLCBkeCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udm9sdXRpb24yRC5wcm90b3R5cGUuYXNzZXJ0V2VpZ2h0c1NoYXBlID0gZnVuY3Rpb24gKHdlaWdodHNTaGFwZSkge1xuICAgICAgICB1dGlsLmFzc2VydCh3ZWlnaHRzU2hhcGVbMF0gPT09IHRoaXMuZmllbGRTaXplICYmXG4gICAgICAgICAgICB3ZWlnaHRzU2hhcGVbMV0gPT09IHRoaXMuZmllbGRTaXplICYmXG4gICAgICAgICAgICB3ZWlnaHRzU2hhcGVbMl0gPT09IHRoaXMueFRlbnNvci5zaGFwZVsyXSAmJlxuICAgICAgICAgICAgd2VpZ2h0c1NoYXBlWzNdID09PSB0aGlzLm91dHB1dERlcHRoLCBcIndlaWdodHMgbXVzdCBiZSBvZiBzaGFwZSBbXCIgKyB0aGlzLmZpZWxkU2l6ZSArIFwiLFwiICsgdGhpcy5maWVsZFNpemUgKyBcIixcIiArXG4gICAgICAgICAgICAodGhpcy54VGVuc29yLnNoYXBlWzJdICsgXCIsXCIgKyB0aGlzLm91dHB1dERlcHRoICsgXCJdIGJ1dCB0aGV5IGFyZSBvZlwiKSArXG4gICAgICAgICAgICAoXCJzaGFwZSBbXCIgKyB3ZWlnaHRzU2hhcGUgKyBcIl1cIikpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnZvbHV0aW9uMkQ7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkNvbnZvbHV0aW9uMkQgPSBDb252b2x1dGlvbjJEO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udm9sdXRpb24uanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/convolution.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/divide.js":
/*!*************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/divide.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar graph_util = __webpack_require__(/*! ../graph_util */ \"./node_modules/deeplearn/dist/src/graph/graph_util.js\");\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar Divide = (function (_super) {\n    __extends(Divide, _super);\n    function Divide(x1Tensor, x2Tensor, yTensor) {\n        var _this = _super.call(this) || this;\n        _this.x1Tensor = x1Tensor;\n        _this.x2Tensor = x2Tensor;\n        _this.yTensor = yTensor;\n        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||\n            util.sizeFromShape(x2Tensor.shape) === 1 ||\n            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +\n            'the same shape');\n        return _this;\n    }\n    Divide.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var t1 = inferenceArrays.get(this.x1Tensor);\n        var t2 = inferenceArrays.get(this.x2Tensor);\n        math.scope(function (keep) {\n            var result;\n            if (util.isScalarShape(t1.shape)) {\n                result = math.scalarDividedByArray(t1, t2);\n            }\n            else if (util.isScalarShape(t2.shape)) {\n                result = math.arrayDividedByScalar(t1, t2);\n            }\n            else {\n                result = math.divide(t1, t2);\n            }\n            inferenceArrays.set(_this.yTensor, keep(result));\n        });\n    };\n    Divide.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        var _this = this;\n        var x1 = inferenceArrays.get(this.x1Tensor);\n        var x2 = inferenceArrays.get(this.x2Tensor);\n        var dy = gradientArrays.get(this.yTensor);\n        var x1IsScalar = util.isScalarShape(x1.shape);\n        var x2IsScalar = util.isScalarShape(x2.shape);\n        math.scope(function () {\n            if (graph_util.shouldBackProp(_this.x1Tensor)) {\n                if (x1IsScalar) {\n                    var div = math.divide(dy, x2);\n                    gradientArrays.add(_this.x1Tensor, math.sum(div));\n                    div.dispose();\n                }\n                else if (x2IsScalar) {\n                    gradientArrays.add(_this.x1Tensor, math.arrayDividedByScalar(dy, x2));\n                }\n                else {\n                    gradientArrays.add(_this.x1Tensor, math.divide(dy, x2));\n                }\n            }\n            if (graph_util.shouldBackProp(_this.x2Tensor)) {\n                var x2Squared = math.elementWiseMul(x2, x2);\n                var x1OverX2Squared = void 0;\n                if (x2IsScalar) {\n                    x1OverX2Squared = math.arrayDividedByScalar(x1, x2Squared);\n                }\n                else if (x1IsScalar) {\n                    x1OverX2Squared = math.scalarDividedByArray(x1, x2Squared);\n                }\n                else {\n                    x1OverX2Squared = math.divide(x1, x2Squared);\n                }\n                var dx2 = math.neg(x1OverX2Squared);\n                var dyTimesDerivative = math.elementWiseMul(dy, dx2);\n                if (x2IsScalar) {\n                    gradientArrays.add(_this.x2Tensor, math.sum(dyTimesDerivative));\n                }\n                else {\n                    gradientArrays.add(_this.x2Tensor, dyTimesDerivative);\n                }\n            }\n        });\n    };\n    return Divide;\n}(op_1.Operation));\nexports.Divide = Divide;\n//# sourceMappingURL=divide.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9kaXZpZGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9kaXZpZGUuanM/ZGFlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIERpdmlkZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpdmlkZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaXZpZGUoeDFUZW5zb3IsIHgyVGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLnNpemVGcm9tU2hhcGUoeDFUZW5zb3Iuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUoeDJUZW5zb3Iuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHgxVGVuc29yLnNoYXBlLCB4MlRlbnNvci5zaGFwZSksICdPbmUgb2YgdDEgb3IgdDIgbXVzdCBiZSBhIHNjYWxhciwgb3IgdDEgYW5kIHQyIG11c3QgaGF2ZSAnICtcbiAgICAgICAgICAgICd0aGUgc2FtZSBzaGFwZScpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERpdmlkZS5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB0MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHQxLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguc2NhbGFyRGl2aWRlZEJ5QXJyYXkodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLmFycmF5RGl2aWRlZEJ5U2NhbGFyKHQxLCB0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLmRpdmlkZSh0MSwgdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKHJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERpdmlkZS5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgdmFyIHgxSXNTY2FsYXIgPSB1dGlsLmlzU2NhbGFyU2hhcGUoeDEuc2hhcGUpO1xuICAgICAgICB2YXIgeDJJc1NjYWxhciA9IHV0aWwuaXNTY2FsYXJTaGFwZSh4Mi5zaGFwZSk7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHgxSXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpdiA9IG1hdGguZGl2aWRlKGR5LCB4Mik7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5zdW0oZGl2KSk7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHgySXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLmFycmF5RGl2aWRlZEJ5U2NhbGFyKGR5LCB4MikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLmRpdmlkZShkeSwgeDIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgeDJTcXVhcmVkID0gbWF0aC5lbGVtZW50V2lzZU11bCh4MiwgeDIpO1xuICAgICAgICAgICAgICAgIHZhciB4MU92ZXJYMlNxdWFyZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHgySXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgeDFPdmVyWDJTcXVhcmVkID0gbWF0aC5hcnJheURpdmlkZWRCeVNjYWxhcih4MSwgeDJTcXVhcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeDFJc1NjYWxhcikge1xuICAgICAgICAgICAgICAgICAgICB4MU92ZXJYMlNxdWFyZWQgPSBtYXRoLnNjYWxhckRpdmlkZWRCeUFycmF5KHgxLCB4MlNxdWFyZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeDFPdmVyWDJTcXVhcmVkID0gbWF0aC5kaXZpZGUoeDEsIHgyU3F1YXJlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkeDIgPSBtYXRoLm5lZyh4MU92ZXJYMlNxdWFyZWQpO1xuICAgICAgICAgICAgICAgIHZhciBkeVRpbWVzRGVyaXZhdGl2ZSA9IG1hdGguZWxlbWVudFdpc2VNdWwoZHksIGR4Mik7XG4gICAgICAgICAgICAgICAgaWYgKHgySXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBtYXRoLnN1bShkeVRpbWVzRGVyaXZhdGl2ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBkeVRpbWVzRGVyaXZhdGl2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBEaXZpZGU7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkRpdmlkZSA9IERpdmlkZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpdmlkZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/divide.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/element_wise_activation.js":
/*!******************************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/element_wise_activation.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar activation_functions_1 = __webpack_require__(/*! ../../math/activation_functions */ \"./node_modules/deeplearn/dist/src/math/activation_functions.js\");\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar ElementWiseActivation = (function (_super) {\n    __extends(ElementWiseActivation, _super);\n    function ElementWiseActivation(xTensor, yTensor, func) {\n        var _this = _super.call(this) || this;\n        _this.xTensor = xTensor;\n        _this.yTensor = yTensor;\n        _this.func = func;\n        return _this;\n    }\n    ElementWiseActivation.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var x = inferenceArrays.get(this.xTensor);\n        math.scope(function (keep) {\n            inferenceArrays.set(_this.yTensor, keep(_this.func.output(math, x)));\n        });\n    };\n    ElementWiseActivation.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        var _this = this;\n        var x = inferenceArrays.get(this.xTensor);\n        var y = inferenceArrays.get(this.yTensor);\n        var dy = gradientArrays.get(this.yTensor);\n        math.scope(function () {\n            var dydx = _this.func.der(math, x, y);\n            gradientArrays.add(_this.xTensor, math.elementWiseMul(dy, dydx));\n            dydx.dispose();\n        });\n    };\n    return ElementWiseActivation;\n}(op_1.Operation));\nexports.ElementWiseActivation = ElementWiseActivation;\nvar ReLU = (function (_super) {\n    __extends(ReLU, _super);\n    function ReLU(xTensor, yTensor) {\n        return _super.call(this, xTensor, yTensor, new activation_functions_1.ReLUFunc()) || this;\n    }\n    return ReLU;\n}(ElementWiseActivation));\nexports.ReLU = ReLU;\nvar TanH = (function (_super) {\n    __extends(TanH, _super);\n    function TanH(xTensor, yTensor) {\n        return _super.call(this, xTensor, yTensor, new activation_functions_1.TanHFunc()) || this;\n    }\n    return TanH;\n}(ElementWiseActivation));\nexports.TanH = TanH;\nvar Sigmoid = (function (_super) {\n    __extends(Sigmoid, _super);\n    function Sigmoid(xTensor, yTensor) {\n        return _super.call(this, xTensor, yTensor, new activation_functions_1.SigmoidFunc()) || this;\n    }\n    return Sigmoid;\n}(ElementWiseActivation));\nexports.Sigmoid = Sigmoid;\nvar Square = (function (_super) {\n    __extends(Square, _super);\n    function Square(xTensor, yTensor) {\n        return _super.call(this, xTensor, yTensor, new activation_functions_1.SquareFunc()) || this;\n    }\n    return Square;\n}(ElementWiseActivation));\nexports.Square = Square;\n//# sourceMappingURL=element_wise_activation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9lbGVtZW50X3dpc2VfYWN0aXZhdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL2VsZW1lbnRfd2lzZV9hY3RpdmF0aW9uLmpzPzczY2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhY3RpdmF0aW9uX2Z1bmN0aW9uc18xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvYWN0aXZhdGlvbl9mdW5jdGlvbnNcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIEVsZW1lbnRXaXNlQWN0aXZhdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVsZW1lbnRXaXNlQWN0aXZhdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbGVtZW50V2lzZUFjdGl2YXRpb24oeFRlbnNvciwgeVRlbnNvciwgZnVuYykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54VGVuc29yID0geFRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIF90aGlzLmZ1bmMgPSBmdW5jO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEVsZW1lbnRXaXNlQWN0aXZhdGlvbi5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAoX3RoaXMuZnVuYy5vdXRwdXQobWF0aCwgeCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbGVtZW50V2lzZUFjdGl2YXRpb24ucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIHZhciB5ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZHlkeCA9IF90aGlzLmZ1bmMuZGVyKG1hdGgsIHgsIHkpO1xuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnhUZW5zb3IsIG1hdGguZWxlbWVudFdpc2VNdWwoZHksIGR5ZHgpKTtcbiAgICAgICAgICAgIGR5ZHguZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50V2lzZUFjdGl2YXRpb247XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkVsZW1lbnRXaXNlQWN0aXZhdGlvbiA9IEVsZW1lbnRXaXNlQWN0aXZhdGlvbjtcbnZhciBSZUxVID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVMVSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZUxVKHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHhUZW5zb3IsIHlUZW5zb3IsIG5ldyBhY3RpdmF0aW9uX2Z1bmN0aW9uc18xLlJlTFVGdW5jKCkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZUxVO1xufShFbGVtZW50V2lzZUFjdGl2YXRpb24pKTtcbmV4cG9ydHMuUmVMVSA9IFJlTFU7XG52YXIgVGFuSCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhbkgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFuSCh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4VGVuc29yLCB5VGVuc29yLCBuZXcgYWN0aXZhdGlvbl9mdW5jdGlvbnNfMS5UYW5IRnVuYygpKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGFuSDtcbn0oRWxlbWVudFdpc2VBY3RpdmF0aW9uKSk7XG5leHBvcnRzLlRhbkggPSBUYW5IO1xudmFyIFNpZ21vaWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaWdtb2lkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpZ21vaWQoeFRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeFRlbnNvciwgeVRlbnNvciwgbmV3IGFjdGl2YXRpb25fZnVuY3Rpb25zXzEuU2lnbW9pZEZ1bmMoKSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNpZ21vaWQ7XG59KEVsZW1lbnRXaXNlQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5TaWdtb2lkID0gU2lnbW9pZDtcbnZhciBTcXVhcmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTcXVhcmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3F1YXJlKHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHhUZW5zb3IsIHlUZW5zb3IsIG5ldyBhY3RpdmF0aW9uX2Z1bmN0aW9uc18xLlNxdWFyZUZ1bmMoKSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNxdWFyZTtcbn0oRWxlbWVudFdpc2VBY3RpdmF0aW9uKSk7XG5leHBvcnRzLlNxdWFyZSA9IFNxdWFyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsZW1lbnRfd2lzZV9hY3RpdmF0aW9uLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/element_wise_activation.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/element_wise_cost.js":
/*!************************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/element_wise_cost.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar cost_functions_1 = __webpack_require__(/*! ../../math/cost_functions */ \"./node_modules/deeplearn/dist/src/math/cost_functions.js\");\nvar ndarray_1 = __webpack_require__(/*! ../../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar graph_util = __webpack_require__(/*! ../graph_util */ \"./node_modules/deeplearn/dist/src/graph/graph_util.js\");\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar ElementWiseCost = (function (_super) {\n    __extends(ElementWiseCost, _super);\n    function ElementWiseCost(x1Tensor, x2Tensor, yTensor, func) {\n        var _this = _super.call(this) || this;\n        _this.x1Tensor = x1Tensor;\n        _this.x2Tensor = x2Tensor;\n        _this.yTensor = yTensor;\n        _this.func = func;\n        _this.oneOverNScalar = ndarray_1.Scalar.new(1 / util.sizeFromShape(x1Tensor.shape));\n        return _this;\n    }\n    ElementWiseCost.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var x1 = inferenceArrays.get(this.x1Tensor);\n        var x2 = inferenceArrays.get(this.x2Tensor);\n        math.scope(function (keep) {\n            var elementWiseCost = _this.func.cost(math, x1, x2);\n            var sum = math.sum(elementWiseCost);\n            var result = math.scalarTimesArray(_this.oneOverNScalar, sum);\n            inferenceArrays.set(_this.yTensor, keep(result));\n        });\n    };\n    ElementWiseCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        var _this = this;\n        var x1 = inferenceArrays.get(this.x1Tensor);\n        var x2 = inferenceArrays.get(this.x2Tensor);\n        math.scope(function () {\n            if (graph_util.shouldBackProp(_this.x1Tensor)) {\n                gradientArrays.add(_this.x1Tensor, _this.func.der(math, x1, x2));\n            }\n            if (graph_util.shouldBackProp(_this.x2Tensor)) {\n                gradientArrays.add(_this.x2Tensor, _this.func.der(math, x2, x1));\n            }\n        });\n    };\n    ElementWiseCost.prototype.dispose = function () {\n        this.func.dispose();\n        this.oneOverNScalar.dispose();\n    };\n    return ElementWiseCost;\n}(op_1.Operation));\nexports.ElementWiseCost = ElementWiseCost;\nvar MeanSquaredCost = (function (_super) {\n    __extends(MeanSquaredCost, _super);\n    function MeanSquaredCost(x1Tensor, x2Tensor, yTensor) {\n        return _super.call(this, x1Tensor, x2Tensor, yTensor, new cost_functions_1.SquareCostFunc()) || this;\n    }\n    return MeanSquaredCost;\n}(ElementWiseCost));\nexports.MeanSquaredCost = MeanSquaredCost;\n//# sourceMappingURL=element_wise_cost.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9lbGVtZW50X3dpc2VfY29zdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL2VsZW1lbnRfd2lzZV9jb3N0LmpzP2YxNTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb3N0X2Z1bmN0aW9uc18xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvY29zdF9mdW5jdGlvbnNcIik7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBFbGVtZW50V2lzZUNvc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbGVtZW50V2lzZUNvc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRWxlbWVudFdpc2VDb3N0KHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvciwgZnVuYykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgX3RoaXMuZnVuYyA9IGZ1bmM7XG4gICAgICAgIF90aGlzLm9uZU92ZXJOU2NhbGFyID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMSAvIHV0aWwuc2l6ZUZyb21TaGFwZSh4MVRlbnNvci5zaGFwZSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEVsZW1lbnRXaXNlQ29zdC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50V2lzZUNvc3QgPSBfdGhpcy5mdW5jLmNvc3QobWF0aCwgeDEsIHgyKTtcbiAgICAgICAgICAgIHZhciBzdW0gPSBtYXRoLnN1bShlbGVtZW50V2lzZUNvc3QpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1hdGguc2NhbGFyVGltZXNBcnJheShfdGhpcy5vbmVPdmVyTlNjYWxhciwgc3VtKTtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChyZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbGVtZW50V2lzZUNvc3QucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MVRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIF90aGlzLmZ1bmMuZGVyKG1hdGgsIHgxLCB4MikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDJUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBfdGhpcy5mdW5jLmRlcihtYXRoLCB4MiwgeDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbGVtZW50V2lzZUNvc3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZnVuYy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMub25lT3Zlck5TY2FsYXIuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRXaXNlQ29zdDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuRWxlbWVudFdpc2VDb3N0ID0gRWxlbWVudFdpc2VDb3N0O1xudmFyIE1lYW5TcXVhcmVkQ29zdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lYW5TcXVhcmVkQ29zdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZWFuU3F1YXJlZENvc3QoeDFUZW5zb3IsIHgyVGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IsIG5ldyBjb3N0X2Z1bmN0aW9uc18xLlNxdWFyZUNvc3RGdW5jKCkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZWFuU3F1YXJlZENvc3Q7XG59KEVsZW1lbnRXaXNlQ29zdCkpO1xuZXhwb3J0cy5NZWFuU3F1YXJlZENvc3QgPSBNZWFuU3F1YXJlZENvc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGVtZW50X3dpc2VfY29zdC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/element_wise_cost.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/exp.js":
/*!**********************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/exp.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graph_util = __webpack_require__(/*! ../graph_util */ \"./node_modules/deeplearn/dist/src/graph/graph_util.js\");\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar Exp = (function (_super) {\n    __extends(Exp, _super);\n    function Exp(xTensor, yTensor) {\n        var _this = _super.call(this) || this;\n        _this.xTensor = xTensor;\n        _this.yTensor = yTensor;\n        return _this;\n    }\n    Exp.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var x = inferenceArrays.get(this.xTensor);\n        math.scope(function (keep) {\n            inferenceArrays.set(_this.yTensor, keep(math.exp(x)));\n        });\n    };\n    Exp.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        var _this = this;\n        var y = inferenceArrays.get(this.yTensor);\n        var dy = gradientArrays.get(this.yTensor);\n        math.scope(function () {\n            if (graph_util.shouldBackProp(_this.xTensor)) {\n                gradientArrays.add(_this.xTensor, math.elementWiseMul(y, dy));\n            }\n        });\n    };\n    return Exp;\n}(op_1.Operation));\nexports.Exp = Exp;\n//# sourceMappingURL=exp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9leHAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9leHAuanM/YjEyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgRXhwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXhwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4cCh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnhUZW5zb3IgPSB4VGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFeHAucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKG1hdGguZXhwKHgpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRXhwLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB5ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54VGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54VGVuc29yLCBtYXRoLmVsZW1lbnRXaXNlTXVsKHksIGR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEV4cDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuRXhwID0gRXhwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/exp.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/linear_combination.js":
/*!*************************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/linear_combination.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graph_util = __webpack_require__(/*! ../graph_util */ \"./node_modules/deeplearn/dist/src/graph/graph_util.js\");\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar LinearCombination = (function (_super) {\n    __extends(LinearCombination, _super);\n    function LinearCombination(x1Tensor, x2Tensor, c1Tensor, c2Tensor, outTensor) {\n        var _this = _super.call(this) || this;\n        _this.x1Tensor = x1Tensor;\n        _this.x2Tensor = x2Tensor;\n        _this.c1Tensor = c1Tensor;\n        _this.c2Tensor = c2Tensor;\n        _this.outTensor = outTensor;\n        return _this;\n    }\n    LinearCombination.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var x1 = inferenceArrays.get(this.x1Tensor);\n        var x2 = inferenceArrays.get(this.x2Tensor);\n        var c1 = inferenceArrays.get(this.c1Tensor).asScalar();\n        var c2 = inferenceArrays.get(this.c2Tensor).asScalar();\n        math.scope(function (keep) {\n            inferenceArrays.set(_this.outTensor, keep(math.scaledArrayAdd(c1, x1, c2, x2)));\n        });\n    };\n    LinearCombination.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        var _this = this;\n        var x1 = inferenceArrays.get(this.x1Tensor);\n        var x2 = inferenceArrays.get(this.x2Tensor);\n        var c1 = inferenceArrays.get(this.c1Tensor);\n        var c2 = inferenceArrays.get(this.c2Tensor);\n        var dy = gradientArrays.get(this.outTensor);\n        math.scope(function () {\n            if (graph_util.shouldBackProp(_this.x1Tensor)) {\n                gradientArrays.add(_this.x1Tensor, math.scalarTimesArray(c1, dy));\n            }\n            if (graph_util.shouldBackProp(_this.x2Tensor)) {\n                gradientArrays.add(_this.x2Tensor, math.scalarTimesArray(c2, dy));\n            }\n            if (graph_util.shouldBackProp(_this.c1Tensor)) {\n                var dotProduct1 = math.elementWiseMul(x1, dy);\n                gradientArrays.add(_this.c1Tensor, math.sum(dotProduct1));\n            }\n            if (graph_util.shouldBackProp(_this.c2Tensor)) {\n                var dotProduct2 = math.elementWiseMul(x2, dy);\n                gradientArrays.add(_this.c2Tensor, math.sum(dotProduct2));\n            }\n        });\n    };\n    return LinearCombination;\n}(op_1.Operation));\nexports.LinearCombination = LinearCombination;\n//# sourceMappingURL=linear_combination.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9saW5lYXJfY29tYmluYXRpb24uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9saW5lYXJfY29tYmluYXRpb24uanM/ZDRlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgTGluZWFyQ29tYmluYXRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaW5lYXJDb21iaW5hdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5lYXJDb21iaW5hdGlvbih4MVRlbnNvciwgeDJUZW5zb3IsIGMxVGVuc29yLCBjMlRlbnNvciwgb3V0VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLmMxVGVuc29yID0gYzFUZW5zb3I7XG4gICAgICAgIF90aGlzLmMyVGVuc29yID0gYzJUZW5zb3I7XG4gICAgICAgIF90aGlzLm91dFRlbnNvciA9IG91dFRlbnNvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMaW5lYXJDb21iaW5hdGlvbi5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIHZhciBjMSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5jMVRlbnNvcikuYXNTY2FsYXIoKTtcbiAgICAgICAgdmFyIGMyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmMyVGVuc29yKS5hc1NjYWxhcigpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLm91dFRlbnNvciwga2VlcChtYXRoLnNjYWxlZEFycmF5QWRkKGMxLCB4MSwgYzIsIHgyKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExpbmVhckNvbWJpbmF0aW9uLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIHZhciBjMSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5jMVRlbnNvcik7XG4gICAgICAgIHZhciBjMiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5jMlRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLm91dFRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLnNjYWxhclRpbWVzQXJyYXkoYzEsIGR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDJUZW5zb3IsIG1hdGguc2NhbGFyVGltZXNBcnJheShjMiwgZHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLmMxVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kdWN0MSA9IG1hdGguZWxlbWVudFdpc2VNdWwoeDEsIGR5KTtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMuYzFUZW5zb3IsIG1hdGguc3VtKGRvdFByb2R1Y3QxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy5jMlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG90UHJvZHVjdDIgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKHgyLCBkeSk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLmMyVGVuc29yLCBtYXRoLnN1bShkb3RQcm9kdWN0MikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBMaW5lYXJDb21iaW5hdGlvbjtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuTGluZWFyQ29tYmluYXRpb24gPSBMaW5lYXJDb21iaW5hdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmVhcl9jb21iaW5hdGlvbi5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/linear_combination.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/log.js":
/*!**********************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/log.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graph_util = __webpack_require__(/*! ../graph_util */ \"./node_modules/deeplearn/dist/src/graph/graph_util.js\");\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar Log = (function (_super) {\n    __extends(Log, _super);\n    function Log(xTensor, yTensor) {\n        var _this = _super.call(this) || this;\n        _this.xTensor = xTensor;\n        _this.yTensor = yTensor;\n        return _this;\n    }\n    Log.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var x = inferenceArrays.get(this.xTensor);\n        math.scope(function (keep) {\n            inferenceArrays.set(_this.yTensor, keep(math.log(x)));\n        });\n    };\n    Log.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        var _this = this;\n        var x = inferenceArrays.get(this.xTensor);\n        var dy = gradientArrays.get(this.yTensor);\n        math.scope(function () {\n            if (graph_util.shouldBackProp(_this.xTensor)) {\n                gradientArrays.add(_this.xTensor, math.divide(dy, x));\n            }\n        });\n    };\n    return Log;\n}(op_1.Operation));\nexports.Log = Log;\n//# sourceMappingURL=log.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9sb2cuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9sb2cuanM/ODA0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgTG9nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExvZyh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnhUZW5zb3IgPSB4VGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMb2cucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKG1hdGgubG9nKHgpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9nLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54VGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54VGVuc29yLCBtYXRoLmRpdmlkZShkeSwgeCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBMb2c7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkxvZyA9IExvZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/log.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/matmul.js":
/*!*************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/matmul.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar math_1 = __webpack_require__(/*! ../../math/math */ \"./node_modules/deeplearn/dist/src/math/math.js\");\nvar graph_util = __webpack_require__(/*! ../graph_util */ \"./node_modules/deeplearn/dist/src/graph/graph_util.js\");\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar MatMul = (function (_super) {\n    __extends(MatMul, _super);\n    function MatMul(x1Tensor, x2Tensor, yTensor) {\n        var _this = _super.call(this) || this;\n        _this.x1Tensor = x1Tensor;\n        _this.x2Tensor = x2Tensor;\n        _this.yTensor = yTensor;\n        return _this;\n    }\n    MatMul.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var x1 = inferenceArrays.get(this.x1Tensor);\n        var x2 = inferenceArrays.get(this.x2Tensor);\n        math.scope(function (keep) {\n            if (x1.shape.length === 2 && x2.shape.length === 2) {\n                inferenceArrays.set(_this.yTensor, keep(math.matMul(x1, x2)));\n            }\n            else if (x1.shape.length === 2 && x2.shape.length === 1) {\n                inferenceArrays.set(_this.yTensor, keep(math.matrixTimesVector(x1, x2)));\n            }\n            else if (x1.shape.length === 1 && x2.shape.length === 2) {\n                inferenceArrays.set(_this.yTensor, keep(math.vectorTimesMatrix(x1, x2)));\n            }\n        });\n    };\n    MatMul.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        var _this = this;\n        var x1 = inferenceArrays.get(this.x1Tensor);\n        var x2 = inferenceArrays.get(this.x2Tensor);\n        var dy = gradientArrays.get(this.yTensor);\n        if (x1.shape.length === 1) {\n            x1 = x1.reshape([1, x1.size]);\n            dy = dy.reshape([1, dy.size]);\n        }\n        if (x2.shape.length === 1) {\n            x2 = x2.reshape([x2.size, 1]);\n            dy = dy.reshape([dy.size, 1]);\n        }\n        math.scope(function () {\n            if (graph_util.shouldBackProp(_this.x1Tensor)) {\n                var dx1 = math.matMul(dy, x2, math_1.MatrixOrientation.REGULAR, math_1.MatrixOrientation.TRANSPOSED);\n                gradientArrays.add(_this.x1Tensor, _this.x1Tensor.shape.length === 1 ? dx1.as1D() : dx1);\n            }\n            if (graph_util.shouldBackProp(_this.x2Tensor)) {\n                var dx2 = math.matMul(x1, dy, math_1.MatrixOrientation.TRANSPOSED, math_1.MatrixOrientation.REGULAR);\n                gradientArrays.add(_this.x2Tensor, _this.x2Tensor.shape.length === 1 ? dx2.as1D() : dx2);\n            }\n        });\n    };\n    return MatMul;\n}(op_1.Operation));\nexports.MatMul = MatMul;\n//# sourceMappingURL=matmul.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9tYXRtdWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9tYXRtdWwuanM/ODVlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1hdGhfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL21hdGhcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBNYXRNdWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXRNdWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF0TXVsKHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYXRNdWwucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpZiAoeDEuc2hhcGUubGVuZ3RoID09PSAyICYmIHgyLnNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChtYXRoLm1hdE11bCh4MSwgeDIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4MS5zaGFwZS5sZW5ndGggPT09IDIgJiYgeDIuc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKG1hdGgubWF0cml4VGltZXNWZWN0b3IoeDEsIHgyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeDEuc2hhcGUubGVuZ3RoID09PSAxICYmIHgyLnNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwga2VlcChtYXRoLnZlY3RvclRpbWVzTWF0cml4KHgxLCB4MikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRNdWwucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIGlmICh4MS5zaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHgxID0geDEucmVzaGFwZShbMSwgeDEuc2l6ZV0pO1xuICAgICAgICAgICAgZHkgPSBkeS5yZXNoYXBlKFsxLCBkeS5zaXplXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHgyLnNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgeDIgPSB4Mi5yZXNoYXBlKFt4Mi5zaXplLCAxXSk7XG4gICAgICAgICAgICBkeSA9IGR5LnJlc2hhcGUoW2R5LnNpemUsIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngxVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIHZhciBkeDEgPSBtYXRoLm1hdE11bChkeSwgeDIsIG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSLCBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uVFJBTlNQT1NFRCk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBfdGhpcy54MVRlbnNvci5zaGFwZS5sZW5ndGggPT09IDEgPyBkeDEuYXMxRCgpIDogZHgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngyVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIHZhciBkeDIgPSBtYXRoLm1hdE11bCh4MSwgZHksIG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5UUkFOU1BPU0VELCBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUik7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBfdGhpcy54MlRlbnNvci5zaGFwZS5sZW5ndGggPT09IDEgPyBkeDIuYXMxRCgpIDogZHgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWF0TXVsO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5NYXRNdWwgPSBNYXRNdWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRtdWwuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/matmul.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/max_pool.js":
/*!***************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/max_pool.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar conv_util = __webpack_require__(/*! ../../math/conv_util */ \"./node_modules/deeplearn/dist/src/math/conv_util.js\");\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar MaxPool = (function (_super) {\n    __extends(MaxPool, _super);\n    function MaxPool(xTensor, yTensor, fieldSize, stride, pad) {\n        if (stride === void 0) { stride = 1; }\n        var _this = _super.call(this) || this;\n        _this.xTensor = xTensor;\n        _this.yTensor = yTensor;\n        _this.fieldSize = fieldSize;\n        _this.stride = stride;\n        if (pad != null) {\n            _this.pad = pad;\n        }\n        else {\n            _this.pad = conv_util.computeDefaultPad(xTensor.shape, _this.fieldSize, _this.stride);\n        }\n        util.assert(util.isInt(_this.pad), \"The zero padding (\" + _this.pad + \") must be an integer. Change the \" +\n            \"stride and/or zero pad parameters\");\n        return _this;\n    }\n    MaxPool.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var x = inferenceArrays.get(this.xTensor);\n        math.scope(function (keep) {\n            inferenceArrays.set(_this.yTensor, keep(math.maxPool(x, _this.fieldSize, _this.stride, _this.pad)));\n        });\n    };\n    MaxPool.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        var _this = this;\n        var x = inferenceArrays.get(this.xTensor);\n        var dy = gradientArrays.get(this.yTensor);\n        math.scope(function () {\n            gradientArrays.add(_this.xTensor, math.maxPoolBackprop(dy, x, _this.fieldSize, _this.stride, _this.pad));\n        });\n    };\n    return MaxPool;\n}(op_1.Operation));\nexports.MaxPool = MaxPool;\n//# sourceMappingURL=max_pool.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9tYXhfcG9vbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL21heF9wb29sLmpzPzBjNzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb252X3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9jb252X3V0aWxcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBNYXhQb29sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF4UG9vbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXhQb29sKHhUZW5zb3IsIHlUZW5zb3IsIGZpZWxkU2l6ZSwgc3RyaWRlLCBwYWQpIHtcbiAgICAgICAgaWYgKHN0cmlkZSA9PT0gdm9pZCAwKSB7IHN0cmlkZSA9IDE7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueFRlbnNvciA9IHhUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICBfdGhpcy5maWVsZFNpemUgPSBmaWVsZFNpemU7XG4gICAgICAgIF90aGlzLnN0cmlkZSA9IHN0cmlkZTtcbiAgICAgICAgaWYgKHBhZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpcy5wYWQgPSBwYWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5wYWQgPSBjb252X3V0aWwuY29tcHV0ZURlZmF1bHRQYWQoeFRlbnNvci5zaGFwZSwgX3RoaXMuZmllbGRTaXplLCBfdGhpcy5zdHJpZGUpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQoX3RoaXMucGFkKSwgXCJUaGUgemVybyBwYWRkaW5nIChcIiArIF90aGlzLnBhZCArIFwiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSB0aGUgXCIgK1xuICAgICAgICAgICAgXCJzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWF4UG9vbC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5tYXhQb29sKHgsIF90aGlzLmZpZWxkU2l6ZSwgX3RoaXMuc3RyaWRlLCBfdGhpcy5wYWQpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF4UG9vbC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnhUZW5zb3IsIG1hdGgubWF4UG9vbEJhY2twcm9wKGR5LCB4LCBfdGhpcy5maWVsZFNpemUsIF90aGlzLnN0cmlkZSwgX3RoaXMucGFkKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1heFBvb2w7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLk1heFBvb2wgPSBNYXhQb29sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF4X3Bvb2wuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/max_pool.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/multiply.js":
/*!***************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/multiply.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar graph_util = __webpack_require__(/*! ../graph_util */ \"./node_modules/deeplearn/dist/src/graph/graph_util.js\");\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar Multiply = (function (_super) {\n    __extends(Multiply, _super);\n    function Multiply(x1Tensor, x2Tensor, yTensor) {\n        var _this = _super.call(this) || this;\n        _this.x1Tensor = x1Tensor;\n        _this.x2Tensor = x2Tensor;\n        _this.yTensor = yTensor;\n        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||\n            util.sizeFromShape(x2Tensor.shape) === 1 ||\n            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +\n            'the same shape');\n        return _this;\n    }\n    Multiply.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var t1 = inferenceArrays.get(this.x1Tensor);\n        var t2 = inferenceArrays.get(this.x2Tensor);\n        math.scope(function (keep) {\n            var result;\n            if (util.isScalarShape(t1.shape)) {\n                result = math.scalarTimesArray(t1, t2);\n            }\n            else if (util.isScalarShape(t2.shape)) {\n                result = math.scalarTimesArray(t2, t1);\n            }\n            else {\n                result = math.elementWiseMul(t1, t2);\n            }\n            inferenceArrays.set(_this.yTensor, keep(result));\n        });\n    };\n    Multiply.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        var _this = this;\n        var x1 = inferenceArrays.get(this.x1Tensor);\n        var x2 = inferenceArrays.get(this.x2Tensor);\n        var dy = gradientArrays.get(this.yTensor);\n        math.scope(function () {\n            if (graph_util.shouldBackProp(_this.x1Tensor)) {\n                if (util.isScalarShape(_this.x1Tensor.shape)) {\n                    var mul = math.elementWiseMul(dy, x2);\n                    gradientArrays.add(_this.x1Tensor, math.sum(mul));\n                }\n                else if (util.isScalarShape(x2.shape)) {\n                    gradientArrays.add(_this.x1Tensor, math.scalarTimesArray(x2, dy));\n                }\n                else {\n                    gradientArrays.add(_this.x1Tensor, math.elementWiseMul(x2, dy));\n                }\n            }\n            if (graph_util.shouldBackProp(_this.x2Tensor)) {\n                if (util.isScalarShape(_this.x2Tensor.shape)) {\n                    var mul = math.elementWiseMul(dy, x1);\n                    gradientArrays.add(_this.x2Tensor, math.sum(mul));\n                }\n                else if (util.isScalarShape(x1.shape)) {\n                    gradientArrays.add(_this.x2Tensor, math.scalarTimesArray(x1, dy));\n                }\n                else {\n                    gradientArrays.add(_this.x2Tensor, math.elementWiseMul(x1, dy));\n                }\n            }\n        });\n    };\n    return Multiply;\n}(op_1.Operation));\nexports.Multiply = Multiply;\n//# sourceMappingURL=multiply.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9tdWx0aXBseS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL211bHRpcGx5LmpzPzA1ZTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBNdWx0aXBseSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE11bHRpcGx5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE11bHRpcGx5KHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHgxVGVuc29yLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHgyVGVuc29yLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh4MVRlbnNvci5zaGFwZSwgeDJUZW5zb3Iuc2hhcGUpLCAnT25lIG9mIHQxIG9yIHQyIG11c3QgYmUgYSBzY2FsYXIsIG9yIHQxIGFuZCB0MiBtdXN0IGhhdmUgJyArXG4gICAgICAgICAgICAndGhlIHNhbWUgc2hhcGUnKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNdWx0aXBseS5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB0MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHQxLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguc2NhbGFyVGltZXNBcnJheSh0MSwgdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHQyLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguc2NhbGFyVGltZXNBcnJheSh0MiwgdDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5lbGVtZW50V2lzZU11bCh0MSwgdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKHJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE11bHRpcGx5LnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngxVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoX3RoaXMueDFUZW5zb3Iuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtdWwgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKGR5LCB4Mik7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5zdW0obXVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh4Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLnNjYWxhclRpbWVzQXJyYXkoeDIsIGR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIG1hdGguZWxlbWVudFdpc2VNdWwoeDIsIGR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDJUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZShfdGhpcy54MlRlbnNvci5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG11bCA9IG1hdGguZWxlbWVudFdpc2VNdWwoZHksIHgxKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBtYXRoLnN1bShtdWwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHgxLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDJUZW5zb3IsIG1hdGguc2NhbGFyVGltZXNBcnJheSh4MSwgZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgbWF0aC5lbGVtZW50V2lzZU11bCh4MSwgZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpcGx5O1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5NdWx0aXBseSA9IE11bHRpcGx5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGlwbHkuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/multiply.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/op.js":
/*!*********************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/op.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Operation = (function () {\n    function Operation() {\n    }\n    Operation.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) { };\n    Operation.prototype.dispose = function () { };\n    return Operation;\n}());\nexports.Operation = Operation;\n//# sourceMappingURL=op.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9vcC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL29wLmpzP2U4M2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgT3BlcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcGVyYXRpb24oKSB7XG4gICAgfVxuICAgIE9wZXJhdGlvbi5wcm90b3R5cGUuZGlzcG9zZVRyYW5zaWVudEFycmF5cyA9IGZ1bmN0aW9uIChpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7IH07XG4gICAgT3BlcmF0aW9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBPcGVyYXRpb247XG59KCkpO1xuZXhwb3J0cy5PcGVyYXRpb24gPSBPcGVyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/op.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/reduce_sum.js":
/*!*****************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/reduce_sum.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ../../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar graph_util = __webpack_require__(/*! ../graph_util */ \"./node_modules/deeplearn/dist/src/graph/graph_util.js\");\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar ReduceSum = (function (_super) {\n    __extends(ReduceSum, _super);\n    function ReduceSum(x, outTensor) {\n        var _this = _super.call(this) || this;\n        _this.x = x;\n        _this.outTensor = outTensor;\n        util.assertShapesMatch(outTensor.shape, []);\n        return _this;\n    }\n    ReduceSum.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var x = inferenceArrays.get(this.x);\n        math.scope(function (keep) {\n            inferenceArrays.set(_this.outTensor, keep(math.sum(x)));\n        });\n    };\n    ReduceSum.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        var _this = this;\n        if (!graph_util.shouldBackProp(this.x)) {\n            return;\n        }\n        math.scope(function () {\n            var dy = gradientArrays.get(_this.outTensor);\n            if (_this.ones == null) {\n                var xArray = inferenceArrays.get(_this.x);\n                _this.ones = ndarray_1.NDArray.zerosLike(xArray);\n                _this.ones.fill(1);\n            }\n            gradientArrays.add(_this.x, math.scalarTimesArray(dy, _this.ones));\n        });\n    };\n    return ReduceSum;\n}(op_1.Operation));\nexports.ReduceSum = ReduceSum;\n//# sourceMappingURL=reduce_sum.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9yZWR1Y2Vfc3VtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvcmVkdWNlX3N1bS5qcz8yMTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBSZWR1Y2VTdW0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWR1Y2VTdW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVkdWNlU3VtKHgsIG91dFRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54ID0geDtcbiAgICAgICAgX3RoaXMub3V0VGVuc29yID0gb3V0VGVuc29yO1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKG91dFRlbnNvci5zaGFwZSwgW10pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlZHVjZVN1bS5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngpO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLm91dFRlbnNvciwga2VlcChtYXRoLnN1bSh4KSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlZHVjZVN1bS5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AodGhpcy54KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KF90aGlzLm91dFRlbnNvcik7XG4gICAgICAgICAgICBpZiAoX3RoaXMub25lcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhBcnJheSA9IGluZmVyZW5jZUFycmF5cy5nZXQoX3RoaXMueCk7XG4gICAgICAgICAgICAgICAgX3RoaXMub25lcyA9IG5kYXJyYXlfMS5OREFycmF5Lnplcm9zTGlrZSh4QXJyYXkpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9uZXMuZmlsbCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54LCBtYXRoLnNjYWxhclRpbWVzQXJyYXkoZHksIF90aGlzLm9uZXMpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVkdWNlU3VtO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5SZWR1Y2VTdW0gPSBSZWR1Y2VTdW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1Y2Vfc3VtLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/reduce_sum.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/reshape.js":
/*!**************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/reshape.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar Reshape = (function (_super) {\n    __extends(Reshape, _super);\n    function Reshape(xTensor, yTensor) {\n        var _this = _super.call(this) || this;\n        _this.xTensor = xTensor;\n        _this.yTensor = yTensor;\n        var xSize = util.sizeFromShape(xTensor.shape);\n        var ySize = util.sizeFromShape(yTensor.shape);\n        util.assert(xSize === ySize, \"The input size (\" + xSize + \") and output size (\" + ySize + \") must match\");\n        return _this;\n    }\n    Reshape.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var x = inferenceArrays.get(this.xTensor);\n        math.scope(function (keep) {\n            inferenceArrays.set(_this.yTensor, keep(x.reshape(_this.yTensor.shape)));\n        });\n    };\n    Reshape.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        var _this = this;\n        var dy = gradientArrays.get(this.yTensor);\n        math.scope(function () {\n            gradientArrays.add(_this.xTensor, dy.reshape(_this.xTensor.shape));\n        });\n    };\n    return Reshape;\n}(op_1.Operation));\nexports.Reshape = Reshape;\n//# sourceMappingURL=reshape.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9yZXNoYXBlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvcmVzaGFwZS5qcz83NDgyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBSZXNoYXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzaGFwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXNoYXBlKHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueFRlbnNvciA9IHhUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICB2YXIgeFNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoeFRlbnNvci5zaGFwZSk7XG4gICAgICAgIHZhciB5U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZSh5VGVuc29yLnNoYXBlKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoeFNpemUgPT09IHlTaXplLCBcIlRoZSBpbnB1dCBzaXplIChcIiArIHhTaXplICsgXCIpIGFuZCBvdXRwdXQgc2l6ZSAoXCIgKyB5U2l6ZSArIFwiKSBtdXN0IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlc2hhcGUucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBrZWVwKHgucmVzaGFwZShfdGhpcy55VGVuc29yLnNoYXBlKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlc2hhcGUucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnhUZW5zb3IsIGR5LnJlc2hhcGUoX3RoaXMueFRlbnNvci5zaGFwZSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNoYXBlO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5SZXNoYXBlID0gUmVzaGFwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc2hhcGUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/reshape.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/softmax.js":
/*!**************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/softmax.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ../../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar graph_1 = __webpack_require__(/*! ../graph */ \"./node_modules/deeplearn/dist/src/graph/graph.js\");\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar Softmax = (function (_super) {\n    __extends(Softmax, _super);\n    function Softmax(logitsTensor, output) {\n        var _this = _super.call(this) || this;\n        _this.logitsTensor = logitsTensor;\n        _this.output = output;\n        return _this;\n    }\n    Softmax.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var logits = inferenceArrays.get(this.logitsTensor);\n        return math.scope(function (keep) {\n            inferenceArrays.set(_this.output, keep(math.softmax(logits)));\n        });\n    };\n    Softmax.prototype.backProp = function () {\n        throw Error('Softmax backprop is not yet implemented');\n    };\n    return Softmax;\n}(op_1.Operation));\nexports.Softmax = Softmax;\nvar SoftmaxCrossEntropyCost = (function (_super) {\n    __extends(SoftmaxCrossEntropyCost, _super);\n    function SoftmaxCrossEntropyCost(logitsTensor, labelTensor, yTensor) {\n        var _this = _super.call(this) || this;\n        _this.logitsTensor = logitsTensor;\n        _this.labelTensor = labelTensor;\n        _this.yTensor = yTensor;\n        _this.epsilon = ndarray_1.Scalar.new(1e-5);\n        _this.softmaxTensor = new graph_1.Tensor(logitsTensor.shape);\n        return _this;\n    }\n    SoftmaxCrossEntropyCost.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var logits = inferenceArrays.get(this.logitsTensor);\n        var label = inferenceArrays.get(this.labelTensor);\n        math.scope(function (keep) {\n            var softmaxResult = math.softmax(logits);\n            inferenceArrays.set(_this.softmaxTensor, keep(softmaxResult));\n            inferenceArrays.set(_this.yTensor, keep(crossEntropyCost(math, softmaxResult, label, _this.epsilon)));\n        });\n    };\n    SoftmaxCrossEntropyCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        var _this = this;\n        var softmax = inferenceArrays.get(this.softmaxTensor);\n        var label = inferenceArrays.get(this.labelTensor);\n        math.scope(function () {\n            gradientArrays.add(_this.logitsTensor, math.sub(softmax, label));\n        });\n    };\n    SoftmaxCrossEntropyCost.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) {\n        inferenceArrays.disposeArray(this.softmaxTensor);\n    };\n    SoftmaxCrossEntropyCost.prototype.dispose = function () {\n        this.epsilon.dispose();\n    };\n    return SoftmaxCrossEntropyCost;\n}(op_1.Operation));\nexports.SoftmaxCrossEntropyCost = SoftmaxCrossEntropyCost;\nfunction crossEntropyCost(math, y, target, epsilon) {\n    util.assert(y.size === target.size, 'The output and target must be the same size');\n    return math.scope(function () {\n        var yPlusEps = math.scalarPlusArray(epsilon, y);\n        var logOutput = math.log(yPlusEps);\n        var tarLogOutput = math.elementWiseMul(target, logOutput);\n        var costVector = math.neg(tarLogOutput);\n        return math.sum(costVector);\n    });\n}\nexports.crossEntropyCost = crossEntropyCost;\n//# sourceMappingURL=softmax.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9zb2Z0bWF4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHMvc29mdG1heC5qcz9iOWU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3JhcGhfMSA9IHJlcXVpcmUoXCIuLi9ncmFwaFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgU29mdG1heCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNvZnRtYXgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU29mdG1heChsb2dpdHNUZW5zb3IsIG91dHB1dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sb2dpdHNUZW5zb3IgPSBsb2dpdHNUZW5zb3I7XG4gICAgICAgIF90aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTb2Z0bWF4LnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxvZ2l0cyA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5sb2dpdHNUZW5zb3IpO1xuICAgICAgICByZXR1cm4gbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy5vdXRwdXQsIGtlZXAobWF0aC5zb2Z0bWF4KGxvZ2l0cykpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTb2Z0bWF4LnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1NvZnRtYXggYmFja3Byb3AgaXMgbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIFNvZnRtYXg7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLlNvZnRtYXggPSBTb2Z0bWF4O1xudmFyIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU29mdG1heENyb3NzRW50cm9weUNvc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU29mdG1heENyb3NzRW50cm9weUNvc3QobG9naXRzVGVuc29yLCBsYWJlbFRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sb2dpdHNUZW5zb3IgPSBsb2dpdHNUZW5zb3I7XG4gICAgICAgIF90aGlzLmxhYmVsVGVuc29yID0gbGFiZWxUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICBfdGhpcy5lcHNpbG9uID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMWUtNSk7XG4gICAgICAgIF90aGlzLnNvZnRtYXhUZW5zb3IgPSBuZXcgZ3JhcGhfMS5UZW5zb3IobG9naXRzVGVuc29yLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsb2dpdHMgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMubG9naXRzVGVuc29yKTtcbiAgICAgICAgdmFyIGxhYmVsID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmxhYmVsVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIHNvZnRtYXhSZXN1bHQgPSBtYXRoLnNvZnRtYXgobG9naXRzKTtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMuc29mdG1heFRlbnNvciwga2VlcChzb2Z0bWF4UmVzdWx0KSk7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGtlZXAoY3Jvc3NFbnRyb3B5Q29zdChtYXRoLCBzb2Z0bWF4UmVzdWx0LCBsYWJlbCwgX3RoaXMuZXBzaWxvbikpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc29mdG1heCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5zb2Z0bWF4VGVuc29yKTtcbiAgICAgICAgdmFyIGxhYmVsID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmxhYmVsVGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMubG9naXRzVGVuc29yLCBtYXRoLnN1Yihzb2Z0bWF4LCBsYWJlbCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0LnByb3RvdHlwZS5kaXNwb3NlVHJhbnNpZW50QXJyYXlzID0gZnVuY3Rpb24gKGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgaW5mZXJlbmNlQXJyYXlzLmRpc3Bvc2VBcnJheSh0aGlzLnNvZnRtYXhUZW5zb3IpO1xuICAgIH07XG4gICAgU29mdG1heENyb3NzRW50cm9weUNvc3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXBzaWxvbi5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU29mdG1heENyb3NzRW50cm9weUNvc3Q7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLlNvZnRtYXhDcm9zc0VudHJvcHlDb3N0ID0gU29mdG1heENyb3NzRW50cm9weUNvc3Q7XG5mdW5jdGlvbiBjcm9zc0VudHJvcHlDb3N0KG1hdGgsIHksIHRhcmdldCwgZXBzaWxvbikge1xuICAgIHV0aWwuYXNzZXJ0KHkuc2l6ZSA9PT0gdGFyZ2V0LnNpemUsICdUaGUgb3V0cHV0IGFuZCB0YXJnZXQgbXVzdCBiZSB0aGUgc2FtZSBzaXplJyk7XG4gICAgcmV0dXJuIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeVBsdXNFcHMgPSBtYXRoLnNjYWxhclBsdXNBcnJheShlcHNpbG9uLCB5KTtcbiAgICAgICAgdmFyIGxvZ091dHB1dCA9IG1hdGgubG9nKHlQbHVzRXBzKTtcbiAgICAgICAgdmFyIHRhckxvZ091dHB1dCA9IG1hdGguZWxlbWVudFdpc2VNdWwodGFyZ2V0LCBsb2dPdXRwdXQpO1xuICAgICAgICB2YXIgY29zdFZlY3RvciA9IG1hdGgubmVnKHRhckxvZ091dHB1dCk7XG4gICAgICAgIHJldHVybiBtYXRoLnN1bShjb3N0VmVjdG9yKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3Jvc3NFbnRyb3B5Q29zdCA9IGNyb3NzRW50cm9weUNvc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb2Z0bWF4LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/softmax.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/ops/subtract.js":
/*!***************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/ops/subtract.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ../../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar graph_util = __webpack_require__(/*! ../graph_util */ \"./node_modules/deeplearn/dist/src/graph/graph_util.js\");\nvar op_1 = __webpack_require__(/*! ./op */ \"./node_modules/deeplearn/dist/src/graph/ops/op.js\");\nvar Subtract = (function (_super) {\n    __extends(Subtract, _super);\n    function Subtract(t1, t2, outTensor) {\n        var _this = _super.call(this) || this;\n        _this.t1 = t1;\n        _this.t2 = t2;\n        _this.outTensor = outTensor;\n        util.assert(util.sizeFromShape(t1.shape) === 1 ||\n            util.sizeFromShape(t2.shape) === 1 ||\n            util.arraysEqual(t1.shape, t2.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +\n            'the same shape');\n        return _this;\n    }\n    Subtract.prototype.feedForward = function (math, inferenceArrays) {\n        var _this = this;\n        var t1 = inferenceArrays.get(this.t1);\n        var t2 = inferenceArrays.get(this.t2);\n        math.scope(function (keep) {\n            var result;\n            if (util.isScalarShape(t1.shape)) {\n                result = math.scalarMinusArray(t1, t2);\n            }\n            else if (util.isScalarShape(t2.shape)) {\n                result = math.arrayMinusScalar(t1, t2);\n            }\n            else {\n                result = math.sub(t1, t2);\n            }\n            inferenceArrays.set(_this.outTensor, keep(result));\n        });\n    };\n    Subtract.prototype.backProp = function (math, inferenceArrays, gradientArrays) {\n        var _this = this;\n        var dy = gradientArrays.get(this.outTensor);\n        math.scope(function () {\n            if (graph_util.shouldBackProp(_this.t1)) {\n                if (util.isScalarShape(_this.t1.shape)) {\n                    var sum = math.sum(dy);\n                    if (_this.dySizeScalar == null) {\n                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);\n                    }\n                    gradientArrays.add(_this.t1, math.divide(sum, _this.dySizeScalar));\n                }\n                else {\n                    gradientArrays.add(_this.t1, math.clone(dy));\n                }\n            }\n            if (graph_util.shouldBackProp(_this.t2)) {\n                if (util.isScalarShape(_this.t2.shape)) {\n                    var sum = math.sum(dy);\n                    var negSum = math.neg(sum);\n                    if (_this.dySizeScalar == null) {\n                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);\n                    }\n                    gradientArrays.add(_this.t2, math.divide(negSum, _this.dySizeScalar));\n                }\n                else {\n                    gradientArrays.add(_this.t2, math.neg(dy));\n                }\n            }\n        });\n    };\n    Subtract.prototype.dispose = function () {\n        if (this.dySizeScalar != null) {\n            this.dySizeScalar.dispose();\n        }\n    };\n    return Subtract;\n}(op_1.Operation));\nexports.Subtract = Subtract;\n//# sourceMappingURL=subtract.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wcy9zdWJ0cmFjdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3BzL3N1YnRyYWN0LmpzPzMxMmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIFN1YnRyYWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3VidHJhY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3VidHJhY3QodDEsIHQyLCBvdXRUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudDEgPSB0MTtcbiAgICAgICAgX3RoaXMudDIgPSB0MjtcbiAgICAgICAgX3RoaXMub3V0VGVuc29yID0gb3V0VGVuc29yO1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLnNpemVGcm9tU2hhcGUodDEuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodDIuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHQxLnNoYXBlLCB0Mi5zaGFwZSksICdPbmUgb2YgdDEgb3IgdDIgbXVzdCBiZSBhIHNjYWxhciwgb3IgdDEgYW5kIHQyIG11c3QgaGF2ZSAnICtcbiAgICAgICAgICAgICd0aGUgc2FtZSBzaGFwZScpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN1YnRyYWN0LnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHQxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnQxKTtcbiAgICAgICAgdmFyIHQyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnQyKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUodDEuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5zY2FsYXJNaW51c0FycmF5KHQxLCB0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUodDIuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5hcnJheU1pbnVzU2NhbGFyKHQxLCB0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnN1Yih0MSwgdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy5vdXRUZW5zb3IsIGtlZXAocmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3VidHJhY3QucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMub3V0VGVuc29yKTtcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy50MSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKF90aGlzLnQxLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VtID0gbWF0aC5zdW0oZHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZHlTaXplU2NhbGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmR5U2l6ZVNjYWxhciA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KGR5LnNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy50MSwgbWF0aC5kaXZpZGUoc3VtLCBfdGhpcy5keVNpemVTY2FsYXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy50MSwgbWF0aC5jbG9uZShkeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLnQyKSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoX3RoaXMudDIuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdW0gPSBtYXRoLnN1bShkeSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZWdTdW0gPSBtYXRoLm5lZyhzdW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZHlTaXplU2NhbGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmR5U2l6ZVNjYWxhciA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KGR5LnNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy50MiwgbWF0aC5kaXZpZGUobmVnU3VtLCBfdGhpcy5keVNpemVTY2FsYXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy50MiwgbWF0aC5uZWcoZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3VidHJhY3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmR5U2l6ZVNjYWxhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmR5U2l6ZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdWJ0cmFjdDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuU3VidHJhY3QgPSBTdWJ0cmFjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnRyYWN0LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/ops/subtract.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/optimizers/adadelta_optimizer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/optimizers/adadelta_optimizer.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ../../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar tensor_array_map_1 = __webpack_require__(/*! ../tensor_array_map */ \"./node_modules/deeplearn/dist/src/graph/tensor_array_map.js\");\nvar optimizer_1 = __webpack_require__(/*! ./optimizer */ \"./node_modules/deeplearn/dist/src/graph/optimizers/optimizer.js\");\nvar AdadeltaOptimizer = (function (_super) {\n    __extends(AdadeltaOptimizer, _super);\n    function AdadeltaOptimizer(learningRate, gamma, specifiedVariableList) {\n        var _this = _super.call(this, learningRate, specifiedVariableList) || this;\n        _this.learningRate = learningRate;\n        _this.gamma = gamma;\n        _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();\n        _this.accumulatedUpdates = new tensor_array_map_1.TensorArrayMap();\n        _this.eps = ndarray_1.Scalar.new(1e-6);\n        _this.g = ndarray_1.Scalar.new(_this.gamma);\n        return _this;\n    }\n    AdadeltaOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {\n        var _this = this;\n        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);\n        if (this.accumulatedSquaredGradients.size() === 0) {\n            this.variableNodes.forEach(function (node) {\n                _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));\n                _this.accumulatedUpdates.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));\n            });\n        }\n    };\n    AdadeltaOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {\n        var _this = this;\n        math.scope(function (keep) {\n            _this.variableNodes.forEach(function (node) {\n                var oldVariable = activationArrayMap.get(node.output);\n                var gradient = _this.variableGradients.get(node.output);\n                var oldCache = _this.accumulatedSquaredGradients.get(node.output);\n                var oldUpdates = _this.accumulatedUpdates.get(node.output);\n                var gradientSquare = math.multiply(gradient, gradient);\n                var cache = math.scaledArrayAdd(_this.g, oldCache, math.sub(_this.one, _this.g), gradientSquare);\n                var updates = math.multiply(math.divide(math.sqrt(math.add(oldUpdates, _this.eps)), math.sqrt(math.add(oldCache, _this.eps))), gradient);\n                var variable = math.scaledArrayAdd(_this.c, updates, _this.one, oldVariable);\n                var updateSquare = math.multiply(updates, updates);\n                var newUpdates = math.scaledArrayAdd(_this.g, oldUpdates, math.sub(_this.one, _this.g), updateSquare);\n                _this.accumulatedSquaredGradients.set(node.output, keep(cache));\n                _this.accumulatedUpdates.set(node.output, keep(newUpdates));\n                activationArrayMap.set(node.output, keep(variable));\n                node.data = variable;\n                oldVariable.dispose();\n                oldCache.dispose();\n                oldUpdates.dispose();\n            });\n        });\n        this.variableGradients.dispose();\n        this.variableGradients = new tensor_array_map_1.TensorArrayMap();\n    };\n    AdadeltaOptimizer.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this.eps.dispose();\n        this.g.dispose();\n        this.accumulatedSquaredGradients.dispose();\n        this.accumulatedUpdates.dispose();\n    };\n    return AdadeltaOptimizer;\n}(optimizer_1.Optimizer));\nexports.AdadeltaOptimizer = AdadeltaOptimizer;\n//# sourceMappingURL=adadelta_optimizer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvYWRhZGVsdGFfb3B0aW1pemVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHRpbWl6ZXJzL2FkYWRlbHRhX29wdGltaXplci5qcz9lNTg0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplclwiKTtcbnZhciBBZGFkZWx0YU9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkYWRlbHRhT3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFkYWRlbHRhT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgZ2FtbWEsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5nYW1tYSA9IGdhbW1hO1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGVkVXBkYXRlcyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgX3RoaXMuZXBzID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMWUtNik7XG4gICAgICAgIF90aGlzLmcgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhfdGhpcy5nYW1tYSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQWRhZGVsdGFPcHRpbWl6ZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYmVmb3JlQmF0Y2guY2FsbCh0aGlzLCBtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCk7XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLnNldChub2RlLm91dHB1dCwgbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMuc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFkYWRlbHRhT3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYXJpYWJsZSA9IGFjdGl2YXRpb25BcnJheU1hcC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZENhY2hlID0gX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFVwZGF0ZXMgPSBfdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnRTcXVhcmUgPSBtYXRoLm11bHRpcGx5KGdyYWRpZW50LCBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5nLCBvbGRDYWNoZSwgbWF0aC5zdWIoX3RoaXMub25lLCBfdGhpcy5nKSwgZ3JhZGllbnRTcXVhcmUpO1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVzID0gbWF0aC5tdWx0aXBseShtYXRoLmRpdmlkZShtYXRoLnNxcnQobWF0aC5hZGQob2xkVXBkYXRlcywgX3RoaXMuZXBzKSksIG1hdGguc3FydChtYXRoLmFkZChvbGRDYWNoZSwgX3RoaXMuZXBzKSkpLCBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5jLCB1cGRhdGVzLCBfdGhpcy5vbmUsIG9sZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlU3F1YXJlID0gbWF0aC5tdWx0aXBseSh1cGRhdGVzLCB1cGRhdGVzKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VXBkYXRlcyA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuZywgb2xkVXBkYXRlcywgbWF0aC5zdWIoX3RoaXMub25lLCBfdGhpcy5nKSwgdXBkYXRlU3F1YXJlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuc2V0KG5vZGUub3V0cHV0LCBrZWVwKGNhY2hlKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRVcGRhdGVzLnNldChub2RlLm91dHB1dCwga2VlcChuZXdVcGRhdGVzKSk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvbkFycmF5TWFwLnNldChub2RlLm91dHB1dCwga2VlcCh2YXJpYWJsZSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIG9sZFZhcmlhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRDYWNoZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgb2xkVXBkYXRlcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgIH07XG4gICAgQWRhZGVsdGFPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmVwcy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEFkYWRlbHRhT3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuQWRhZGVsdGFPcHRpbWl6ZXIgPSBBZGFkZWx0YU9wdGltaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYWRlbHRhX29wdGltaXplci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/optimizers/adadelta_optimizer.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/optimizers/adagrad_optimizer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/optimizers/adagrad_optimizer.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ../../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar tensor_array_map_1 = __webpack_require__(/*! ../tensor_array_map */ \"./node_modules/deeplearn/dist/src/graph/tensor_array_map.js\");\nvar optimizer_1 = __webpack_require__(/*! ./optimizer */ \"./node_modules/deeplearn/dist/src/graph/optimizers/optimizer.js\");\nvar AdagradOptimizer = (function (_super) {\n    __extends(AdagradOptimizer, _super);\n    function AdagradOptimizer(learningRate, specifiedVariableList) {\n        var _this = _super.call(this, learningRate, specifiedVariableList) || this;\n        _this.learningRate = learningRate;\n        _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();\n        _this.eps = ndarray_1.Scalar.new(1e-6);\n        return _this;\n    }\n    AdagradOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {\n        var _this = this;\n        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);\n        if (this.accumulatedSquaredGradients.size() === 0) {\n            this.variableNodes.forEach(function (node) {\n                _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));\n            });\n        }\n    };\n    AdagradOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {\n        var _this = this;\n        math.scope(function (keep) {\n            _this.variableNodes.forEach(function (node) {\n                var oldVariable = activationArrayMap.get(node.output);\n                var gradient = _this.variableGradients.get(node.output);\n                var oldCache = _this.accumulatedSquaredGradients.get(node.output);\n                var gradientSquare = math.multiply(gradient, gradient);\n                var cache = math.add(oldCache, gradientSquare);\n                var variable = math.scaledArrayAdd(_this.c, math.divide(gradient, math.add(math.sqrt(cache), _this.eps)), _this.one, oldVariable);\n                _this.accumulatedSquaredGradients.set(node.output, keep(cache));\n                activationArrayMap.set(node.output, keep(variable));\n                node.data = variable;\n                oldVariable.dispose();\n                oldCache.dispose();\n            });\n        });\n        this.variableGradients.dispose();\n        this.variableGradients = new tensor_array_map_1.TensorArrayMap();\n    };\n    AdagradOptimizer.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this.eps.dispose();\n        this.accumulatedSquaredGradients.dispose();\n    };\n    return AdagradOptimizer;\n}(optimizer_1.Optimizer));\nexports.AdagradOptimizer = AdagradOptimizer;\n//# sourceMappingURL=adagrad_optimizer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvYWRhZ3JhZF9vcHRpbWl6ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvYWRhZ3JhZF9vcHRpbWl6ZXIuanM/MjI4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJcIik7XG52YXIgQWRhZ3JhZE9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkYWdyYWRPcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWRhZ3JhZE9wdGltaXplcihsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLmVwcyA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDFlLTYpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFkYWdyYWRPcHRpbWl6ZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYmVmb3JlQmF0Y2guY2FsbCh0aGlzLCBtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCk7XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLnNldChub2RlLm91dHB1dCwgbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBZGFncmFkT3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYXJpYWJsZSA9IGFjdGl2YXRpb25BcnJheU1hcC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZENhY2hlID0gX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50U3F1YXJlID0gbWF0aC5tdWx0aXBseShncmFkaWVudCwgZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZSA9IG1hdGguYWRkKG9sZENhY2hlLCBncmFkaWVudFNxdWFyZSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5jLCBtYXRoLmRpdmlkZShncmFkaWVudCwgbWF0aC5hZGQobWF0aC5zcXJ0KGNhY2hlKSwgX3RoaXMuZXBzKSksIF90aGlzLm9uZSwgb2xkVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zZXQobm9kZS5vdXRwdXQsIGtlZXAoY2FjaGUpKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBrZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgb2xkVmFyaWFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZENhY2hlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBBZGFncmFkT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lcHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQWRhZ3JhZE9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLkFkYWdyYWRPcHRpbWl6ZXIgPSBBZGFncmFkT3B0aW1pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhZ3JhZF9vcHRpbWl6ZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/optimizers/adagrad_optimizer.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/optimizers/adam_optimizer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/optimizers/adam_optimizer.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ../../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar tensor_array_map_1 = __webpack_require__(/*! ../tensor_array_map */ \"./node_modules/deeplearn/dist/src/graph/tensor_array_map.js\");\nvar optimizer_1 = __webpack_require__(/*! ./optimizer */ \"./node_modules/deeplearn/dist/src/graph/optimizers/optimizer.js\");\nvar AdamOptimizer = (function (_super) {\n    __extends(AdamOptimizer, _super);\n    function AdamOptimizer(learningRate, beta1, beta2, specifiedVariableList) {\n        var _this = _super.call(this, learningRate, specifiedVariableList) || this;\n        _this.learningRate = learningRate;\n        _this.beta1 = beta1;\n        _this.beta2 = beta2;\n        _this.firstMoment = new tensor_array_map_1.TensorArrayMap();\n        _this.secondMoment = new tensor_array_map_1.TensorArrayMap();\n        _this.eps = ndarray_1.Scalar.new(1e-8);\n        _this.b1 = ndarray_1.Scalar.new(_this.beta1);\n        _this.b2 = ndarray_1.Scalar.new(_this.beta2);\n        _this.accB1 = ndarray_1.Scalar.new(_this.beta1);\n        _this.accB2 = ndarray_1.Scalar.new(_this.beta2);\n        return _this;\n    }\n    AdamOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {\n        var _this = this;\n        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);\n        if (this.firstMoment.size() === 0) {\n            this.variableNodes.forEach(function (node) {\n                _this.firstMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));\n            });\n        }\n        if (this.secondMoment.size() === 0) {\n            this.variableNodes.forEach(function (node) {\n                _this.secondMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));\n            });\n        }\n    };\n    AdamOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {\n        var _this = this;\n        math.scope(function (keep) {\n            _this.variableNodes.forEach(function (node) {\n                var oldVariable = activationArrayMap.get(node.output);\n                var gradient = _this.variableGradients.get(node.output);\n                var oldFirstMoment = _this.firstMoment.get(node.output);\n                var oldSecondMoment = _this.secondMoment.get(node.output);\n                var newFirstMoment = math.scaledArrayAdd(_this.b1, oldFirstMoment, math.sub(_this.one, _this.b1), gradient);\n                var gradientSquare = math.multiply(gradient, gradient);\n                var newSecondMoment = math.scaledArrayAdd(_this.b2, oldSecondMoment, math.sub(_this.one, _this.b2), gradientSquare);\n                var biasCorrectedFirstMoment = math.divide(newFirstMoment, math.sub(_this.one, _this.accB1));\n                var biasCorrectedSecondMoment = math.divide(newSecondMoment, math.sub(_this.one, _this.accB2));\n                var variable = math.scaledArrayAdd(_this.c, math.divide(biasCorrectedFirstMoment, math.add(math.sqrt(biasCorrectedSecondMoment), _this.eps)), _this.one, oldVariable);\n                activationArrayMap.set(node.output, keep(variable));\n                node.data = variable;\n                _this.firstMoment.set(node.output, keep(newFirstMoment));\n                _this.secondMoment.set(node.output, keep(newSecondMoment));\n                oldVariable.dispose();\n                gradient.dispose();\n                oldFirstMoment.dispose();\n                oldSecondMoment.dispose();\n            });\n            _this.accB1 = keep(math.multiply(_this.accB1, _this.b1));\n            _this.accB2 = keep(math.multiply(_this.accB2, _this.b2));\n        });\n        this.variableGradients.dispose();\n        this.variableGradients = new tensor_array_map_1.TensorArrayMap();\n    };\n    AdamOptimizer.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this.firstMoment.dispose();\n        this.secondMoment.dispose();\n        this.eps.dispose();\n        this.b1.dispose();\n        this.b2.dispose();\n        this.accB1.dispose();\n        this.accB2.dispose();\n    };\n    return AdamOptimizer;\n}(optimizer_1.Optimizer));\nexports.AdamOptimizer = AdamOptimizer;\n//# sourceMappingURL=adam_optimizer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvYWRhbV9vcHRpbWl6ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvYWRhbV9vcHRpbWl6ZXIuanM/MGQ5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJcIik7XG52YXIgQWRhbU9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkYW1PcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWRhbU9wdGltaXplcihsZWFybmluZ1JhdGUsIGJldGExLCBiZXRhMiwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIF90aGlzLmJldGExID0gYmV0YTE7XG4gICAgICAgIF90aGlzLmJldGEyID0gYmV0YTI7XG4gICAgICAgIF90aGlzLmZpcnN0TW9tZW50ID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5zZWNvbmRNb21lbnQgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLmVwcyA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDFlLTgpO1xuICAgICAgICBfdGhpcy5iMSA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLmJldGExKTtcbiAgICAgICAgX3RoaXMuYjIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhfdGhpcy5iZXRhMik7XG4gICAgICAgIF90aGlzLmFjY0IxID0gbmRhcnJheV8xLlNjYWxhci5uZXcoX3RoaXMuYmV0YTEpO1xuICAgICAgICBfdGhpcy5hY2NCMiA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLmJldGEyKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZGFtT3B0aW1pemVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoLmNhbGwodGhpcywgbWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApO1xuICAgICAgICBpZiAodGhpcy5maXJzdE1vbWVudC5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZmlyc3RNb21lbnQuc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kTW9tZW50LnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWNvbmRNb21lbnQuc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFkYW1PcHRpbWl6ZXIucHJvdG90eXBlLmFmdGVyQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgX3RoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhcmlhYmxlID0gYWN0aXZhdGlvbkFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkRmlyc3RNb21lbnQgPSBfdGhpcy5maXJzdE1vbWVudC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRTZWNvbmRNb21lbnQgPSBfdGhpcy5zZWNvbmRNb21lbnQuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Rmlyc3RNb21lbnQgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmIxLCBvbGRGaXJzdE1vbWVudCwgbWF0aC5zdWIoX3RoaXMub25lLCBfdGhpcy5iMSksIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnRTcXVhcmUgPSBtYXRoLm11bHRpcGx5KGdyYWRpZW50LCBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NlY29uZE1vbWVudCA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuYjIsIG9sZFNlY29uZE1vbWVudCwgbWF0aC5zdWIoX3RoaXMub25lLCBfdGhpcy5iMiksIGdyYWRpZW50U3F1YXJlKTtcbiAgICAgICAgICAgICAgICB2YXIgYmlhc0NvcnJlY3RlZEZpcnN0TW9tZW50ID0gbWF0aC5kaXZpZGUobmV3Rmlyc3RNb21lbnQsIG1hdGguc3ViKF90aGlzLm9uZSwgX3RoaXMuYWNjQjEpKTtcbiAgICAgICAgICAgICAgICB2YXIgYmlhc0NvcnJlY3RlZFNlY29uZE1vbWVudCA9IG1hdGguZGl2aWRlKG5ld1NlY29uZE1vbWVudCwgbWF0aC5zdWIoX3RoaXMub25lLCBfdGhpcy5hY2NCMikpO1xuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuYywgbWF0aC5kaXZpZGUoYmlhc0NvcnJlY3RlZEZpcnN0TW9tZW50LCBtYXRoLmFkZChtYXRoLnNxcnQoYmlhc0NvcnJlY3RlZFNlY29uZE1vbWVudCksIF90aGlzLmVwcykpLCBfdGhpcy5vbmUsIG9sZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBrZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgX3RoaXMuZmlyc3RNb21lbnQuc2V0KG5vZGUub3V0cHV0LCBrZWVwKG5ld0ZpcnN0TW9tZW50KSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2Vjb25kTW9tZW50LnNldChub2RlLm91dHB1dCwga2VlcChuZXdTZWNvbmRNb21lbnQpKTtcbiAgICAgICAgICAgICAgICBvbGRWYXJpYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZEZpcnN0TW9tZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRTZWNvbmRNb21lbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5hY2NCMSA9IGtlZXAobWF0aC5tdWx0aXBseShfdGhpcy5hY2NCMSwgX3RoaXMuYjEpKTtcbiAgICAgICAgICAgIF90aGlzLmFjY0IyID0ga2VlcChtYXRoLm11bHRpcGx5KF90aGlzLmFjY0IyLCBfdGhpcy5iMikpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBBZGFtT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5maXJzdE1vbWVudC5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuc2Vjb25kTW9tZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5lcHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmIxLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5iMi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYWNjQjEuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFjY0IyLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBBZGFtT3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuQWRhbU9wdGltaXplciA9IEFkYW1PcHRpbWl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGFtX29wdGltaXplci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/optimizers/adam_optimizer.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/optimizers/momentum_optimizer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/optimizers/momentum_optimizer.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ../../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar tensor_array_map_1 = __webpack_require__(/*! ../tensor_array_map */ \"./node_modules/deeplearn/dist/src/graph/tensor_array_map.js\");\nvar sgd_optimizer_1 = __webpack_require__(/*! ./sgd_optimizer */ \"./node_modules/deeplearn/dist/src/graph/optimizers/sgd_optimizer.js\");\nvar MomentumOptimizer = (function (_super) {\n    __extends(MomentumOptimizer, _super);\n    function MomentumOptimizer(learningRate, momentum, specifiedVariableList) {\n        var _this = _super.call(this, learningRate, specifiedVariableList) || this;\n        _this.learningRate = learningRate;\n        _this.momentum = momentum;\n        _this.variableVelocities = new tensor_array_map_1.TensorArrayMap();\n        _this.m = ndarray_1.Scalar.new(_this.momentum);\n        return _this;\n    }\n    MomentumOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {\n        var _this = this;\n        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);\n        if (this.variableVelocities.size() === 0) {\n            this.variableNodes.forEach(function (node) {\n                _this.variableVelocities.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));\n            });\n        }\n    };\n    MomentumOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {\n        var _this = this;\n        math.scope(function (keep) {\n            _this.variableNodes.forEach(function (node) {\n                var oldVariable = activationArrayMap.get(node.output);\n                var gradient = _this.variableGradients.get(node.output);\n                var oldVelocity = _this.variableVelocities.get(node.output);\n                var velocity = math.scaledArrayAdd(_this.m, oldVelocity, _this.one, gradient);\n                var variable = math.scaledArrayAdd(_this.c, velocity, _this.one, oldVariable);\n                _this.variableVelocities.set(node.output, keep(velocity));\n                activationArrayMap.set(node.output, keep(variable));\n                node.data = variable;\n                oldVariable.dispose();\n                oldVelocity.dispose();\n            });\n        });\n        this.variableGradients.dispose();\n        this.variableGradients = new tensor_array_map_1.TensorArrayMap();\n    };\n    MomentumOptimizer.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this.m.dispose();\n        this.variableVelocities.dispose();\n    };\n    MomentumOptimizer.prototype.setMomentum = function (momentum) {\n        this.momentum = momentum;\n    };\n    return MomentumOptimizer;\n}(sgd_optimizer_1.SGDOptimizer));\nexports.MomentumOptimizer = MomentumOptimizer;\n//# sourceMappingURL=momentum_optimizer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvbW9tZW50dW1fb3B0aW1pemVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHRpbWl6ZXJzL21vbWVudHVtX29wdGltaXplci5qcz9kODExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uLy4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBzZ2Rfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9zZ2Rfb3B0aW1pemVyXCIpO1xudmFyIE1vbWVudHVtT3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTW9tZW50dW1PcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9tZW50dW1PcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBtb21lbnR1bSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIF90aGlzLm1vbWVudHVtID0gbW9tZW50dW07XG4gICAgICAgIF90aGlzLnZhcmlhYmxlVmVsb2NpdGllcyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgX3RoaXMubSA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLm1vbWVudHVtKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNb21lbnR1bU9wdGltaXplci5wcm90b3R5cGUuYmVmb3JlQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaC5jYWxsKHRoaXMsIG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKTtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGVWZWxvY2l0aWVzLnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy52YXJpYWJsZVZlbG9jaXRpZXMuc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vbWVudHVtT3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYXJpYWJsZSA9IGFjdGl2YXRpb25BcnJheU1hcC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZlbG9jaXR5ID0gX3RoaXMudmFyaWFibGVWZWxvY2l0aWVzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIHZlbG9jaXR5ID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5tLCBvbGRWZWxvY2l0eSwgX3RoaXMub25lLCBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5jLCB2ZWxvY2l0eSwgX3RoaXMub25lLCBvbGRWYXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMudmFyaWFibGVWZWxvY2l0aWVzLnNldChub2RlLm91dHB1dCwga2VlcCh2ZWxvY2l0eSkpO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRpb25BcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIGtlZXAodmFyaWFibGUpKTtcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSB2YXJpYWJsZTtcbiAgICAgICAgICAgICAgICBvbGRWYXJpYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgb2xkVmVsb2NpdHkuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICB9O1xuICAgIE1vbWVudHVtT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5tLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZVZlbG9jaXRpZXMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgTW9tZW50dW1PcHRpbWl6ZXIucHJvdG90eXBlLnNldE1vbWVudHVtID0gZnVuY3Rpb24gKG1vbWVudHVtKSB7XG4gICAgICAgIHRoaXMubW9tZW50dW0gPSBtb21lbnR1bTtcbiAgICB9O1xuICAgIHJldHVybiBNb21lbnR1bU9wdGltaXplcjtcbn0oc2dkX29wdGltaXplcl8xLlNHRE9wdGltaXplcikpO1xuZXhwb3J0cy5Nb21lbnR1bU9wdGltaXplciA9IE1vbWVudHVtT3B0aW1pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9tZW50dW1fb3B0aW1pemVyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/optimizers/momentum_optimizer.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/optimizers/optimizer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/optimizers/optimizer.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ../../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar session_util = __webpack_require__(/*! ../session_util */ \"./node_modules/deeplearn/dist/src/graph/session_util.js\");\nvar tensor_array_map_1 = __webpack_require__(/*! ../tensor_array_map */ \"./node_modules/deeplearn/dist/src/graph/tensor_array_map.js\");\nvar Optimizer = (function () {\n    function Optimizer(learningRate, specifiedVariableList) {\n        this.learningRate = learningRate;\n        this.variableGradients = new tensor_array_map_1.TensorArrayMap();\n        this.one = ndarray_1.Scalar.new(1);\n        if (specifiedVariableList != null) {\n            this.specifiedVariableNodes = specifiedVariableList;\n        }\n    }\n    Optimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {\n        var _this = this;\n        this.variableNodes = this.specifiedVariableNodes == null ?\n            session_util.getVariableNodesFromEvaluationSet(runtime.nodes) :\n            this.specifiedVariableNodes;\n        if (batchSize !== this.prevBatchSize) {\n            if (this.c != null) {\n                this.c.dispose();\n            }\n            this.prevBatchSize = batchSize;\n            this.c = ndarray_1.Scalar.new(-this.learningRate / batchSize);\n        }\n        this.variableNodes.forEach(function (node) { return _this.variableGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape)); });\n    };\n    Optimizer.prototype.afterExample = function (math, runtime, activationArrayMap, gradientArrayMap) {\n        var _this = this;\n        math.scope(function (keep) {\n            _this.variableNodes.forEach(function (node) {\n                var gradient = gradientArrayMap.get(node.output);\n                var accumulatedGradient = _this.variableGradients.get(node.output);\n                _this.variableGradients.set(node.output, keep(math.add(gradient, accumulatedGradient)));\n                accumulatedGradient.dispose();\n            });\n        });\n    };\n    Optimizer.prototype.dispose = function () {\n        if (this.c != null) {\n            this.c.dispose();\n        }\n        this.one.dispose();\n    };\n    return Optimizer;\n}());\nexports.Optimizer = Optimizer;\n//# sourceMappingURL=optimizer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvb3B0aW1pemVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9vcHRpbWl6ZXJzL29wdGltaXplci5qcz85YzdhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgc2Vzc2lvbl91dGlsID0gcmVxdWlyZShcIi4uL3Nlc3Npb25fdXRpbFwiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBPcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9wdGltaXplcihsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkge1xuICAgICAgICB0aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgdGhpcy5vbmUgPSBuZGFycmF5XzEuU2NhbGFyLm5ldygxKTtcbiAgICAgICAgaWYgKHNwZWNpZmllZFZhcmlhYmxlTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWNpZmllZFZhcmlhYmxlTm9kZXMgPSBzcGVjaWZpZWRWYXJpYWJsZUxpc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT3B0aW1pemVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMgPSB0aGlzLnNwZWNpZmllZFZhcmlhYmxlTm9kZXMgPT0gbnVsbCA/XG4gICAgICAgICAgICBzZXNzaW9uX3V0aWwuZ2V0VmFyaWFibGVOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0KHJ1bnRpbWUubm9kZXMpIDpcbiAgICAgICAgICAgIHRoaXMuc3BlY2lmaWVkVmFyaWFibGVOb2RlcztcbiAgICAgICAgaWYgKGJhdGNoU2l6ZSAhPT0gdGhpcy5wcmV2QmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmV2QmF0Y2hTaXplID0gYmF0Y2hTaXplO1xuICAgICAgICAgICAgdGhpcy5jID0gbmRhcnJheV8xLlNjYWxhci5uZXcoLXRoaXMubGVhcm5pbmdSYXRlIC8gYmF0Y2hTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuc2V0KG5vZGUub3V0cHV0LCBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpOyB9KTtcbiAgICB9O1xuICAgIE9wdGltaXplci5wcm90b3R5cGUuYWZ0ZXJFeGFtcGxlID0gZnVuY3Rpb24gKG1hdGgsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBfdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBncmFkaWVudEFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGFjY3VtdWxhdGVkR3JhZGllbnQgPSBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLnNldChub2RlLm91dHB1dCwga2VlcChtYXRoLmFkZChncmFkaWVudCwgYWNjdW11bGF0ZWRHcmFkaWVudCkpKTtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZEdyYWRpZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmMuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25lLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBPcHRpbWl6ZXI7XG59KCkpO1xuZXhwb3J0cy5PcHRpbWl6ZXIgPSBPcHRpbWl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpbWl6ZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/optimizers/optimizer.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/optimizers/rmsprop_optimizer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/optimizers/rmsprop_optimizer.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ../../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar tensor_array_map_1 = __webpack_require__(/*! ../tensor_array_map */ \"./node_modules/deeplearn/dist/src/graph/tensor_array_map.js\");\nvar optimizer_1 = __webpack_require__(/*! ./optimizer */ \"./node_modules/deeplearn/dist/src/graph/optimizers/optimizer.js\");\nvar RMSPropOptimizer = (function (_super) {\n    __extends(RMSPropOptimizer, _super);\n    function RMSPropOptimizer(learningRate, gamma, specifiedVariableList) {\n        var _this = _super.call(this, learningRate, specifiedVariableList) || this;\n        _this.learningRate = learningRate;\n        _this.gamma = gamma;\n        _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();\n        _this.eps = ndarray_1.Scalar.new(1e-6);\n        _this.g = ndarray_1.Scalar.new(_this.gamma);\n        return _this;\n    }\n    RMSPropOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {\n        var _this = this;\n        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);\n        if (this.accumulatedSquaredGradients.size() === 0) {\n            this.variableNodes.forEach(function (node) {\n                _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));\n            });\n        }\n    };\n    RMSPropOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {\n        var _this = this;\n        math.scope(function (keep) {\n            _this.variableNodes.forEach(function (node) {\n                var oldVariable = activationArrayMap.get(node.output);\n                var gradient = _this.variableGradients.get(node.output);\n                var oldCache = _this.accumulatedSquaredGradients.get(node.output);\n                var gradientSquare = math.multiply(gradient, gradient);\n                var cache = math.scaledArrayAdd(_this.g, oldCache, math.sub(_this.one, _this.g), gradientSquare);\n                var variable = math.scaledArrayAdd(_this.c, math.divide(gradient, math.add(math.sqrt(cache), _this.eps)), _this.one, oldVariable);\n                _this.accumulatedSquaredGradients.set(node.output, keep(cache));\n                activationArrayMap.set(node.output, keep(variable));\n                node.data = variable;\n                oldVariable.dispose();\n                oldCache.dispose();\n            });\n        });\n        this.variableGradients.dispose();\n        this.variableGradients = new tensor_array_map_1.TensorArrayMap();\n    };\n    RMSPropOptimizer.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        this.eps.dispose();\n        this.g.dispose();\n        this.accumulatedSquaredGradients.dispose();\n    };\n    return RMSPropOptimizer;\n}(optimizer_1.Optimizer));\nexports.RMSPropOptimizer = RMSPropOptimizer;\n//# sourceMappingURL=rmsprop_optimizer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvcm1zcHJvcF9vcHRpbWl6ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvcm1zcHJvcF9vcHRpbWl6ZXIuanM/M2QwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXRoL25kYXJyYXlcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJcIik7XG52YXIgUk1TUHJvcE9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJNU1Byb3BPcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUk1TUHJvcE9wdGltaXplcihsZWFybmluZ1JhdGUsIGdhbW1hLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbGVhcm5pbmdSYXRlLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgX3RoaXMuZ2FtbWEgPSBnYW1tYTtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5lcHMgPSBuZGFycmF5XzEuU2NhbGFyLm5ldygxZS02KTtcbiAgICAgICAgX3RoaXMuZyA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KF90aGlzLmdhbW1hKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSTVNQcm9wT3B0aW1pemVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoLmNhbGwodGhpcywgbWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApO1xuICAgICAgICBpZiAodGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zZXQobm9kZS5vdXRwdXQsIG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUk1TUHJvcE9wdGltaXplci5wcm90b3R5cGUuYWZ0ZXJCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtYXRoLnNjb3BlKGZ1bmN0aW9uIChrZWVwKSB7XG4gICAgICAgICAgICBfdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFyaWFibGUgPSBhY3RpdmF0aW9uQXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRDYWNoZSA9IF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudFNxdWFyZSA9IG1hdGgubXVsdGlwbHkoZ3JhZGllbnQsIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmcsIG9sZENhY2hlLCBtYXRoLnN1YihfdGhpcy5vbmUsIF90aGlzLmcpLCBncmFkaWVudFNxdWFyZSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5jLCBtYXRoLmRpdmlkZShncmFkaWVudCwgbWF0aC5hZGQobWF0aC5zcXJ0KGNhY2hlKSwgX3RoaXMuZXBzKSksIF90aGlzLm9uZSwgb2xkVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zZXQobm9kZS5vdXRwdXQsIGtlZXAoY2FjaGUpKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBrZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgb2xkVmFyaWFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZENhY2hlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBSTVNQcm9wT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lcHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmcuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gUk1TUHJvcE9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLlJNU1Byb3BPcHRpbWl6ZXIgPSBSTVNQcm9wT3B0aW1pemVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm1zcHJvcF9vcHRpbWl6ZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/optimizers/rmsprop_optimizer.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/optimizers/sgd_optimizer.js":
/*!***************************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/optimizers/sgd_optimizer.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tensor_array_map_1 = __webpack_require__(/*! ../tensor_array_map */ \"./node_modules/deeplearn/dist/src/graph/tensor_array_map.js\");\nvar optimizer_1 = __webpack_require__(/*! ./optimizer */ \"./node_modules/deeplearn/dist/src/graph/optimizers/optimizer.js\");\nvar SGDOptimizer = (function (_super) {\n    __extends(SGDOptimizer, _super);\n    function SGDOptimizer(learningRate, specifiedVariableList) {\n        var _this = _super.call(this, learningRate, specifiedVariableList) || this;\n        _this.learningRate = learningRate;\n        return _this;\n    }\n    SGDOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {\n        var _this = this;\n        math.scope(function (keep) {\n            _this.variableNodes.forEach(function (node) {\n                var oldVariable = activationArrayMap.get(node.output);\n                var gradient = _this.variableGradients.get(node.output);\n                var variable = math.scaledArrayAdd(_this.c, gradient, _this.one, oldVariable);\n                activationArrayMap.set(node.output, keep(variable));\n                node.data = variable;\n                oldVariable.dispose();\n            });\n        });\n        this.variableGradients.dispose();\n        this.variableGradients = new tensor_array_map_1.TensorArrayMap();\n    };\n    SGDOptimizer.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n    };\n    SGDOptimizer.prototype.setLearningRate = function (learningRate) {\n        this.learningRate = learningRate;\n    };\n    return SGDOptimizer;\n}(optimizer_1.Optimizer));\nexports.SGDOptimizer = SGDOptimizer;\n//# sourceMappingURL=sgd_optimizer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL29wdGltaXplcnMvc2dkX29wdGltaXplci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvb3B0aW1pemVycy9zZ2Rfb3B0aW1pemVyLmpzP2VkMTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplclwiKTtcbnZhciBTR0RPcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTR0RPcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU0dET3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZWFybmluZ1JhdGUgPSBsZWFybmluZ1JhdGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU0dET3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYXJpYWJsZSA9IGFjdGl2YXRpb25BcnJheU1hcC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5jLCBncmFkaWVudCwgX3RoaXMub25lLCBvbGRWYXJpYWJsZSk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGlvbkFycmF5TWFwLnNldChub2RlLm91dHB1dCwga2VlcCh2YXJpYWJsZSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIG9sZFZhcmlhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBTR0RPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgU0dET3B0aW1pemVyLnByb3RvdHlwZS5zZXRMZWFybmluZ1JhdGUgPSBmdW5jdGlvbiAobGVhcm5pbmdSYXRlKSB7XG4gICAgICAgIHRoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgIH07XG4gICAgcmV0dXJuIFNHRE9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLlNHRE9wdGltaXplciA9IFNHRE9wdGltaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNnZF9vcHRpbWl6ZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/optimizers/sgd_optimizer.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/priority_queue.js":
/*!*****************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/priority_queue.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction defaultCompare(a, b) {\n    if (a === b) {\n        return 0;\n    }\n    else if (a < b) {\n        return -1;\n    }\n    else {\n        return 1;\n    }\n}\nexports.defaultCompare = defaultCompare;\nvar PriorityQueue = (function () {\n    function PriorityQueue(comparator, indexObserver) {\n        this.comparator = comparator;\n        this.indexObserver = indexObserver;\n        this.heap = [];\n    }\n    PriorityQueue.prototype.enqueue = function (t) {\n        this.heap.push(t);\n        this.onIndexChanged(t, this.heap.length - 1);\n        this.siftUp(this.heap.length - 1);\n    };\n    PriorityQueue.prototype.dequeue = function () {\n        if (this.empty()) {\n            throw new Error('dequeue called on empty priority queue.');\n        }\n        var t = this.heap[0];\n        this.swap(0, this.heap.length - 1);\n        this.heap.pop();\n        this.siftDown(0);\n        return t;\n    };\n    PriorityQueue.prototype.update = function (newT, index) {\n        var last = (index === this.heap.length - 1);\n        if (!last) {\n            this.swap(index, this.heap.length - 1);\n        }\n        this.heap.pop();\n        if (!last) {\n            if (this.siftUpIndex(index) !== -1) {\n                this.siftUp(index);\n            }\n            else if (this.siftDownIndex(index) !== -1) {\n                this.siftDown(index);\n            }\n        }\n        this.enqueue(newT);\n    };\n    PriorityQueue.prototype.empty = function () {\n        return this.heap.length === 0;\n    };\n    PriorityQueue.prototype.onIndexChanged = function (t, newIndex) {\n        if (this.indexObserver) {\n            this.indexObserver(t, newIndex);\n        }\n    };\n    PriorityQueue.prototype.getParentIndex = function (index) {\n        if (index === 0) {\n            return -1;\n        }\n        return Math.floor((index - 1) / 2);\n    };\n    PriorityQueue.prototype.getLeftChildIndex = function (index) {\n        var candidate = index * 2 + 1;\n        return candidate < this.heap.length ? candidate : -1;\n    };\n    PriorityQueue.prototype.getRightChildIndex = function (index) {\n        var candidate = index * 2 + 2;\n        return candidate < this.heap.length ? candidate : -1;\n    };\n    PriorityQueue.prototype.siftUpIndex = function (index) {\n        var parentIndex = this.getParentIndex(index);\n        if (parentIndex === -1) {\n            return -1;\n        }\n        if (this.compare(parentIndex, index) > 0) {\n            return parentIndex;\n        }\n        return -1;\n    };\n    PriorityQueue.prototype.siftUp = function (index) {\n        var siftIndex = this.siftUpIndex(index);\n        while (siftIndex !== -1) {\n            this.swap(index, siftIndex);\n            index = siftIndex;\n            siftIndex = this.siftUpIndex(index);\n        }\n    };\n    PriorityQueue.prototype.siftDownIndex = function (index) {\n        if (index >= this.heap.length) {\n            return -1;\n        }\n        var largestChildIndex = index;\n        var leftChildIndex = this.getLeftChildIndex(index);\n        if ((leftChildIndex !== -1) &&\n            (this.compare(leftChildIndex, largestChildIndex) < 0)) {\n            largestChildIndex = leftChildIndex;\n        }\n        var rightChildIndex = this.getRightChildIndex(index);\n        if ((rightChildIndex !== -1) &&\n            (this.compare(rightChildIndex, largestChildIndex) < 0)) {\n            largestChildIndex = rightChildIndex;\n        }\n        return (largestChildIndex === index) ? -1 : largestChildIndex;\n    };\n    PriorityQueue.prototype.siftDown = function (index) {\n        var siftIndex = this.siftDownIndex(index);\n        while (siftIndex !== -1) {\n            this.swap(index, siftIndex);\n            index = siftIndex;\n            siftIndex = this.siftDownIndex(index);\n        }\n    };\n    PriorityQueue.prototype.compare = function (aIndex, bIndex) {\n        return this.comparator(this.heap[aIndex], this.heap[bIndex]);\n    };\n    PriorityQueue.prototype.swap = function (a, b) {\n        var temp = this.heap[a];\n        this.heap[a] = this.heap[b];\n        this.heap[b] = temp;\n        this.onIndexChanged(this.heap[a], a);\n        this.onIndexChanged(this.heap[b], b);\n    };\n    return PriorityQueue;\n}());\nexports.PriorityQueue = PriorityQueue;\n//# sourceMappingURL=priority_queue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL3ByaW9yaXR5X3F1ZXVlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9ncmFwaC9wcmlvcml0eV9xdWV1ZS5qcz9mYTI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChhIDwgYikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHRDb21wYXJlID0gZGVmYXVsdENvbXBhcmU7XG52YXIgUHJpb3JpdHlRdWV1ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJpb3JpdHlRdWV1ZShjb21wYXJhdG9yLCBpbmRleE9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgICAgIHRoaXMuaW5kZXhPYnNlcnZlciA9IGluZGV4T2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMuaGVhcCA9IFtdO1xuICAgIH1cbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdGhpcy5oZWFwLnB1c2godCk7XG4gICAgICAgIHRoaXMub25JbmRleENoYW5nZWQodCwgdGhpcy5oZWFwLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLnNpZnRVcCh0aGlzLmhlYXAubGVuZ3RoIC0gMSk7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5kZXF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlcXVldWUgY2FsbGVkIG9uIGVtcHR5IHByaW9yaXR5IHF1ZXVlLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ID0gdGhpcy5oZWFwWzBdO1xuICAgICAgICB0aGlzLnN3YXAoMCwgdGhpcy5oZWFwLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLmhlYXAucG9wKCk7XG4gICAgICAgIHRoaXMuc2lmdERvd24oMCk7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG5ld1QsIGluZGV4KSB7XG4gICAgICAgIHZhciBsYXN0ID0gKGluZGV4ID09PSB0aGlzLmhlYXAubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgdGhpcy5zd2FwKGluZGV4LCB0aGlzLmhlYXAubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFwLnBvcCgpO1xuICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpZnRVcEluZGV4KGluZGV4KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZnRVcChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnNpZnREb3duSW5kZXgoaW5kZXgpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2lmdERvd24oaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5xdWV1ZShuZXdUKTtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFwLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLm9uSW5kZXhDaGFuZ2VkID0gZnVuY3Rpb24gKHQsIG5ld0luZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhPYnNlcnZlcih0LCBuZXdJbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmdldFBhcmVudEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKChpbmRleCAtIDEpIC8gMik7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5nZXRMZWZ0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gaW5kZXggKiAyICsgMTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSA8IHRoaXMuaGVhcC5sZW5ndGggPyBjYW5kaWRhdGUgOiAtMTtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmdldFJpZ2h0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gaW5kZXggKiAyICsgMjtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSA8IHRoaXMuaGVhcC5sZW5ndGggPyBjYW5kaWRhdGUgOiAtMTtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnNpZnRVcEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBwYXJlbnRJbmRleCA9IHRoaXMuZ2V0UGFyZW50SW5kZXgoaW5kZXgpO1xuICAgICAgICBpZiAocGFyZW50SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29tcGFyZShwYXJlbnRJbmRleCwgaW5kZXgpID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnNpZnRVcCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgc2lmdEluZGV4ID0gdGhpcy5zaWZ0VXBJbmRleChpbmRleCk7XG4gICAgICAgIHdoaWxlIChzaWZ0SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnN3YXAoaW5kZXgsIHNpZnRJbmRleCk7XG4gICAgICAgICAgICBpbmRleCA9IHNpZnRJbmRleDtcbiAgICAgICAgICAgIHNpZnRJbmRleCA9IHRoaXMuc2lmdFVwSW5kZXgoaW5kZXgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5zaWZ0RG93bkluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmhlYXAubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhcmdlc3RDaGlsZEluZGV4ID0gaW5kZXg7XG4gICAgICAgIHZhciBsZWZ0Q2hpbGRJbmRleCA9IHRoaXMuZ2V0TGVmdENoaWxkSW5kZXgoaW5kZXgpO1xuICAgICAgICBpZiAoKGxlZnRDaGlsZEluZGV4ICE9PSAtMSkgJiZcbiAgICAgICAgICAgICh0aGlzLmNvbXBhcmUobGVmdENoaWxkSW5kZXgsIGxhcmdlc3RDaGlsZEluZGV4KSA8IDApKSB7XG4gICAgICAgICAgICBsYXJnZXN0Q2hpbGRJbmRleCA9IGxlZnRDaGlsZEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHZhciByaWdodENoaWxkSW5kZXggPSB0aGlzLmdldFJpZ2h0Q2hpbGRJbmRleChpbmRleCk7XG4gICAgICAgIGlmICgocmlnaHRDaGlsZEluZGV4ICE9PSAtMSkgJiZcbiAgICAgICAgICAgICh0aGlzLmNvbXBhcmUocmlnaHRDaGlsZEluZGV4LCBsYXJnZXN0Q2hpbGRJbmRleCkgPCAwKSkge1xuICAgICAgICAgICAgbGFyZ2VzdENoaWxkSW5kZXggPSByaWdodENoaWxkSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChsYXJnZXN0Q2hpbGRJbmRleCA9PT0gaW5kZXgpID8gLTEgOiBsYXJnZXN0Q2hpbGRJbmRleDtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnNpZnREb3duID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBzaWZ0SW5kZXggPSB0aGlzLnNpZnREb3duSW5kZXgoaW5kZXgpO1xuICAgICAgICB3aGlsZSAoc2lmdEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5zd2FwKGluZGV4LCBzaWZ0SW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggPSBzaWZ0SW5kZXg7XG4gICAgICAgICAgICBzaWZ0SW5kZXggPSB0aGlzLnNpZnREb3duSW5kZXgoaW5kZXgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGFJbmRleCwgYkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmF0b3IodGhpcy5oZWFwW2FJbmRleF0sIHRoaXMuaGVhcFtiSW5kZXhdKTtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnN3YXAgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgdGVtcCA9IHRoaXMuaGVhcFthXTtcbiAgICAgICAgdGhpcy5oZWFwW2FdID0gdGhpcy5oZWFwW2JdO1xuICAgICAgICB0aGlzLmhlYXBbYl0gPSB0ZW1wO1xuICAgICAgICB0aGlzLm9uSW5kZXhDaGFuZ2VkKHRoaXMuaGVhcFthXSwgYSk7XG4gICAgICAgIHRoaXMub25JbmRleENoYW5nZWQodGhpcy5oZWFwW2JdLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBQcmlvcml0eVF1ZXVlO1xufSgpKTtcbmV4cG9ydHMuUHJpb3JpdHlRdWV1ZSA9IFByaW9yaXR5UXVldWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmlvcml0eV9xdWV1ZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/priority_queue.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/session.js":
/*!**********************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/session.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar operation_emitter = __webpack_require__(/*! ./operation_emitter */ \"./node_modules/deeplearn/dist/src/graph/operation_emitter.js\");\nvar session_util = __webpack_require__(/*! ./session_util */ \"./node_modules/deeplearn/dist/src/graph/session_util.js\");\nvar tensor_array_map_1 = __webpack_require__(/*! ./tensor_array_map */ \"./node_modules/deeplearn/dist/src/graph/tensor_array_map.js\");\nvar FeedDictionary = (function () {\n    function FeedDictionary(feedEntries) {\n        var _this = this;\n        this.dict = {};\n        if (feedEntries) {\n            feedEntries.forEach(function (entry) { return _this.dict[entry.tensor.id] = entry; });\n        }\n    }\n    return FeedDictionary;\n}());\nexports.FeedDictionary = FeedDictionary;\nvar CostReduction;\n(function (CostReduction) {\n    CostReduction[CostReduction[\"NONE\"] = 0] = \"NONE\";\n    CostReduction[CostReduction[\"SUM\"] = 1] = \"SUM\";\n    CostReduction[CostReduction[\"MEAN\"] = 2] = \"MEAN\";\n})(CostReduction = exports.CostReduction || (exports.CostReduction = {}));\nvar Session = (function () {\n    function Session(graph, math) {\n        this.math = math;\n        this.activationArrayMap = new tensor_array_map_1.TensorArrayMap();\n        this.runtimeCache = {};\n        this.oneScalar = ndarray_1.Scalar.new(1);\n        this.gradientArrayMap = new tensor_array_map_1.SummedTensorArrayMap(this.math);\n    }\n    Session.prototype.dispose = function () {\n        var _this = this;\n        this.activationArrayMap.dispose();\n        Object.keys(this.runtimeCache).forEach(function (key) {\n            var runtime = _this.runtimeCache[key];\n            if (runtime.operations) {\n                runtime.operations.forEach(function (op) { return op.dispose(); });\n            }\n        });\n        this.runtimeCache = {};\n        if (this.batchSizeScalar != null) {\n            this.batchSizeScalar.dispose();\n        }\n        this.oneScalar.dispose();\n    };\n    Session.prototype.evalAll = function (tensors, feedEntries) {\n        var _this = this;\n        return this.math.scope(function () {\n            var feed = new FeedDictionary(feedEntries);\n            var runtime = _this.getOrCreateRuntime(tensors, feed);\n            var activations = _this.activationArrayMap;\n            session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);\n            session_util.disposeTransientOperationArrays(runtime.operations, _this.activationArrayMap, _this.gradientArrayMap);\n            session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);\n            session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);\n            runtime.operations.forEach(function (op) { return op.feedForward(_this.math, activations); });\n            var results = tensors.map(function (x) { return activations.get(x); });\n            tensors.forEach(function (x) { return activations.delete(x); });\n            session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);\n            return results;\n        });\n    };\n    Session.prototype.eval = function (tensor, feedEntries) {\n        return this.evalAll([tensor], feedEntries)[0];\n    };\n    Session.prototype.train = function (costTensor, feedEntries, batchSize, optimizer, costReduction) {\n        var _this = this;\n        if (costReduction === void 0) { costReduction = CostReduction.NONE; }\n        util.assert(util.isScalarShape(costTensor.shape), 'Cost tensor for training must be a scalar value.');\n        if (this.prevBatchSize !== batchSize) {\n            this.prevBatchSize = batchSize;\n            this.batchSizeScalar = ndarray_1.Scalar.new(batchSize);\n        }\n        var feed = new FeedDictionary(feedEntries);\n        session_util.throwIfFeedDictionaryContainsNDArrays(feed);\n        var runtime = this.getOrCreateRuntime([costTensor], feed);\n        var inferenceOperations = runtime.operations;\n        var backPropOperations = runtime.operations.slice().reverse();\n        var activations = this.activationArrayMap;\n        var gradients = this.gradientArrayMap;\n        gradients.nullify(costTensor);\n        gradients.add(costTensor, this.oneScalar);\n        session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);\n        optimizer.beforeBatch(this.math, batchSize, runtime, activations, gradients);\n        return this.math.scope(function (keep, track) {\n            var cost = track(ndarray_1.Scalar.new(0));\n            for (var i = 0; i < batchSize; ++i) {\n                session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);\n                session_util.disposeAndInitializeOperationInputGradients(runtime.nodes, gradients);\n                session_util.disposeTransientOperationArrays(runtime.operations, activations, gradients);\n                session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);\n                inferenceOperations.forEach(function (op) { return op.feedForward(_this.math, activations); });\n                backPropOperations.forEach(function (op) { return op.backProp(_this.math, activations, gradients); });\n                optimizer.afterExample(_this.math, runtime, activations, gradients);\n                session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);\n                cost = _this.updateCostForExample(cost, activations.get(costTensor), costReduction);\n            }\n            optimizer.afterBatch(_this.math, batchSize, runtime, activations, gradients);\n            return _this.updateCostForBatch(cost, costReduction);\n        });\n    };\n    Session.prototype.updateCostForExample = function (totalCost, currCost, costReduction) {\n        if (costReduction === CostReduction.MEAN ||\n            costReduction === CostReduction.SUM) {\n            return this.math.add(totalCost, currCost);\n        }\n        return totalCost;\n    };\n    Session.prototype.updateCostForBatch = function (totalCost, costReduction) {\n        if (costReduction === CostReduction.MEAN) {\n            return this.math.divide(totalCost, this.batchSizeScalar);\n        }\n        return totalCost;\n    };\n    Session.prototype.getOrCreateRuntime = function (tensors, feed) {\n        var key = this.makeRuntimeCacheKey(tensors, feed);\n        var runtime = this.runtimeCache[key];\n        if (runtime === undefined) {\n            var nodes = session_util.getOrderedEvaluationSetFromEvalTensor(tensors, feed);\n            session_util.removeFeedDictionaryNodesFromEvaluationSet(feed, nodes);\n            session_util.throwErrorIfEvaluationSetContainsPlaceholderNodes(nodes);\n            var operations = operation_emitter.emitFromGraphNodes(nodes);\n            runtime = { nodes: nodes, operations: operations };\n            this.runtimeCache[key] = runtime;\n        }\n        return runtime;\n    };\n    Session.prototype.makeRuntimeCacheKey = function (tensors, feed) {\n        return tensors.map(function (x) { return x.id; }).sort().join('_') + '__' +\n            Object.keys(feed.dict).sort().join('_');\n    };\n    return Session;\n}());\nexports.Session = Session;\n//# sourceMappingURL=session.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL3Nlc3Npb24uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL3Nlc3Npb24uanM/NDNkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fZW1pdHRlciA9IHJlcXVpcmUoXCIuL29wZXJhdGlvbl9lbWl0dGVyXCIpO1xudmFyIHNlc3Npb25fdXRpbCA9IHJlcXVpcmUoXCIuL3Nlc3Npb25fdXRpbFwiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi90ZW5zb3JfYXJyYXlfbWFwXCIpO1xudmFyIEZlZWREaWN0aW9uYXJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGZWVkRGljdGlvbmFyeShmZWVkRW50cmllcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRpY3QgPSB7fTtcbiAgICAgICAgaWYgKGZlZWRFbnRyaWVzKSB7XG4gICAgICAgICAgICBmZWVkRW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gX3RoaXMuZGljdFtlbnRyeS50ZW5zb3IuaWRdID0gZW50cnk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBGZWVkRGljdGlvbmFyeTtcbn0oKSk7XG5leHBvcnRzLkZlZWREaWN0aW9uYXJ5ID0gRmVlZERpY3Rpb25hcnk7XG52YXIgQ29zdFJlZHVjdGlvbjtcbihmdW5jdGlvbiAoQ29zdFJlZHVjdGlvbikge1xuICAgIENvc3RSZWR1Y3Rpb25bQ29zdFJlZHVjdGlvbltcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICAgIENvc3RSZWR1Y3Rpb25bQ29zdFJlZHVjdGlvbltcIlNVTVwiXSA9IDFdID0gXCJTVU1cIjtcbiAgICBDb3N0UmVkdWN0aW9uW0Nvc3RSZWR1Y3Rpb25bXCJNRUFOXCJdID0gMl0gPSBcIk1FQU5cIjtcbn0pKENvc3RSZWR1Y3Rpb24gPSBleHBvcnRzLkNvc3RSZWR1Y3Rpb24gfHwgKGV4cG9ydHMuQ29zdFJlZHVjdGlvbiA9IHt9KSk7XG52YXIgU2Vzc2lvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2Vzc2lvbihncmFwaCwgbWF0aCkge1xuICAgICAgICB0aGlzLm1hdGggPSBtYXRoO1xuICAgICAgICB0aGlzLmFjdGl2YXRpb25BcnJheU1hcCA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgdGhpcy5ydW50aW1lQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5vbmVTY2FsYXIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldygxKTtcbiAgICAgICAgdGhpcy5ncmFkaWVudEFycmF5TWFwID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5TdW1tZWRUZW5zb3JBcnJheU1hcCh0aGlzLm1hdGgpO1xuICAgIH1cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmFjdGl2YXRpb25BcnJheU1hcC5kaXNwb3NlKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMucnVudGltZUNhY2hlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBydW50aW1lID0gX3RoaXMucnVudGltZUNhY2hlW2tleV07XG4gICAgICAgICAgICBpZiAocnVudGltZS5vcGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgcnVudGltZS5vcGVyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC5kaXNwb3NlKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ydW50aW1lQ2FjaGUgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2hTaXplU2NhbGFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hTaXplU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5ldmFsQWxsID0gZnVuY3Rpb24gKHRlbnNvcnMsIGZlZWRFbnRyaWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZlZWQgPSBuZXcgRmVlZERpY3Rpb25hcnkoZmVlZEVudHJpZXMpO1xuICAgICAgICAgICAgdmFyIHJ1bnRpbWUgPSBfdGhpcy5nZXRPckNyZWF0ZVJ1bnRpbWUodGVuc29ycywgZmVlZCk7XG4gICAgICAgICAgICB2YXIgYWN0aXZhdGlvbnMgPSBfdGhpcy5hY3RpdmF0aW9uQXJyYXlNYXA7XG4gICAgICAgICAgICBzZXNzaW9uX3V0aWwuZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25PdXRwdXRzKHJ1bnRpbWUubm9kZXMsIGFjdGl2YXRpb25zKTtcbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC5kaXNwb3NlVHJhbnNpZW50T3BlcmF0aW9uQXJyYXlzKHJ1bnRpbWUub3BlcmF0aW9ucywgX3RoaXMuYWN0aXZhdGlvbkFycmF5TWFwLCBfdGhpcy5ncmFkaWVudEFycmF5TWFwKTtcbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC5hZGRQZXJzaXN0ZW50QXJyYXlzVG9UZW5zb3JBcnJheU1hcChydW50aW1lLm5vZGVzLCBhY3RpdmF0aW9ucyk7XG4gICAgICAgICAgICBzZXNzaW9uX3V0aWwubG9hZElucHV0c0Zyb21GZWVkRGljdGlvbmFyeVRvVGVuc29yQXJyYXlNYXAoZmVlZCwgYWN0aXZhdGlvbnMsIF90aGlzLm1hdGgpO1xuICAgICAgICAgICAgcnVudGltZS5vcGVyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC5mZWVkRm9yd2FyZChfdGhpcy5tYXRoLCBhY3RpdmF0aW9ucyk7IH0pO1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB0ZW5zb3JzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gYWN0aXZhdGlvbnMuZ2V0KHgpOyB9KTtcbiAgICAgICAgICAgIHRlbnNvcnMuZm9yRWFjaChmdW5jdGlvbiAoeCkgeyByZXR1cm4gYWN0aXZhdGlvbnMuZGVsZXRlKHgpOyB9KTtcbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC5yZWxlYXNlRmVlZERpY3Rpb25hcnlJbnB1dHNGcm9tVGVuc29yQXJyYXlNYXAoZmVlZCwgYWN0aXZhdGlvbnMsIF90aGlzLm1hdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuZXZhbCA9IGZ1bmN0aW9uICh0ZW5zb3IsIGZlZWRFbnRyaWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2YWxBbGwoW3RlbnNvcl0sIGZlZWRFbnRyaWVzKVswXTtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnRyYWluID0gZnVuY3Rpb24gKGNvc3RUZW5zb3IsIGZlZWRFbnRyaWVzLCBiYXRjaFNpemUsIG9wdGltaXplciwgY29zdFJlZHVjdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29zdFJlZHVjdGlvbiA9PT0gdm9pZCAwKSB7IGNvc3RSZWR1Y3Rpb24gPSBDb3N0UmVkdWN0aW9uLk5PTkU7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc1NjYWxhclNoYXBlKGNvc3RUZW5zb3Iuc2hhcGUpLCAnQ29zdCB0ZW5zb3IgZm9yIHRyYWluaW5nIG11c3QgYmUgYSBzY2FsYXIgdmFsdWUuJyk7XG4gICAgICAgIGlmICh0aGlzLnByZXZCYXRjaFNpemUgIT09IGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5wcmV2QmF0Y2hTaXplID0gYmF0Y2hTaXplO1xuICAgICAgICAgICAgdGhpcy5iYXRjaFNpemVTY2FsYXIgPSBuZGFycmF5XzEuU2NhbGFyLm5ldyhiYXRjaFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmZWVkID0gbmV3IEZlZWREaWN0aW9uYXJ5KGZlZWRFbnRyaWVzKTtcbiAgICAgICAgc2Vzc2lvbl91dGlsLnRocm93SWZGZWVkRGljdGlvbmFyeUNvbnRhaW5zTkRBcnJheXMoZmVlZCk7XG4gICAgICAgIHZhciBydW50aW1lID0gdGhpcy5nZXRPckNyZWF0ZVJ1bnRpbWUoW2Nvc3RUZW5zb3JdLCBmZWVkKTtcbiAgICAgICAgdmFyIGluZmVyZW5jZU9wZXJhdGlvbnMgPSBydW50aW1lLm9wZXJhdGlvbnM7XG4gICAgICAgIHZhciBiYWNrUHJvcE9wZXJhdGlvbnMgPSBydW50aW1lLm9wZXJhdGlvbnMuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICAgIHZhciBhY3RpdmF0aW9ucyA9IHRoaXMuYWN0aXZhdGlvbkFycmF5TWFwO1xuICAgICAgICB2YXIgZ3JhZGllbnRzID0gdGhpcy5ncmFkaWVudEFycmF5TWFwO1xuICAgICAgICBncmFkaWVudHMubnVsbGlmeShjb3N0VGVuc29yKTtcbiAgICAgICAgZ3JhZGllbnRzLmFkZChjb3N0VGVuc29yLCB0aGlzLm9uZVNjYWxhcik7XG4gICAgICAgIHNlc3Npb25fdXRpbC5hZGRQZXJzaXN0ZW50QXJyYXlzVG9UZW5zb3JBcnJheU1hcChydW50aW1lLm5vZGVzLCBhY3RpdmF0aW9ucyk7XG4gICAgICAgIG9wdGltaXplci5iZWZvcmVCYXRjaCh0aGlzLm1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbnMsIGdyYWRpZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXAsIHRyYWNrKSB7XG4gICAgICAgICAgICB2YXIgY29zdCA9IHRyYWNrKG5kYXJyYXlfMS5TY2FsYXIubmV3KDApKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmF0Y2hTaXplOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uX3V0aWwuZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25PdXRwdXRzKHJ1bnRpbWUubm9kZXMsIGFjdGl2YXRpb25zKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uX3V0aWwuZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25JbnB1dEdyYWRpZW50cyhydW50aW1lLm5vZGVzLCBncmFkaWVudHMpO1xuICAgICAgICAgICAgICAgIHNlc3Npb25fdXRpbC5kaXNwb3NlVHJhbnNpZW50T3BlcmF0aW9uQXJyYXlzKHJ1bnRpbWUub3BlcmF0aW9ucywgYWN0aXZhdGlvbnMsIGdyYWRpZW50cyk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmxvYWRJbnB1dHNGcm9tRmVlZERpY3Rpb25hcnlUb1RlbnNvckFycmF5TWFwKGZlZWQsIGFjdGl2YXRpb25zLCBfdGhpcy5tYXRoKTtcbiAgICAgICAgICAgICAgICBpbmZlcmVuY2VPcGVyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC5mZWVkRm9yd2FyZChfdGhpcy5tYXRoLCBhY3RpdmF0aW9ucyk7IH0pO1xuICAgICAgICAgICAgICAgIGJhY2tQcm9wT3BlcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AuYmFja1Byb3AoX3RoaXMubWF0aCwgYWN0aXZhdGlvbnMsIGdyYWRpZW50cyk7IH0pO1xuICAgICAgICAgICAgICAgIG9wdGltaXplci5hZnRlckV4YW1wbGUoX3RoaXMubWF0aCwgcnVudGltZSwgYWN0aXZhdGlvbnMsIGdyYWRpZW50cyk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbl91dGlsLnJlbGVhc2VGZWVkRGljdGlvbmFyeUlucHV0c0Zyb21UZW5zb3JBcnJheU1hcChmZWVkLCBhY3RpdmF0aW9ucywgX3RoaXMubWF0aCk7XG4gICAgICAgICAgICAgICAgY29zdCA9IF90aGlzLnVwZGF0ZUNvc3RGb3JFeGFtcGxlKGNvc3QsIGFjdGl2YXRpb25zLmdldChjb3N0VGVuc29yKSwgY29zdFJlZHVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpbWl6ZXIuYWZ0ZXJCYXRjaChfdGhpcy5tYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25zLCBncmFkaWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZUNvc3RGb3JCYXRjaChjb3N0LCBjb3N0UmVkdWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS51cGRhdGVDb3N0Rm9yRXhhbXBsZSA9IGZ1bmN0aW9uICh0b3RhbENvc3QsIGN1cnJDb3N0LCBjb3N0UmVkdWN0aW9uKSB7XG4gICAgICAgIGlmIChjb3N0UmVkdWN0aW9uID09PSBDb3N0UmVkdWN0aW9uLk1FQU4gfHxcbiAgICAgICAgICAgIGNvc3RSZWR1Y3Rpb24gPT09IENvc3RSZWR1Y3Rpb24uU1VNKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRoLmFkZCh0b3RhbENvc3QsIGN1cnJDb3N0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxDb3N0O1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUudXBkYXRlQ29zdEZvckJhdGNoID0gZnVuY3Rpb24gKHRvdGFsQ29zdCwgY29zdFJlZHVjdGlvbikge1xuICAgICAgICBpZiAoY29zdFJlZHVjdGlvbiA9PT0gQ29zdFJlZHVjdGlvbi5NRUFOKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRoLmRpdmlkZSh0b3RhbENvc3QsIHRoaXMuYmF0Y2hTaXplU2NhbGFyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxDb3N0O1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuZ2V0T3JDcmVhdGVSdW50aW1lID0gZnVuY3Rpb24gKHRlbnNvcnMsIGZlZWQpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMubWFrZVJ1bnRpbWVDYWNoZUtleSh0ZW5zb3JzLCBmZWVkKTtcbiAgICAgICAgdmFyIHJ1bnRpbWUgPSB0aGlzLnJ1bnRpbWVDYWNoZVtrZXldO1xuICAgICAgICBpZiAocnVudGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSBzZXNzaW9uX3V0aWwuZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXRGcm9tRXZhbFRlbnNvcih0ZW5zb3JzLCBmZWVkKTtcbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC5yZW1vdmVGZWVkRGljdGlvbmFyeU5vZGVzRnJvbUV2YWx1YXRpb25TZXQoZmVlZCwgbm9kZXMpO1xuICAgICAgICAgICAgc2Vzc2lvbl91dGlsLnRocm93RXJyb3JJZkV2YWx1YXRpb25TZXRDb250YWluc1BsYWNlaG9sZGVyTm9kZXMobm9kZXMpO1xuICAgICAgICAgICAgdmFyIG9wZXJhdGlvbnMgPSBvcGVyYXRpb25fZW1pdHRlci5lbWl0RnJvbUdyYXBoTm9kZXMobm9kZXMpO1xuICAgICAgICAgICAgcnVudGltZSA9IHsgbm9kZXM6IG5vZGVzLCBvcGVyYXRpb25zOiBvcGVyYXRpb25zIH07XG4gICAgICAgICAgICB0aGlzLnJ1bnRpbWVDYWNoZVtrZXldID0gcnVudGltZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVudGltZTtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLm1ha2VSdW50aW1lQ2FjaGVLZXkgPSBmdW5jdGlvbiAodGVuc29ycywgZmVlZCkge1xuICAgICAgICByZXR1cm4gdGVuc29ycy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguaWQ7IH0pLnNvcnQoKS5qb2luKCdfJykgKyAnX18nICtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGZlZWQuZGljdCkuc29ydCgpLmpvaW4oJ18nKTtcbiAgICB9O1xuICAgIHJldHVybiBTZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuU2Vzc2lvbiA9IFNlc3Npb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXNzaW9uLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/session.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/session_util.js":
/*!***************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/session_util.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ../math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar graph_1 = __webpack_require__(/*! ./graph */ \"./node_modules/deeplearn/dist/src/graph/graph.js\");\nvar graph_util = __webpack_require__(/*! ./graph_util */ \"./node_modules/deeplearn/dist/src/graph/graph_util.js\");\nfunction getTerminatingNodesFromFeedDictionary(feedDictionary) {\n    return Object.keys(feedDictionary.dict)\n        .map(function (tensorID) { return feedDictionary.dict[+tensorID].tensor.node; });\n}\nexports.getTerminatingNodesFromFeedDictionary = getTerminatingNodesFromFeedDictionary;\nfunction getOrderedEvaluationSetFromEvalTensor(evalTensors, feedDictionary) {\n    var terminatingNodes = getTerminatingNodesFromFeedDictionary(feedDictionary);\n    var evalNodes = evalTensors.map(function (x) { return x.node; });\n    var unorderedEvaluationSet = graph_util.getUnorderedEvaluationSet(evalNodes, terminatingNodes);\n    var orderedEvaluationSet = graph_util.getOrderedEvaluationSet(unorderedEvaluationSet);\n    return orderedEvaluationSet;\n}\nexports.getOrderedEvaluationSetFromEvalTensor = getOrderedEvaluationSetFromEvalTensor;\nfunction addPersistentArraysToTensorArrayMap(evaluationSet, tensorArrayMap) {\n    evaluationSet.forEach(function (node) {\n        if (node instanceof graph_1.VariableNode || node instanceof graph_1.ConstantNode) {\n            tensorArrayMap.set(node.output, node.data);\n        }\n    });\n}\nexports.addPersistentArraysToTensorArrayMap = addPersistentArraysToTensorArrayMap;\nfunction getVariableNodesFromEvaluationSet(evaluationSet) {\n    var nodes = [];\n    evaluationSet.forEach(function (node) {\n        if (node instanceof graph_1.VariableNode) {\n            nodes.push(node);\n        }\n    });\n    return nodes;\n}\nexports.getVariableNodesFromEvaluationSet = getVariableNodesFromEvaluationSet;\nfunction throwIfFeedDictionaryContainsNDArrays(feedDictionary) {\n    Object.keys(feedDictionary.dict).forEach(function (tensorID) {\n        if (feedDictionary.dict[+tensorID].data instanceof ndarray_1.NDArray) {\n            throw new Error('training requires FeedDictionary entries to be InputProviders' +\n                'and not NDArrays.');\n        }\n    });\n}\nexports.throwIfFeedDictionaryContainsNDArrays = throwIfFeedDictionaryContainsNDArrays;\nfunction loadInputsFromFeedDictionaryToTensorArrayMap(batchFeed, activations, math) {\n    Object.keys(batchFeed.dict).forEach(function (tensorID) {\n        var feedEntry = batchFeed.dict[+tensorID];\n        var data;\n        if (feedEntry.data instanceof ndarray_1.NDArray) {\n            data = feedEntry.data;\n        }\n        else {\n            var provider = feedEntry.data;\n            data = provider.getNextCopy(math);\n        }\n        util.assert(util.arraysEqual(feedEntry.tensor.shape, data.shape), \"Error loading FeedEntry: feeding NDArray of shape \" + data.shape + \" \" +\n            (\"does not match Tensor (id: \" + feedEntry.tensor.id + \") shape: \") +\n            (feedEntry.tensor.shape + \".\"));\n        activations.set(feedEntry.tensor, data);\n    });\n}\nexports.loadInputsFromFeedDictionaryToTensorArrayMap = loadInputsFromFeedDictionaryToTensorArrayMap;\nfunction releaseFeedDictionaryInputsFromTensorArrayMap(batchFeed, activations, math) {\n    Object.keys(batchFeed.dict).forEach(function (tensorID) {\n        var feedEntry = batchFeed.dict[+tensorID];\n        if (!(feedEntry.data instanceof ndarray_1.NDArray)) {\n            var provider = feedEntry.data;\n            var feedEntryArray = activations.get(feedEntry.tensor);\n            provider.disposeCopy(math, feedEntryArray);\n        }\n        activations.delete(feedEntry.tensor);\n    });\n}\nexports.releaseFeedDictionaryInputsFromTensorArrayMap = releaseFeedDictionaryInputsFromTensorArrayMap;\nfunction removeFeedDictionaryNodesFromEvaluationSet(feedDictionary, evaluationSet) {\n    var i = 0;\n    while (i < evaluationSet.length) {\n        var node = evaluationSet[i];\n        if (feedDictionary.dict[node.output.id] != null) {\n            evaluationSet.splice(i, 1);\n        }\n        else {\n            ++i;\n        }\n    }\n}\nexports.removeFeedDictionaryNodesFromEvaluationSet = removeFeedDictionaryNodesFromEvaluationSet;\nfunction disposeAndInitializeOperationOutputs(evaluationSet, tensorArrayMap) {\n    evaluationSet.forEach(function (node) {\n        if (!graph_util.isInputNode(node)) {\n            if (!graph_util.isPassthroughNode(node, tensorArrayMap)) {\n                tensorArrayMap.disposeArray(node.output);\n            }\n            tensorArrayMap.set(node.output, null);\n        }\n    });\n}\nexports.disposeAndInitializeOperationOutputs = disposeAndInitializeOperationOutputs;\nfunction disposeAndInitializeOperationInputGradients(evaluationSet, gradients) {\n    evaluationSet.forEach(function (node) {\n        Object.keys(node.inputs).forEach(function (inputName) {\n            var input = node.inputs[inputName];\n            if (gradients.get(input, true) !== gradients.get(node.output, true)) {\n                gradients.disposeArray(input);\n            }\n            gradients.nullify(input);\n        });\n    });\n}\nexports.disposeAndInitializeOperationInputGradients = disposeAndInitializeOperationInputGradients;\nfunction disposeTransientOperationArrays(operations, activations, gradients) {\n    operations.forEach(function (op) { return op.disposeTransientArrays(activations, gradients); });\n}\nexports.disposeTransientOperationArrays = disposeTransientOperationArrays;\nfunction throwErrorIfEvaluationSetContainsPlaceholderNodes(evaluationSet) {\n    evaluationSet.forEach(function (node) {\n        if (node instanceof graph_1.PlaceholderNode) {\n            var shape = '[' + node.output.shape.join(', ') + ']';\n            throw new Error('Placeholder node \"' + node.name + '\" ' + shape +\n                ' not present in feed dictionary.');\n        }\n    });\n}\nexports.throwErrorIfEvaluationSetContainsPlaceholderNodes = throwErrorIfEvaluationSetContainsPlaceholderNodes;\n//# sourceMappingURL=session_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL3Nlc3Npb25fdXRpbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGgvc2Vzc2lvbl91dGlsLmpzPzM3N2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4uL21hdGgvbmRhcnJheVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgZ3JhcGhfMSA9IHJlcXVpcmUoXCIuL2dyYXBoXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi9ncmFwaF91dGlsXCIpO1xuZnVuY3Rpb24gZ2V0VGVybWluYXRpbmdOb2Rlc0Zyb21GZWVkRGljdGlvbmFyeShmZWVkRGljdGlvbmFyeSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhmZWVkRGljdGlvbmFyeS5kaWN0KVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh0ZW5zb3JJRCkgeyByZXR1cm4gZmVlZERpY3Rpb25hcnkuZGljdFsrdGVuc29ySURdLnRlbnNvci5ub2RlOyB9KTtcbn1cbmV4cG9ydHMuZ2V0VGVybWluYXRpbmdOb2Rlc0Zyb21GZWVkRGljdGlvbmFyeSA9IGdldFRlcm1pbmF0aW5nTm9kZXNGcm9tRmVlZERpY3Rpb25hcnk7XG5mdW5jdGlvbiBnZXRPcmRlcmVkRXZhbHVhdGlvblNldEZyb21FdmFsVGVuc29yKGV2YWxUZW5zb3JzLCBmZWVkRGljdGlvbmFyeSkge1xuICAgIHZhciB0ZXJtaW5hdGluZ05vZGVzID0gZ2V0VGVybWluYXRpbmdOb2Rlc0Zyb21GZWVkRGljdGlvbmFyeShmZWVkRGljdGlvbmFyeSk7XG4gICAgdmFyIGV2YWxOb2RlcyA9IGV2YWxUZW5zb3JzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5ub2RlOyB9KTtcbiAgICB2YXIgdW5vcmRlcmVkRXZhbHVhdGlvblNldCA9IGdyYXBoX3V0aWwuZ2V0VW5vcmRlcmVkRXZhbHVhdGlvblNldChldmFsTm9kZXMsIHRlcm1pbmF0aW5nTm9kZXMpO1xuICAgIHZhciBvcmRlcmVkRXZhbHVhdGlvblNldCA9IGdyYXBoX3V0aWwuZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXQodW5vcmRlcmVkRXZhbHVhdGlvblNldCk7XG4gICAgcmV0dXJuIG9yZGVyZWRFdmFsdWF0aW9uU2V0O1xufVxuZXhwb3J0cy5nZXRPcmRlcmVkRXZhbHVhdGlvblNldEZyb21FdmFsVGVuc29yID0gZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXRGcm9tRXZhbFRlbnNvcjtcbmZ1bmN0aW9uIGFkZFBlcnNpc3RlbnRBcnJheXNUb1RlbnNvckFycmF5TWFwKGV2YWx1YXRpb25TZXQsIHRlbnNvckFycmF5TWFwKSB7XG4gICAgZXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5WYXJpYWJsZU5vZGUgfHwgbm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQ29uc3RhbnROb2RlKSB7XG4gICAgICAgICAgICB0ZW5zb3JBcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIG5vZGUuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuYWRkUGVyc2lzdGVudEFycmF5c1RvVGVuc29yQXJyYXlNYXAgPSBhZGRQZXJzaXN0ZW50QXJyYXlzVG9UZW5zb3JBcnJheU1hcDtcbmZ1bmN0aW9uIGdldFZhcmlhYmxlTm9kZXNGcm9tRXZhbHVhdGlvblNldChldmFsdWF0aW9uU2V0KSB7XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgZXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5WYXJpYWJsZU5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZXM7XG59XG5leHBvcnRzLmdldFZhcmlhYmxlTm9kZXNGcm9tRXZhbHVhdGlvblNldCA9IGdldFZhcmlhYmxlTm9kZXNGcm9tRXZhbHVhdGlvblNldDtcbmZ1bmN0aW9uIHRocm93SWZGZWVkRGljdGlvbmFyeUNvbnRhaW5zTkRBcnJheXMoZmVlZERpY3Rpb25hcnkpIHtcbiAgICBPYmplY3Qua2V5cyhmZWVkRGljdGlvbmFyeS5kaWN0KS5mb3JFYWNoKGZ1bmN0aW9uICh0ZW5zb3JJRCkge1xuICAgICAgICBpZiAoZmVlZERpY3Rpb25hcnkuZGljdFsrdGVuc29ySURdLmRhdGEgaW5zdGFuY2VvZiBuZGFycmF5XzEuTkRBcnJheSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFpbmluZyByZXF1aXJlcyBGZWVkRGljdGlvbmFyeSBlbnRyaWVzIHRvIGJlIElucHV0UHJvdmlkZXJzJyArXG4gICAgICAgICAgICAgICAgJ2FuZCBub3QgTkRBcnJheXMuJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMudGhyb3dJZkZlZWREaWN0aW9uYXJ5Q29udGFpbnNOREFycmF5cyA9IHRocm93SWZGZWVkRGljdGlvbmFyeUNvbnRhaW5zTkRBcnJheXM7XG5mdW5jdGlvbiBsb2FkSW5wdXRzRnJvbUZlZWREaWN0aW9uYXJ5VG9UZW5zb3JBcnJheU1hcChiYXRjaEZlZWQsIGFjdGl2YXRpb25zLCBtYXRoKSB7XG4gICAgT2JqZWN0LmtleXMoYmF0Y2hGZWVkLmRpY3QpLmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcklEKSB7XG4gICAgICAgIHZhciBmZWVkRW50cnkgPSBiYXRjaEZlZWQuZGljdFsrdGVuc29ySURdO1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGZlZWRFbnRyeS5kYXRhIGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpIHtcbiAgICAgICAgICAgIGRhdGEgPSBmZWVkRW50cnkuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcm92aWRlciA9IGZlZWRFbnRyeS5kYXRhO1xuICAgICAgICAgICAgZGF0YSA9IHByb3ZpZGVyLmdldE5leHRDb3B5KG1hdGgpO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuYXJyYXlzRXF1YWwoZmVlZEVudHJ5LnRlbnNvci5zaGFwZSwgZGF0YS5zaGFwZSksIFwiRXJyb3IgbG9hZGluZyBGZWVkRW50cnk6IGZlZWRpbmcgTkRBcnJheSBvZiBzaGFwZSBcIiArIGRhdGEuc2hhcGUgKyBcIiBcIiArXG4gICAgICAgICAgICAoXCJkb2VzIG5vdCBtYXRjaCBUZW5zb3IgKGlkOiBcIiArIGZlZWRFbnRyeS50ZW5zb3IuaWQgKyBcIikgc2hhcGU6IFwiKSArXG4gICAgICAgICAgICAoZmVlZEVudHJ5LnRlbnNvci5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIGFjdGl2YXRpb25zLnNldChmZWVkRW50cnkudGVuc29yLCBkYXRhKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubG9hZElucHV0c0Zyb21GZWVkRGljdGlvbmFyeVRvVGVuc29yQXJyYXlNYXAgPSBsb2FkSW5wdXRzRnJvbUZlZWREaWN0aW9uYXJ5VG9UZW5zb3JBcnJheU1hcDtcbmZ1bmN0aW9uIHJlbGVhc2VGZWVkRGljdGlvbmFyeUlucHV0c0Zyb21UZW5zb3JBcnJheU1hcChiYXRjaEZlZWQsIGFjdGl2YXRpb25zLCBtYXRoKSB7XG4gICAgT2JqZWN0LmtleXMoYmF0Y2hGZWVkLmRpY3QpLmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcklEKSB7XG4gICAgICAgIHZhciBmZWVkRW50cnkgPSBiYXRjaEZlZWQuZGljdFsrdGVuc29ySURdO1xuICAgICAgICBpZiAoIShmZWVkRW50cnkuZGF0YSBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5KSkge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gZmVlZEVudHJ5LmRhdGE7XG4gICAgICAgICAgICB2YXIgZmVlZEVudHJ5QXJyYXkgPSBhY3RpdmF0aW9ucy5nZXQoZmVlZEVudHJ5LnRlbnNvcik7XG4gICAgICAgICAgICBwcm92aWRlci5kaXNwb3NlQ29weShtYXRoLCBmZWVkRW50cnlBcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZhdGlvbnMuZGVsZXRlKGZlZWRFbnRyeS50ZW5zb3IpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5yZWxlYXNlRmVlZERpY3Rpb25hcnlJbnB1dHNGcm9tVGVuc29yQXJyYXlNYXAgPSByZWxlYXNlRmVlZERpY3Rpb25hcnlJbnB1dHNGcm9tVGVuc29yQXJyYXlNYXA7XG5mdW5jdGlvbiByZW1vdmVGZWVkRGljdGlvbmFyeU5vZGVzRnJvbUV2YWx1YXRpb25TZXQoZmVlZERpY3Rpb25hcnksIGV2YWx1YXRpb25TZXQpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBldmFsdWF0aW9uU2V0Lmxlbmd0aCkge1xuICAgICAgICB2YXIgbm9kZSA9IGV2YWx1YXRpb25TZXRbaV07XG4gICAgICAgIGlmIChmZWVkRGljdGlvbmFyeS5kaWN0W25vZGUub3V0cHV0LmlkXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBldmFsdWF0aW9uU2V0LnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMucmVtb3ZlRmVlZERpY3Rpb25hcnlOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0ID0gcmVtb3ZlRmVlZERpY3Rpb25hcnlOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0O1xuZnVuY3Rpb24gZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25PdXRwdXRzKGV2YWx1YXRpb25TZXQsIHRlbnNvckFycmF5TWFwKSB7XG4gICAgZXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghZ3JhcGhfdXRpbC5pc0lucHV0Tm9kZShub2RlKSkge1xuICAgICAgICAgICAgaWYgKCFncmFwaF91dGlsLmlzUGFzc3Rocm91Z2hOb2RlKG5vZGUsIHRlbnNvckFycmF5TWFwKSkge1xuICAgICAgICAgICAgICAgIHRlbnNvckFycmF5TWFwLmRpc3Bvc2VBcnJheShub2RlLm91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW5zb3JBcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uT3V0cHV0cyA9IGRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uT3V0cHV0cztcbmZ1bmN0aW9uIGRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uSW5wdXRHcmFkaWVudHMoZXZhbHVhdGlvblNldCwgZ3JhZGllbnRzKSB7XG4gICAgZXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG5vZGUuaW5wdXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IG5vZGUuaW5wdXRzW2lucHV0TmFtZV07XG4gICAgICAgICAgICBpZiAoZ3JhZGllbnRzLmdldChpbnB1dCwgdHJ1ZSkgIT09IGdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRzLmRpc3Bvc2VBcnJheShpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmFkaWVudHMubnVsbGlmeShpbnB1dCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbklucHV0R3JhZGllbnRzID0gZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25JbnB1dEdyYWRpZW50cztcbmZ1bmN0aW9uIGRpc3Bvc2VUcmFuc2llbnRPcGVyYXRpb25BcnJheXMob3BlcmF0aW9ucywgYWN0aXZhdGlvbnMsIGdyYWRpZW50cykge1xuICAgIG9wZXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG9wLmRpc3Bvc2VUcmFuc2llbnRBcnJheXMoYWN0aXZhdGlvbnMsIGdyYWRpZW50cyk7IH0pO1xufVxuZXhwb3J0cy5kaXNwb3NlVHJhbnNpZW50T3BlcmF0aW9uQXJyYXlzID0gZGlzcG9zZVRyYW5zaWVudE9wZXJhdGlvbkFycmF5cztcbmZ1bmN0aW9uIHRocm93RXJyb3JJZkV2YWx1YXRpb25TZXRDb250YWluc1BsYWNlaG9sZGVyTm9kZXMoZXZhbHVhdGlvblNldCkge1xuICAgIGV2YWx1YXRpb25TZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuUGxhY2Vob2xkZXJOb2RlKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSAnWycgKyBub2RlLm91dHB1dC5zaGFwZS5qb2luKCcsICcpICsgJ10nO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGFjZWhvbGRlciBub2RlIFwiJyArIG5vZGUubmFtZSArICdcIiAnICsgc2hhcGUgK1xuICAgICAgICAgICAgICAgICcgbm90IHByZXNlbnQgaW4gZmVlZCBkaWN0aW9uYXJ5LicpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnRocm93RXJyb3JJZkV2YWx1YXRpb25TZXRDb250YWluc1BsYWNlaG9sZGVyTm9kZXMgPSB0aHJvd0Vycm9ySWZFdmFsdWF0aW9uU2V0Q29udGFpbnNQbGFjZWhvbGRlck5vZGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Vzc2lvbl91dGlsLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/session_util.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph/tensor_array_map.js":
/*!*******************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph/tensor_array_map.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TensorArrayMapBase = (function () {\n    function TensorArrayMapBase() {\n        this.dict = {};\n    }\n    TensorArrayMapBase.prototype.get = function (tensor, skipChecks) {\n        if (skipChecks === void 0) { skipChecks = false; }\n        if (!skipChecks && this.dict[tensor.id] === undefined) {\n            throw new Error('tensor ' + tensor.id + ' not in array map.');\n        }\n        var nda = this.dict[tensor.id];\n        if (!skipChecks && nda === null) {\n            throw new Error('tensor ' + tensor.id + ' has null array.');\n        }\n        return nda;\n    };\n    TensorArrayMapBase.prototype.delete = function (tensor) {\n        delete this.dict[tensor.id];\n    };\n    TensorArrayMapBase.prototype.nullify = function (tensor) {\n        this.dict[tensor.id] = null;\n    };\n    TensorArrayMapBase.prototype.disposeArray = function (tensor) {\n        if (this.dict[tensor.id] === undefined) {\n            return;\n        }\n        var nda = this.dict[tensor.id];\n        if (nda === null) {\n            return;\n        }\n        nda.dispose();\n        this.dict[tensor.id] = null;\n    };\n    TensorArrayMapBase.prototype.size = function () {\n        return Object.keys(this.dict).length;\n    };\n    TensorArrayMapBase.prototype.dispose = function () {\n        var _this = this;\n        Object.keys(this.dict).forEach(function (tensorID) {\n            var nda = _this.dict[+tensorID];\n            if (nda) {\n                nda.dispose();\n            }\n        });\n        this.dict = {};\n    };\n    TensorArrayMapBase.prototype.hasNullArray = function (tensor) {\n        if (this.dict[tensor.id] === undefined) {\n            throw new Error('tensor ' + tensor.id + ' not in array map.');\n        }\n        return this.dict[tensor.id] === null;\n    };\n    return TensorArrayMapBase;\n}());\nexports.TensorArrayMapBase = TensorArrayMapBase;\nvar TensorArrayMap = (function (_super) {\n    __extends(TensorArrayMap, _super);\n    function TensorArrayMap() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TensorArrayMap.prototype.set = function (tensor, array) {\n        this.dict[tensor.id] = array;\n    };\n    return TensorArrayMap;\n}(TensorArrayMapBase));\nexports.TensorArrayMap = TensorArrayMap;\nvar SummedTensorArrayMap = (function (_super) {\n    __extends(SummedTensorArrayMap, _super);\n    function SummedTensorArrayMap(math) {\n        var _this = _super.call(this) || this;\n        _this.math = math;\n        return _this;\n    }\n    SummedTensorArrayMap.prototype.add = function (tensor, array) {\n        if (this.dict[tensor.id] == null) {\n            this.dict[tensor.id] = this.math.keep(array);\n        }\n        else {\n            var oldValue = this.get(tensor);\n            var newValue = this.math.keep(this.math.addStrict(oldValue, array));\n            this.dict[tensor.id] = newValue;\n            oldValue.dispose();\n        }\n    };\n    return SummedTensorArrayMap;\n}(TensorArrayMapBase));\nexports.SummedTensorArrayMap = SummedTensorArrayMap;\n//# sourceMappingURL=tensor_array_map.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL3RlbnNvcl9hcnJheV9tYXAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoL3RlbnNvcl9hcnJheV9tYXAuanM/MTI5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRlbnNvckFycmF5TWFwQmFzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVuc29yQXJyYXlNYXBCYXNlKCkge1xuICAgICAgICB0aGlzLmRpY3QgPSB7fTtcbiAgICB9XG4gICAgVGVuc29yQXJyYXlNYXBCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodGVuc29yLCBza2lwQ2hlY2tzKSB7XG4gICAgICAgIGlmIChza2lwQ2hlY2tzID09PSB2b2lkIDApIHsgc2tpcENoZWNrcyA9IGZhbHNlOyB9XG4gICAgICAgIGlmICghc2tpcENoZWNrcyAmJiB0aGlzLmRpY3RbdGVuc29yLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RlbnNvciAnICsgdGVuc29yLmlkICsgJyBub3QgaW4gYXJyYXkgbWFwLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZGEgPSB0aGlzLmRpY3RbdGVuc29yLmlkXTtcbiAgICAgICAgaWYgKCFza2lwQ2hlY2tzICYmIG5kYSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZW5zb3IgJyArIHRlbnNvci5pZCArICcgaGFzIG51bGwgYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYTtcbiAgICB9O1xuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICBkZWxldGUgdGhpcy5kaWN0W3RlbnNvci5pZF07XG4gICAgfTtcbiAgICBUZW5zb3JBcnJheU1hcEJhc2UucHJvdG90eXBlLm51bGxpZnkgPSBmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgICAgIHRoaXMuZGljdFt0ZW5zb3IuaWRdID0gbnVsbDtcbiAgICB9O1xuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUuZGlzcG9zZUFycmF5ID0gZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICBpZiAodGhpcy5kaWN0W3RlbnNvci5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZGEgPSB0aGlzLmRpY3RbdGVuc29yLmlkXTtcbiAgICAgICAgaWYgKG5kYSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5kYS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZGljdFt0ZW5zb3IuaWRdID0gbnVsbDtcbiAgICB9O1xuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGljdCkubGVuZ3RoO1xuICAgIH07XG4gICAgVGVuc29yQXJyYXlNYXBCYXNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmRpY3QpLmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcklEKSB7XG4gICAgICAgICAgICB2YXIgbmRhID0gX3RoaXMuZGljdFsrdGVuc29ySURdO1xuICAgICAgICAgICAgaWYgKG5kYSkge1xuICAgICAgICAgICAgICAgIG5kYS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRpY3QgPSB7fTtcbiAgICB9O1xuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUuaGFzTnVsbEFycmF5ID0gZnVuY3Rpb24gKHRlbnNvcikge1xuICAgICAgICBpZiAodGhpcy5kaWN0W3RlbnNvci5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZW5zb3IgJyArIHRlbnNvci5pZCArICcgbm90IGluIGFycmF5IG1hcC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kaWN0W3RlbnNvci5pZF0gPT09IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gVGVuc29yQXJyYXlNYXBCYXNlO1xufSgpKTtcbmV4cG9ydHMuVGVuc29yQXJyYXlNYXBCYXNlID0gVGVuc29yQXJyYXlNYXBCYXNlO1xudmFyIFRlbnNvckFycmF5TWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGVuc29yQXJyYXlNYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGVuc29yQXJyYXlNYXAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGVuc29yQXJyYXlNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0ZW5zb3IsIGFycmF5KSB7XG4gICAgICAgIHRoaXMuZGljdFt0ZW5zb3IuaWRdID0gYXJyYXk7XG4gICAgfTtcbiAgICByZXR1cm4gVGVuc29yQXJyYXlNYXA7XG59KFRlbnNvckFycmF5TWFwQmFzZSkpO1xuZXhwb3J0cy5UZW5zb3JBcnJheU1hcCA9IFRlbnNvckFycmF5TWFwO1xudmFyIFN1bW1lZFRlbnNvckFycmF5TWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3VtbWVkVGVuc29yQXJyYXlNYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3VtbWVkVGVuc29yQXJyYXlNYXAobWF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tYXRoID0gbWF0aDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdW1tZWRUZW5zb3JBcnJheU1hcC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRlbnNvciwgYXJyYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZGljdFt0ZW5zb3IuaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGljdFt0ZW5zb3IuaWRdID0gdGhpcy5tYXRoLmtlZXAoYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5nZXQodGVuc29yKTtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMubWF0aC5rZWVwKHRoaXMubWF0aC5hZGRTdHJpY3Qob2xkVmFsdWUsIGFycmF5KSk7XG4gICAgICAgICAgICB0aGlzLmRpY3RbdGVuc29yLmlkXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgb2xkVmFsdWUuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3VtbWVkVGVuc29yQXJyYXlNYXA7XG59KFRlbnNvckFycmF5TWFwQmFzZSkpO1xuZXhwb3J0cy5TdW1tZWRUZW5zb3JBcnJheU1hcCA9IFN1bW1lZFRlbnNvckFycmF5TWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVuc29yX2FycmF5X21hcC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph/tensor_array_map.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/graph_runner.js":
/*!*********************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/graph_runner.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar session_1 = __webpack_require__(/*! ./graph/session */ \"./node_modules/deeplearn/dist/src/graph/session.js\");\nvar ndarray_1 = __webpack_require__(/*! ./math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar DEFAULT_EVAL_INTERVAL_MS = 1500;\nvar DEFAULT_COST_INTERVAL_MS = 500;\nvar DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS = 3000;\nvar MetricReduction;\n(function (MetricReduction) {\n    MetricReduction[MetricReduction[\"SUM\"] = 0] = \"SUM\";\n    MetricReduction[MetricReduction[\"MEAN\"] = 1] = \"MEAN\";\n})(MetricReduction = exports.MetricReduction || (exports.MetricReduction = {}));\nvar GraphRunner = (function () {\n    function GraphRunner(math, session, eventObserver) {\n        this.math = math;\n        this.session = session;\n        this.eventObserver = eventObserver;\n        this.lastCostTimestamp = 0;\n        this.lastEvalTimestamp = 0;\n        this.totalIdleTimeMs = 0;\n        this.resetStatistics();\n        this.zeroScalar = ndarray_1.Scalar.new(0);\n    }\n    GraphRunner.prototype.resetStatistics = function () {\n        this.totalBatchesTrained = 0;\n        this.totalIdleTimeMs = 0;\n        this.lastStopTimestamp = null;\n    };\n    GraphRunner.prototype.train = function (costTensor, trainFeedEntries, batchSize, optimizer, numBatches, metricTensor, metricFeedEntries, metricBatchSize, metricReduction, evalIntervalMs, costIntervalMs) {\n        if (metricReduction === void 0) { metricReduction = MetricReduction.MEAN; }\n        if (evalIntervalMs === void 0) { evalIntervalMs = DEFAULT_EVAL_INTERVAL_MS; }\n        if (costIntervalMs === void 0) { costIntervalMs = DEFAULT_COST_INTERVAL_MS; }\n        this.costTensor = costTensor;\n        this.trainFeedEntries = trainFeedEntries;\n        this.metricTensor = metricTensor;\n        this.metricFeedEntries = metricFeedEntries;\n        if (metricBatchSize != null && this.metricBatchSize !== metricBatchSize) {\n            if (this.metricBatchSizeScalar != null) {\n                this.metricBatchSizeScalar.dispose();\n            }\n            this.metricBatchSizeScalar = ndarray_1.Scalar.new(metricBatchSize);\n        }\n        this.metricBatchSize = metricBatchSize;\n        this.metricReduction = metricReduction;\n        this.batchSize = batchSize;\n        this.optimizer = optimizer;\n        this.metricIntervalMs = evalIntervalMs;\n        this.costIntervalMs = costIntervalMs;\n        this.currentTrainLoopNumBatches = numBatches;\n        this.batchesTrainedThisRun = 0;\n        this.isTraining = true;\n        this.trainStartTimestamp = performance.now();\n        this.trainNetwork();\n    };\n    GraphRunner.prototype.stopTraining = function () {\n        this.isTraining = false;\n        this.lastStopTimestamp = performance.now();\n    };\n    GraphRunner.prototype.resumeTraining = function () {\n        this.isTraining = true;\n        if (this.lastStopTimestamp != null) {\n            this.totalIdleTimeMs += performance.now() - this.lastStopTimestamp;\n        }\n        this.trainNetwork();\n    };\n    GraphRunner.prototype.trainNetwork = function () {\n        var _this = this;\n        if (this.batchesTrainedThisRun === this.currentTrainLoopNumBatches) {\n            this.stopTraining();\n        }\n        if (!this.isTraining) {\n            if (this.eventObserver.doneTrainingCallback != null) {\n                this.eventObserver.doneTrainingCallback();\n            }\n            return;\n        }\n        var start = performance.now();\n        var shouldComputeCost = this.eventObserver.avgCostCallback != null &&\n            (start - this.lastCostTimestamp > this.costIntervalMs);\n        if (shouldComputeCost) {\n            this.lastCostTimestamp = start;\n        }\n        var costReduction = shouldComputeCost ? session_1.CostReduction.MEAN : session_1.CostReduction.NONE;\n        this.math.scope(function (keep) {\n            var avgCost = _this.session.train(_this.costTensor, _this.trainFeedEntries, _this.batchSize, _this.optimizer, costReduction);\n            if (shouldComputeCost) {\n                var trainTime = performance.now() - start;\n                _this.eventObserver.avgCostCallback(avgCost);\n                if (_this.eventObserver.trainExamplesPerSecCallback != null) {\n                    var examplesPerSec = (_this.batchSize * 1000 / trainTime);\n                    _this.eventObserver.trainExamplesPerSecCallback(examplesPerSec);\n                }\n            }\n            if (_this.eventObserver.metricCallback != null &&\n                _this.metricFeedEntries != null &&\n                start - _this.lastEvalTimestamp > _this.metricIntervalMs) {\n                _this.lastEvalTimestamp = start;\n                if (_this.lastComputedMetric != null) {\n                    _this.lastComputedMetric.dispose();\n                }\n                _this.lastComputedMetric = _this.computeMetric();\n                _this.eventObserver.metricCallback(_this.lastComputedMetric);\n            }\n            if (_this.eventObserver.totalTimeCallback != null) {\n                _this.eventObserver.totalTimeCallback((start - _this.trainStartTimestamp) / 1000);\n            }\n            _this.batchesTrainedThisRun++;\n            _this.totalBatchesTrained++;\n            if (_this.eventObserver.batchesTrainedCallback != null) {\n                _this.eventObserver.batchesTrainedCallback(_this.totalBatchesTrained);\n            }\n        });\n        requestAnimationFrame(function () { return _this.trainNetwork(); });\n    };\n    GraphRunner.prototype.infer = function (inferenceTensor, inferenceFeedEntries, inferenceExampleIntervalMs, inferenceExampleCount, numPasses) {\n        var _this = this;\n        if (inferenceExampleIntervalMs === void 0) { inferenceExampleIntervalMs = DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS; }\n        if (inferenceExampleCount === void 0) { inferenceExampleCount = 5; }\n        if (this.eventObserver.inferenceExamplesCallback == null &&\n            this.eventObserver.inferenceExamplesPerSecCallback == null) {\n            throw new Error('Cannot start inference loop, no inference example or ' +\n                'examples/sec observer provided.');\n        }\n        for (var i = 0; i < inferenceFeedEntries.length; i++) {\n            var feedEntry = inferenceFeedEntries[i];\n            if (feedEntry.data instanceof ndarray_1.NDArray) {\n                throw new Error('Cannot start inference on the model runner with feed entries of ' +\n                    'type NDArray. Please use InputProviders.');\n            }\n        }\n        this.inferenceExampleIntervalMs = inferenceExampleIntervalMs;\n        this.inferenceTensor = inferenceTensor;\n        this.inferenceFeedEntries = inferenceFeedEntries;\n        this.inferenceExampleCount = inferenceExampleCount;\n        this.currentInferenceLoopNumPasses = numPasses;\n        if (!this.isInferring) {\n            this.inferencePassesThisRun = 0;\n            requestAnimationFrame(function () { return _this.inferNetwork(); });\n        }\n        this.isInferring = true;\n    };\n    GraphRunner.prototype.inferNetwork = function () {\n        var _this = this;\n        if (!this.isInferring ||\n            this.inferencePassesThisRun === this.currentInferenceLoopNumPasses) {\n            return;\n        }\n        this.math.scope(function (keep, track) {\n            var feeds = [];\n            var inferenceValues = [];\n            var start = performance.now();\n            for (var i = 0; i < _this.inferenceExampleCount; i++) {\n                var ndarrayFeedEntries = [];\n                for (var j = 0; j < _this.inferenceFeedEntries.length; j++) {\n                    var feedEntry = _this.inferenceFeedEntries[j];\n                    ndarrayFeedEntries.push({\n                        tensor: feedEntry.tensor,\n                        data: track(feedEntry.data.getNextCopy(_this.math))\n                    });\n                }\n                feeds.push(ndarrayFeedEntries);\n                inferenceValues.push(_this.session.eval(_this.inferenceTensor, ndarrayFeedEntries));\n            }\n            if (_this.eventObserver.inferenceExamplesPerSecCallback != null) {\n                inferenceValues[inferenceValues.length - 1].getValues();\n                var inferenceExamplesPerSecTime = performance.now() - start;\n                var examplesPerSec = (_this.inferenceExampleCount * 1000 / inferenceExamplesPerSecTime);\n                _this.eventObserver.inferenceExamplesPerSecCallback(examplesPerSec);\n            }\n            if (_this.eventObserver.inferenceExamplesCallback != null) {\n                _this.eventObserver.inferenceExamplesCallback(feeds, inferenceValues);\n            }\n            _this.inferencePassesThisRun++;\n        });\n        this.lastInferTimeoutID = window.setTimeout(function () { return _this.inferNetwork(); }, this.inferenceExampleIntervalMs);\n    };\n    GraphRunner.prototype.stopInferring = function () {\n        this.isInferring = false;\n        window.clearTimeout(this.lastInferTimeoutID);\n    };\n    GraphRunner.prototype.isInferenceRunning = function () {\n        return this.isInferring;\n    };\n    GraphRunner.prototype.computeMetric = function () {\n        var _this = this;\n        if (this.metricFeedEntries == null) {\n            throw new Error('Cannot compute metric, no metric FeedEntries provided.');\n        }\n        var metric = this.zeroScalar;\n        return this.math.scope(function (keep) {\n            for (var i = 0; i < _this.metricBatchSize; i++) {\n                var metricValue = _this.session.eval(_this.metricTensor, _this.metricFeedEntries);\n                metric = _this.math.add(metric, metricValue);\n            }\n            if (_this.metricReduction === MetricReduction.MEAN) {\n                metric = _this.math.divide(metric, _this.metricBatchSizeScalar);\n            }\n            return metric;\n        });\n    };\n    GraphRunner.prototype.getTotalBatchesTrained = function () {\n        return this.totalBatchesTrained;\n    };\n    GraphRunner.prototype.getLastComputedMetric = function () {\n        return this.lastComputedMetric;\n    };\n    GraphRunner.prototype.setMath = function (math) {\n        this.math = math;\n    };\n    GraphRunner.prototype.setSession = function (session) {\n        this.session = session;\n    };\n    GraphRunner.prototype.setInferenceTensor = function (inferenceTensor) {\n        this.inferenceTensor = inferenceTensor;\n    };\n    GraphRunner.prototype.setInferenceExampleCount = function (inferenceExampleCount) {\n        this.inferenceExampleCount = inferenceExampleCount;\n    };\n    return GraphRunner;\n}());\nexports.GraphRunner = GraphRunner;\n//# sourceMappingURL=graph_runner.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2dyYXBoX3J1bm5lci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvZ3JhcGhfcnVubmVyLmpzPzE0ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2Vzc2lvbl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvc2Vzc2lvblwiKTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi9tYXRoL25kYXJyYXlcIik7XG52YXIgREVGQVVMVF9FVkFMX0lOVEVSVkFMX01TID0gMTUwMDtcbnZhciBERUZBVUxUX0NPU1RfSU5URVJWQUxfTVMgPSA1MDA7XG52YXIgREVGQVVMVF9JTkZFUkVOQ0VfRVhBTVBMRV9JTlRFUlZBTF9NUyA9IDMwMDA7XG52YXIgTWV0cmljUmVkdWN0aW9uO1xuKGZ1bmN0aW9uIChNZXRyaWNSZWR1Y3Rpb24pIHtcbiAgICBNZXRyaWNSZWR1Y3Rpb25bTWV0cmljUmVkdWN0aW9uW1wiU1VNXCJdID0gMF0gPSBcIlNVTVwiO1xuICAgIE1ldHJpY1JlZHVjdGlvbltNZXRyaWNSZWR1Y3Rpb25bXCJNRUFOXCJdID0gMV0gPSBcIk1FQU5cIjtcbn0pKE1ldHJpY1JlZHVjdGlvbiA9IGV4cG9ydHMuTWV0cmljUmVkdWN0aW9uIHx8IChleHBvcnRzLk1ldHJpY1JlZHVjdGlvbiA9IHt9KSk7XG52YXIgR3JhcGhSdW5uZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyYXBoUnVubmVyKG1hdGgsIHNlc3Npb24sIGV2ZW50T2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5tYXRoID0gbWF0aDtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5ldmVudE9ic2VydmVyID0gZXZlbnRPYnNlcnZlcjtcbiAgICAgICAgdGhpcy5sYXN0Q29zdFRpbWVzdGFtcCA9IDA7XG4gICAgICAgIHRoaXMubGFzdEV2YWxUaW1lc3RhbXAgPSAwO1xuICAgICAgICB0aGlzLnRvdGFsSWRsZVRpbWVNcyA9IDA7XG4gICAgICAgIHRoaXMucmVzZXRTdGF0aXN0aWNzKCk7XG4gICAgICAgIHRoaXMuemVyb1NjYWxhciA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KDApO1xuICAgIH1cbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUucmVzZXRTdGF0aXN0aWNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRvdGFsQmF0Y2hlc1RyYWluZWQgPSAwO1xuICAgICAgICB0aGlzLnRvdGFsSWRsZVRpbWVNcyA9IDA7XG4gICAgICAgIHRoaXMubGFzdFN0b3BUaW1lc3RhbXAgPSBudWxsO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnRyYWluID0gZnVuY3Rpb24gKGNvc3RUZW5zb3IsIHRyYWluRmVlZEVudHJpZXMsIGJhdGNoU2l6ZSwgb3B0aW1pemVyLCBudW1CYXRjaGVzLCBtZXRyaWNUZW5zb3IsIG1ldHJpY0ZlZWRFbnRyaWVzLCBtZXRyaWNCYXRjaFNpemUsIG1ldHJpY1JlZHVjdGlvbiwgZXZhbEludGVydmFsTXMsIGNvc3RJbnRlcnZhbE1zKSB7XG4gICAgICAgIGlmIChtZXRyaWNSZWR1Y3Rpb24gPT09IHZvaWQgMCkgeyBtZXRyaWNSZWR1Y3Rpb24gPSBNZXRyaWNSZWR1Y3Rpb24uTUVBTjsgfVxuICAgICAgICBpZiAoZXZhbEludGVydmFsTXMgPT09IHZvaWQgMCkgeyBldmFsSW50ZXJ2YWxNcyA9IERFRkFVTFRfRVZBTF9JTlRFUlZBTF9NUzsgfVxuICAgICAgICBpZiAoY29zdEludGVydmFsTXMgPT09IHZvaWQgMCkgeyBjb3N0SW50ZXJ2YWxNcyA9IERFRkFVTFRfQ09TVF9JTlRFUlZBTF9NUzsgfVxuICAgICAgICB0aGlzLmNvc3RUZW5zb3IgPSBjb3N0VGVuc29yO1xuICAgICAgICB0aGlzLnRyYWluRmVlZEVudHJpZXMgPSB0cmFpbkZlZWRFbnRyaWVzO1xuICAgICAgICB0aGlzLm1ldHJpY1RlbnNvciA9IG1ldHJpY1RlbnNvcjtcbiAgICAgICAgdGhpcy5tZXRyaWNGZWVkRW50cmllcyA9IG1ldHJpY0ZlZWRFbnRyaWVzO1xuICAgICAgICBpZiAobWV0cmljQmF0Y2hTaXplICE9IG51bGwgJiYgdGhpcy5tZXRyaWNCYXRjaFNpemUgIT09IG1ldHJpY0JhdGNoU2l6ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWV0cmljQmF0Y2hTaXplU2NhbGFyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldHJpY0JhdGNoU2l6ZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1ldHJpY0JhdGNoU2l6ZVNjYWxhciA9IG5kYXJyYXlfMS5TY2FsYXIubmV3KG1ldHJpY0JhdGNoU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXRyaWNCYXRjaFNpemUgPSBtZXRyaWNCYXRjaFNpemU7XG4gICAgICAgIHRoaXMubWV0cmljUmVkdWN0aW9uID0gbWV0cmljUmVkdWN0aW9uO1xuICAgICAgICB0aGlzLmJhdGNoU2l6ZSA9IGJhdGNoU2l6ZTtcbiAgICAgICAgdGhpcy5vcHRpbWl6ZXIgPSBvcHRpbWl6ZXI7XG4gICAgICAgIHRoaXMubWV0cmljSW50ZXJ2YWxNcyA9IGV2YWxJbnRlcnZhbE1zO1xuICAgICAgICB0aGlzLmNvc3RJbnRlcnZhbE1zID0gY29zdEludGVydmFsTXM7XG4gICAgICAgIHRoaXMuY3VycmVudFRyYWluTG9vcE51bUJhdGNoZXMgPSBudW1CYXRjaGVzO1xuICAgICAgICB0aGlzLmJhdGNoZXNUcmFpbmVkVGhpc1J1biA9IDA7XG4gICAgICAgIHRoaXMuaXNUcmFpbmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudHJhaW5TdGFydFRpbWVzdGFtcCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB0aGlzLnRyYWluTmV0d29yaygpO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnN0b3BUcmFpbmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc1RyYWluaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdFN0b3BUaW1lc3RhbXAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5yZXN1bWVUcmFpbmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc1RyYWluaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMubGFzdFN0b3BUaW1lc3RhbXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50b3RhbElkbGVUaW1lTXMgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLmxhc3RTdG9wVGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhaW5OZXR3b3JrKCk7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUudHJhaW5OZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5iYXRjaGVzVHJhaW5lZFRoaXNSdW4gPT09IHRoaXMuY3VycmVudFRyYWluTG9vcE51bUJhdGNoZXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFRyYWluaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzVHJhaW5pbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50T2JzZXJ2ZXIuZG9uZVRyYWluaW5nQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlci5kb25lVHJhaW5pbmdDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICB2YXIgc2hvdWxkQ29tcHV0ZUNvc3QgPSB0aGlzLmV2ZW50T2JzZXJ2ZXIuYXZnQ29zdENhbGxiYWNrICE9IG51bGwgJiZcbiAgICAgICAgICAgIChzdGFydCAtIHRoaXMubGFzdENvc3RUaW1lc3RhbXAgPiB0aGlzLmNvc3RJbnRlcnZhbE1zKTtcbiAgICAgICAgaWYgKHNob3VsZENvbXB1dGVDb3N0KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb3N0VGltZXN0YW1wID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvc3RSZWR1Y3Rpb24gPSBzaG91bGRDb21wdXRlQ29zdCA/IHNlc3Npb25fMS5Db3N0UmVkdWN0aW9uLk1FQU4gOiBzZXNzaW9uXzEuQ29zdFJlZHVjdGlvbi5OT05FO1xuICAgICAgICB0aGlzLm1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXApIHtcbiAgICAgICAgICAgIHZhciBhdmdDb3N0ID0gX3RoaXMuc2Vzc2lvbi50cmFpbihfdGhpcy5jb3N0VGVuc29yLCBfdGhpcy50cmFpbkZlZWRFbnRyaWVzLCBfdGhpcy5iYXRjaFNpemUsIF90aGlzLm9wdGltaXplciwgY29zdFJlZHVjdGlvbik7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQ29tcHV0ZUNvc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhaW5UaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydDtcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudE9ic2VydmVyLmF2Z0Nvc3RDYWxsYmFjayhhdmdDb3N0KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZXZlbnRPYnNlcnZlci50cmFpbkV4YW1wbGVzUGVyU2VjQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXhhbXBsZXNQZXJTZWMgPSAoX3RoaXMuYmF0Y2hTaXplICogMTAwMCAvIHRyYWluVGltZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50T2JzZXJ2ZXIudHJhaW5FeGFtcGxlc1BlclNlY0NhbGxiYWNrKGV4YW1wbGVzUGVyU2VjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuZXZlbnRPYnNlcnZlci5tZXRyaWNDYWxsYmFjayAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgX3RoaXMubWV0cmljRmVlZEVudHJpZXMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHN0YXJ0IC0gX3RoaXMubGFzdEV2YWxUaW1lc3RhbXAgPiBfdGhpcy5tZXRyaWNJbnRlcnZhbE1zKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubGFzdEV2YWxUaW1lc3RhbXAgPSBzdGFydDtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGFzdENvbXB1dGVkTWV0cmljICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGFzdENvbXB1dGVkTWV0cmljLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMubGFzdENvbXB1dGVkTWV0cmljID0gX3RoaXMuY29tcHV0ZU1ldHJpYygpO1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50T2JzZXJ2ZXIubWV0cmljQ2FsbGJhY2soX3RoaXMubGFzdENvbXB1dGVkTWV0cmljKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5ldmVudE9ic2VydmVyLnRvdGFsVGltZUNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudE9ic2VydmVyLnRvdGFsVGltZUNhbGxiYWNrKChzdGFydCAtIF90aGlzLnRyYWluU3RhcnRUaW1lc3RhbXApIC8gMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5iYXRjaGVzVHJhaW5lZFRoaXNSdW4rKztcbiAgICAgICAgICAgIF90aGlzLnRvdGFsQmF0Y2hlc1RyYWluZWQrKztcbiAgICAgICAgICAgIGlmIChfdGhpcy5ldmVudE9ic2VydmVyLmJhdGNoZXNUcmFpbmVkQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50T2JzZXJ2ZXIuYmF0Y2hlc1RyYWluZWRDYWxsYmFjayhfdGhpcy50b3RhbEJhdGNoZXNUcmFpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50cmFpbk5ldHdvcmsoKTsgfSk7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuaW5mZXIgPSBmdW5jdGlvbiAoaW5mZXJlbmNlVGVuc29yLCBpbmZlcmVuY2VGZWVkRW50cmllcywgaW5mZXJlbmNlRXhhbXBsZUludGVydmFsTXMsIGluZmVyZW5jZUV4YW1wbGVDb3VudCwgbnVtUGFzc2VzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChpbmZlcmVuY2VFeGFtcGxlSW50ZXJ2YWxNcyA9PT0gdm9pZCAwKSB7IGluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zID0gREVGQVVMVF9JTkZFUkVOQ0VfRVhBTVBMRV9JTlRFUlZBTF9NUzsgfVxuICAgICAgICBpZiAoaW5mZXJlbmNlRXhhbXBsZUNvdW50ID09PSB2b2lkIDApIHsgaW5mZXJlbmNlRXhhbXBsZUNvdW50ID0gNTsgfVxuICAgICAgICBpZiAodGhpcy5ldmVudE9ic2VydmVyLmluZmVyZW5jZUV4YW1wbGVzQ2FsbGJhY2sgPT0gbnVsbCAmJlxuICAgICAgICAgICAgdGhpcy5ldmVudE9ic2VydmVyLmluZmVyZW5jZUV4YW1wbGVzUGVyU2VjQ2FsbGJhY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3RhcnQgaW5mZXJlbmNlIGxvb3AsIG5vIGluZmVyZW5jZSBleGFtcGxlIG9yICcgK1xuICAgICAgICAgICAgICAgICdleGFtcGxlcy9zZWMgb2JzZXJ2ZXIgcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmZlcmVuY2VGZWVkRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZlZWRFbnRyeSA9IGluZmVyZW5jZUZlZWRFbnRyaWVzW2ldO1xuICAgICAgICAgICAgaWYgKGZlZWRFbnRyeS5kYXRhIGluc3RhbmNlb2YgbmRhcnJheV8xLk5EQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzdGFydCBpbmZlcmVuY2Ugb24gdGhlIG1vZGVsIHJ1bm5lciB3aXRoIGZlZWQgZW50cmllcyBvZiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUgTkRBcnJheS4gUGxlYXNlIHVzZSBJbnB1dFByb3ZpZGVycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zID0gaW5mZXJlbmNlRXhhbXBsZUludGVydmFsTXM7XG4gICAgICAgIHRoaXMuaW5mZXJlbmNlVGVuc29yID0gaW5mZXJlbmNlVGVuc29yO1xuICAgICAgICB0aGlzLmluZmVyZW5jZUZlZWRFbnRyaWVzID0gaW5mZXJlbmNlRmVlZEVudHJpZXM7XG4gICAgICAgIHRoaXMuaW5mZXJlbmNlRXhhbXBsZUNvdW50ID0gaW5mZXJlbmNlRXhhbXBsZUNvdW50O1xuICAgICAgICB0aGlzLmN1cnJlbnRJbmZlcmVuY2VMb29wTnVtUGFzc2VzID0gbnVtUGFzc2VzO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbmZlcnJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5mZXJlbmNlUGFzc2VzVGhpc1J1biA9IDA7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaW5mZXJOZXR3b3JrKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNJbmZlcnJpbmcgPSB0cnVlO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLmluZmVyTmV0d29yayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5mZXJyaW5nIHx8XG4gICAgICAgICAgICB0aGlzLmluZmVyZW5jZVBhc3Nlc1RoaXNSdW4gPT09IHRoaXMuY3VycmVudEluZmVyZW5jZUxvb3BOdW1QYXNzZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hdGguc2NvcGUoZnVuY3Rpb24gKGtlZXAsIHRyYWNrKSB7XG4gICAgICAgICAgICB2YXIgZmVlZHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBpbmZlcmVuY2VWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5pbmZlcmVuY2VFeGFtcGxlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBuZGFycmF5RmVlZEVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF90aGlzLmluZmVyZW5jZUZlZWRFbnRyaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmZWVkRW50cnkgPSBfdGhpcy5pbmZlcmVuY2VGZWVkRW50cmllc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgbmRhcnJheUZlZWRFbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVuc29yOiBmZWVkRW50cnkudGVuc29yLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdHJhY2soZmVlZEVudHJ5LmRhdGEuZ2V0TmV4dENvcHkoX3RoaXMubWF0aCkpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmZWVkcy5wdXNoKG5kYXJyYXlGZWVkRW50cmllcyk7XG4gICAgICAgICAgICAgICAgaW5mZXJlbmNlVmFsdWVzLnB1c2goX3RoaXMuc2Vzc2lvbi5ldmFsKF90aGlzLmluZmVyZW5jZVRlbnNvciwgbmRhcnJheUZlZWRFbnRyaWVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuZXZlbnRPYnNlcnZlci5pbmZlcmVuY2VFeGFtcGxlc1BlclNlY0NhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmZlcmVuY2VWYWx1ZXNbaW5mZXJlbmNlVmFsdWVzLmxlbmd0aCAtIDFdLmdldFZhbHVlcygpO1xuICAgICAgICAgICAgICAgIHZhciBpbmZlcmVuY2VFeGFtcGxlc1BlclNlY1RpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIHZhciBleGFtcGxlc1BlclNlYyA9IChfdGhpcy5pbmZlcmVuY2VFeGFtcGxlQ291bnQgKiAxMDAwIC8gaW5mZXJlbmNlRXhhbXBsZXNQZXJTZWNUaW1lKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudE9ic2VydmVyLmluZmVyZW5jZUV4YW1wbGVzUGVyU2VjQ2FsbGJhY2soZXhhbXBsZXNQZXJTZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRPYnNlcnZlci5pbmZlcmVuY2VFeGFtcGxlc0NhbGxiYWNrKGZlZWRzLCBpbmZlcmVuY2VWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuaW5mZXJlbmNlUGFzc2VzVGhpc1J1bisrO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sYXN0SW5mZXJUaW1lb3V0SUQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5pbmZlck5ldHdvcmsoKTsgfSwgdGhpcy5pbmZlcmVuY2VFeGFtcGxlSW50ZXJ2YWxNcyk7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuc3RvcEluZmVycmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0luZmVycmluZyA9IGZhbHNlO1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMubGFzdEluZmVyVGltZW91dElEKTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5pc0luZmVyZW5jZVJ1bm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSW5mZXJyaW5nO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLmNvbXB1dGVNZXRyaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLm1ldHJpY0ZlZWRFbnRyaWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXB1dGUgbWV0cmljLCBubyBtZXRyaWMgRmVlZEVudHJpZXMgcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1ldHJpYyA9IHRoaXMuemVyb1NjYWxhcjtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0aC5zY29wZShmdW5jdGlvbiAoa2VlcCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5tZXRyaWNCYXRjaFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBtZXRyaWNWYWx1ZSA9IF90aGlzLnNlc3Npb24uZXZhbChfdGhpcy5tZXRyaWNUZW5zb3IsIF90aGlzLm1ldHJpY0ZlZWRFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICBtZXRyaWMgPSBfdGhpcy5tYXRoLmFkZChtZXRyaWMsIG1ldHJpY1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5tZXRyaWNSZWR1Y3Rpb24gPT09IE1ldHJpY1JlZHVjdGlvbi5NRUFOKSB7XG4gICAgICAgICAgICAgICAgbWV0cmljID0gX3RoaXMubWF0aC5kaXZpZGUobWV0cmljLCBfdGhpcy5tZXRyaWNCYXRjaFNpemVTY2FsYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ldHJpYztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuZ2V0VG90YWxCYXRjaGVzVHJhaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG90YWxCYXRjaGVzVHJhaW5lZDtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5nZXRMYXN0Q29tcHV0ZWRNZXRyaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDb21wdXRlZE1ldHJpYztcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5zZXRNYXRoID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgICAgICAgdGhpcy5tYXRoID0gbWF0aDtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5zZXRTZXNzaW9uID0gZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5zZXRJbmZlcmVuY2VUZW5zb3IgPSBmdW5jdGlvbiAoaW5mZXJlbmNlVGVuc29yKSB7XG4gICAgICAgIHRoaXMuaW5mZXJlbmNlVGVuc29yID0gaW5mZXJlbmNlVGVuc29yO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnNldEluZmVyZW5jZUV4YW1wbGVDb3VudCA9IGZ1bmN0aW9uIChpbmZlcmVuY2VFeGFtcGxlQ291bnQpIHtcbiAgICAgICAgdGhpcy5pbmZlcmVuY2VFeGFtcGxlQ291bnQgPSBpbmZlcmVuY2VFeGFtcGxlQ291bnQ7XG4gICAgfTtcbiAgICByZXR1cm4gR3JhcGhSdW5uZXI7XG59KCkpO1xuZXhwb3J0cy5HcmFwaFJ1bm5lciA9IEdyYXBoUnVubmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JhcGhfcnVubmVyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/graph_runner.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar xhr_dataset = __webpack_require__(/*! ./data/xhr-dataset */ \"./node_modules/deeplearn/dist/src/data/xhr-dataset.js\");\nexports.xhr_dataset = xhr_dataset;\nvar environment = __webpack_require__(/*! ./environment */ \"./node_modules/deeplearn/dist/src/environment.js\");\nexports.environment = environment;\nvar conv_util = __webpack_require__(/*! ./math/conv_util */ \"./node_modules/deeplearn/dist/src/math/conv_util.js\");\nexports.conv_util = conv_util;\nvar gpgpu_util = __webpack_require__(/*! ./math/webgl/gpgpu_util */ \"./node_modules/deeplearn/dist/src/math/webgl/gpgpu_util.js\");\nexports.gpgpu_util = gpgpu_util;\nvar render_ndarray_gpu_util = __webpack_require__(/*! ./math/webgl/render_ndarray_gpu_util */ \"./node_modules/deeplearn/dist/src/math/webgl/render_ndarray_gpu_util.js\");\nexports.render_ndarray_gpu_util = render_ndarray_gpu_util;\nvar webgl_util = __webpack_require__(/*! ./math/webgl/webgl_util */ \"./node_modules/deeplearn/dist/src/math/webgl/webgl_util.js\");\nexports.webgl_util = webgl_util;\nvar test_util = __webpack_require__(/*! ./test_util */ \"./node_modules/deeplearn/dist/src/test_util.js\");\nexports.test_util = test_util;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/deeplearn/dist/src/util.js\");\nexports.util = util;\nvar checkpoint_loader_1 = __webpack_require__(/*! ./data/checkpoint_loader */ \"./node_modules/deeplearn/dist/src/data/checkpoint_loader.js\");\nexports.CheckpointLoader = checkpoint_loader_1.CheckpointLoader;\nvar dataset_1 = __webpack_require__(/*! ./data/dataset */ \"./node_modules/deeplearn/dist/src/data/dataset.js\");\nexports.InMemoryDataset = dataset_1.InMemoryDataset;\nvar input_provider_1 = __webpack_require__(/*! ./data/input_provider */ \"./node_modules/deeplearn/dist/src/data/input_provider.js\");\nexports.InCPUMemoryShuffledInputProviderBuilder = input_provider_1.InCPUMemoryShuffledInputProviderBuilder;\nexports.InGPUMemoryShuffledInputProviderBuilder = input_provider_1.InGPUMemoryShuffledInputProviderBuilder;\nvar xhr_dataset_1 = __webpack_require__(/*! ./data/xhr-dataset */ \"./node_modules/deeplearn/dist/src/data/xhr-dataset.js\");\nexports.XhrDataset = xhr_dataset_1.XhrDataset;\nvar environment_1 = __webpack_require__(/*! ./environment */ \"./node_modules/deeplearn/dist/src/environment.js\");\nexports.ENV = environment_1.ENV;\nexports.Environment = environment_1.Environment;\nvar graph_1 = __webpack_require__(/*! ./graph/graph */ \"./node_modules/deeplearn/dist/src/graph/graph.js\");\nexports.Graph = graph_1.Graph;\nexports.Tensor = graph_1.Tensor;\nvar adadelta_optimizer_1 = __webpack_require__(/*! ./graph/optimizers/adadelta_optimizer */ \"./node_modules/deeplearn/dist/src/graph/optimizers/adadelta_optimizer.js\");\nexports.AdadeltaOptimizer = adadelta_optimizer_1.AdadeltaOptimizer;\nvar adagrad_optimizer_1 = __webpack_require__(/*! ./graph/optimizers/adagrad_optimizer */ \"./node_modules/deeplearn/dist/src/graph/optimizers/adagrad_optimizer.js\");\nexports.AdagradOptimizer = adagrad_optimizer_1.AdagradOptimizer;\nvar momentum_optimizer_1 = __webpack_require__(/*! ./graph/optimizers/momentum_optimizer */ \"./node_modules/deeplearn/dist/src/graph/optimizers/momentum_optimizer.js\");\nexports.MomentumOptimizer = momentum_optimizer_1.MomentumOptimizer;\nvar optimizer_1 = __webpack_require__(/*! ./graph/optimizers/optimizer */ \"./node_modules/deeplearn/dist/src/graph/optimizers/optimizer.js\");\nexports.Optimizer = optimizer_1.Optimizer;\nvar rmsprop_optimizer_1 = __webpack_require__(/*! ./graph/optimizers/rmsprop_optimizer */ \"./node_modules/deeplearn/dist/src/graph/optimizers/rmsprop_optimizer.js\");\nexports.RMSPropOptimizer = rmsprop_optimizer_1.RMSPropOptimizer;\nvar sgd_optimizer_1 = __webpack_require__(/*! ./graph/optimizers/sgd_optimizer */ \"./node_modules/deeplearn/dist/src/graph/optimizers/sgd_optimizer.js\");\nexports.SGDOptimizer = sgd_optimizer_1.SGDOptimizer;\nvar adam_optimizer_1 = __webpack_require__(/*! ./graph/optimizers/adam_optimizer */ \"./node_modules/deeplearn/dist/src/graph/optimizers/adam_optimizer.js\");\nexports.AdamOptimizer = adam_optimizer_1.AdamOptimizer;\nvar session_1 = __webpack_require__(/*! ./graph/session */ \"./node_modules/deeplearn/dist/src/graph/session.js\");\nexports.CostReduction = session_1.CostReduction;\nexports.Session = session_1.Session;\nvar graph_runner_1 = __webpack_require__(/*! ./graph_runner */ \"./node_modules/deeplearn/dist/src/graph_runner.js\");\nexports.GraphRunner = graph_runner_1.GraphRunner;\nexports.MetricReduction = graph_runner_1.MetricReduction;\nvar initializers_1 = __webpack_require__(/*! ./initializers */ \"./node_modules/deeplearn/dist/src/initializers.js\");\nexports.ConstantInitializer = initializers_1.ConstantInitializer;\nexports.NDArrayInitializer = initializers_1.NDArrayInitializer;\nexports.OnesInitializer = initializers_1.OnesInitializer;\nexports.RandomNormalInitializer = initializers_1.RandomNormalInitializer;\nexports.RandomTruncatedNormalInitializer = initializers_1.RandomTruncatedNormalInitializer;\nexports.RandomUniformInitializer = initializers_1.RandomUniformInitializer;\nexports.VarianceScalingInitializer = initializers_1.VarianceScalingInitializer;\nexports.ZerosInitializer = initializers_1.ZerosInitializer;\nvar math_1 = __webpack_require__(/*! ./math/math */ \"./node_modules/deeplearn/dist/src/math/math.js\");\nexports.MatrixOrientation = math_1.MatrixOrientation;\nexports.NDArrayMath = math_1.NDArrayMath;\nvar math_cpu_1 = __webpack_require__(/*! ./math/math_cpu */ \"./node_modules/deeplearn/dist/src/math/math_cpu.js\");\nexports.NDArrayMathCPU = math_cpu_1.NDArrayMathCPU;\nvar math_gpu_1 = __webpack_require__(/*! ./math/math_gpu */ \"./node_modules/deeplearn/dist/src/math/math_gpu.js\");\nexports.NDArrayMathGPU = math_gpu_1.NDArrayMathGPU;\nvar ndarray_1 = __webpack_require__(/*! ./math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nexports.Array1D = ndarray_1.Array1D;\nexports.Array2D = ndarray_1.Array2D;\nexports.Array3D = ndarray_1.Array3D;\nexports.Array4D = ndarray_1.Array4D;\nexports.NDArray = ndarray_1.NDArray;\nexports.Scalar = ndarray_1.Scalar;\nvar gpgpu_context_1 = __webpack_require__(/*! ./math/webgl/gpgpu_context */ \"./node_modules/deeplearn/dist/src/math/webgl/gpgpu_context.js\");\nexports.GPGPUContext = gpgpu_context_1.GPGPUContext;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9pbmRleC5qcz9hOTQwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHhocl9kYXRhc2V0ID0gcmVxdWlyZShcIi4vZGF0YS94aHItZGF0YXNldFwiKTtcbmV4cG9ydHMueGhyX2RhdGFzZXQgPSB4aHJfZGF0YXNldDtcbnZhciBlbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xuZXhwb3J0cy5lbnZpcm9ubWVudCA9IGVudmlyb25tZW50O1xudmFyIGNvbnZfdXRpbCA9IHJlcXVpcmUoXCIuL21hdGgvY29udl91dGlsXCIpO1xuZXhwb3J0cy5jb252X3V0aWwgPSBjb252X3V0aWw7XG52YXIgZ3BncHVfdXRpbCA9IHJlcXVpcmUoXCIuL21hdGgvd2ViZ2wvZ3BncHVfdXRpbFwiKTtcbmV4cG9ydHMuZ3BncHVfdXRpbCA9IGdwZ3B1X3V0aWw7XG52YXIgcmVuZGVyX25kYXJyYXlfZ3B1X3V0aWwgPSByZXF1aXJlKFwiLi9tYXRoL3dlYmdsL3JlbmRlcl9uZGFycmF5X2dwdV91dGlsXCIpO1xuZXhwb3J0cy5yZW5kZXJfbmRhcnJheV9ncHVfdXRpbCA9IHJlbmRlcl9uZGFycmF5X2dwdV91dGlsO1xudmFyIHdlYmdsX3V0aWwgPSByZXF1aXJlKFwiLi9tYXRoL3dlYmdsL3dlYmdsX3V0aWxcIik7XG5leHBvcnRzLndlYmdsX3V0aWwgPSB3ZWJnbF91dGlsO1xudmFyIHRlc3RfdXRpbCA9IHJlcXVpcmUoXCIuL3Rlc3RfdXRpbFwiKTtcbmV4cG9ydHMudGVzdF91dGlsID0gdGVzdF91dGlsO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZXhwb3J0cy51dGlsID0gdXRpbDtcbnZhciBjaGVja3BvaW50X2xvYWRlcl8xID0gcmVxdWlyZShcIi4vZGF0YS9jaGVja3BvaW50X2xvYWRlclwiKTtcbmV4cG9ydHMuQ2hlY2twb2ludExvYWRlciA9IGNoZWNrcG9pbnRfbG9hZGVyXzEuQ2hlY2twb2ludExvYWRlcjtcbnZhciBkYXRhc2V0XzEgPSByZXF1aXJlKFwiLi9kYXRhL2RhdGFzZXRcIik7XG5leHBvcnRzLkluTWVtb3J5RGF0YXNldCA9IGRhdGFzZXRfMS5Jbk1lbW9yeURhdGFzZXQ7XG52YXIgaW5wdXRfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL2RhdGEvaW5wdXRfcHJvdmlkZXJcIik7XG5leHBvcnRzLkluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciA9IGlucHV0X3Byb3ZpZGVyXzEuSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyO1xuZXhwb3J0cy5JbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSBpbnB1dF9wcm92aWRlcl8xLkluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcjtcbnZhciB4aHJfZGF0YXNldF8xID0gcmVxdWlyZShcIi4vZGF0YS94aHItZGF0YXNldFwiKTtcbmV4cG9ydHMuWGhyRGF0YXNldCA9IHhocl9kYXRhc2V0XzEuWGhyRGF0YXNldDtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRcIik7XG5leHBvcnRzLkVOViA9IGVudmlyb25tZW50XzEuRU5WO1xuZXhwb3J0cy5FbnZpcm9ubWVudCA9IGVudmlyb25tZW50XzEuRW52aXJvbm1lbnQ7XG52YXIgZ3JhcGhfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL2dyYXBoXCIpO1xuZXhwb3J0cy5HcmFwaCA9IGdyYXBoXzEuR3JhcGg7XG5leHBvcnRzLlRlbnNvciA9IGdyYXBoXzEuVGVuc29yO1xudmFyIGFkYWRlbHRhX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvb3B0aW1pemVycy9hZGFkZWx0YV9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLkFkYWRlbHRhT3B0aW1pemVyID0gYWRhZGVsdGFfb3B0aW1pemVyXzEuQWRhZGVsdGFPcHRpbWl6ZXI7XG52YXIgYWRhZ3JhZF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL29wdGltaXplcnMvYWRhZ3JhZF9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLkFkYWdyYWRPcHRpbWl6ZXIgPSBhZGFncmFkX29wdGltaXplcl8xLkFkYWdyYWRPcHRpbWl6ZXI7XG52YXIgbW9tZW50dW1fb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9vcHRpbWl6ZXJzL21vbWVudHVtX29wdGltaXplclwiKTtcbmV4cG9ydHMuTW9tZW50dW1PcHRpbWl6ZXIgPSBtb21lbnR1bV9vcHRpbWl6ZXJfMS5Nb21lbnR1bU9wdGltaXplcjtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL29wdGltaXplcnMvb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5PcHRpbWl6ZXIgPSBvcHRpbWl6ZXJfMS5PcHRpbWl6ZXI7XG52YXIgcm1zcHJvcF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL29wdGltaXplcnMvcm1zcHJvcF9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLlJNU1Byb3BPcHRpbWl6ZXIgPSBybXNwcm9wX29wdGltaXplcl8xLlJNU1Byb3BPcHRpbWl6ZXI7XG52YXIgc2dkX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vZ3JhcGgvb3B0aW1pemVycy9zZ2Rfb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5TR0RPcHRpbWl6ZXIgPSBzZ2Rfb3B0aW1pemVyXzEuU0dET3B0aW1pemVyO1xudmFyIGFkYW1fb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9vcHRpbWl6ZXJzL2FkYW1fb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5BZGFtT3B0aW1pemVyID0gYWRhbV9vcHRpbWl6ZXJfMS5BZGFtT3B0aW1pemVyO1xudmFyIHNlc3Npb25fMSA9IHJlcXVpcmUoXCIuL2dyYXBoL3Nlc3Npb25cIik7XG5leHBvcnRzLkNvc3RSZWR1Y3Rpb24gPSBzZXNzaW9uXzEuQ29zdFJlZHVjdGlvbjtcbmV4cG9ydHMuU2Vzc2lvbiA9IHNlc3Npb25fMS5TZXNzaW9uO1xudmFyIGdyYXBoX3J1bm5lcl8xID0gcmVxdWlyZShcIi4vZ3JhcGhfcnVubmVyXCIpO1xuZXhwb3J0cy5HcmFwaFJ1bm5lciA9IGdyYXBoX3J1bm5lcl8xLkdyYXBoUnVubmVyO1xuZXhwb3J0cy5NZXRyaWNSZWR1Y3Rpb24gPSBncmFwaF9ydW5uZXJfMS5NZXRyaWNSZWR1Y3Rpb247XG52YXIgaW5pdGlhbGl6ZXJzXzEgPSByZXF1aXJlKFwiLi9pbml0aWFsaXplcnNcIik7XG5leHBvcnRzLkNvbnN0YW50SW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5Db25zdGFudEluaXRpYWxpemVyO1xuZXhwb3J0cy5OREFycmF5SW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5OREFycmF5SW5pdGlhbGl6ZXI7XG5leHBvcnRzLk9uZXNJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLk9uZXNJbml0aWFsaXplcjtcbmV4cG9ydHMuUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5SYW5kb21Ob3JtYWxJbml0aWFsaXplcjtcbmV4cG9ydHMuUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5SYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplcjtcbmV4cG9ydHMuUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyO1xuZXhwb3J0cy5WYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLlZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyO1xuZXhwb3J0cy5aZXJvc0luaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuWmVyb3NJbml0aWFsaXplcjtcbnZhciBtYXRoXzEgPSByZXF1aXJlKFwiLi9tYXRoL21hdGhcIik7XG5leHBvcnRzLk1hdHJpeE9yaWVudGF0aW9uID0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uO1xuZXhwb3J0cy5OREFycmF5TWF0aCA9IG1hdGhfMS5OREFycmF5TWF0aDtcbnZhciBtYXRoX2NwdV8xID0gcmVxdWlyZShcIi4vbWF0aC9tYXRoX2NwdVwiKTtcbmV4cG9ydHMuTkRBcnJheU1hdGhDUFUgPSBtYXRoX2NwdV8xLk5EQXJyYXlNYXRoQ1BVO1xudmFyIG1hdGhfZ3B1XzEgPSByZXF1aXJlKFwiLi9tYXRoL21hdGhfZ3B1XCIpO1xuZXhwb3J0cy5OREFycmF5TWF0aEdQVSA9IG1hdGhfZ3B1XzEuTkRBcnJheU1hdGhHUFU7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbWF0aC9uZGFycmF5XCIpO1xuZXhwb3J0cy5BcnJheTFEID0gbmRhcnJheV8xLkFycmF5MUQ7XG5leHBvcnRzLkFycmF5MkQgPSBuZGFycmF5XzEuQXJyYXkyRDtcbmV4cG9ydHMuQXJyYXkzRCA9IG5kYXJyYXlfMS5BcnJheTNEO1xuZXhwb3J0cy5BcnJheTREID0gbmRhcnJheV8xLkFycmF5NEQ7XG5leHBvcnRzLk5EQXJyYXkgPSBuZGFycmF5XzEuTkRBcnJheTtcbmV4cG9ydHMuU2NhbGFyID0gbmRhcnJheV8xLlNjYWxhcjtcbnZhciBncGdwdV9jb250ZXh0XzEgPSByZXF1aXJlKFwiLi9tYXRoL3dlYmdsL2dwZ3B1X2NvbnRleHRcIik7XG5leHBvcnRzLkdQR1BVQ29udGV4dCA9IGdwZ3B1X2NvbnRleHRfMS5HUEdQVUNvbnRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/index.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/initializers.js":
/*!*********************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/initializers.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ./math/ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar VarianceScalingInitializer = (function () {\n    function VarianceScalingInitializer(scale, mode, distribution) {\n        if (scale === void 0) { scale = 1.0; }\n        if (mode === void 0) { mode = 'fan_in'; }\n        if (distribution === void 0) { distribution = 'normal'; }\n        this.scale = scale;\n        this.mode = mode;\n        this.distribution = distribution;\n    }\n    VarianceScalingInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {\n        var n = 0;\n        if (this.mode === 'fan_in') {\n            n = inputUnits;\n        }\n        else if (this.mode === 'fan_out') {\n            n = outputUnits;\n        }\n        else if (this.mode === 'fan_avg') {\n            n = (inputUnits + outputUnits) / 2;\n        }\n        else {\n            throw new Error('Unexpected mode for variance scaling initializer: ' + this.mode);\n        }\n        if (this.distribution === 'normal') {\n            return ndarray_1.NDArray.randTruncatedNormal(weightsShape, 0.0, Math.sqrt(this.scale / n));\n        }\n        else if (this.distribution === 'uniform') {\n            return ndarray_1.NDArray.randUniform(weightsShape, 0.0, Math.sqrt(3 * this.scale / n));\n        }\n        else {\n            throw new Error('Unexpected distribution for variance scaling initializer: ' +\n                this.distribution);\n        }\n    };\n    return VarianceScalingInitializer;\n}());\nexports.VarianceScalingInitializer = VarianceScalingInitializer;\nvar ZerosInitializer = (function () {\n    function ZerosInitializer() {\n    }\n    ZerosInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {\n        return ndarray_1.NDArray.zeros(weightsShape);\n    };\n    return ZerosInitializer;\n}());\nexports.ZerosInitializer = ZerosInitializer;\nvar OnesInitializer = (function () {\n    function OnesInitializer() {\n    }\n    OnesInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {\n        var values = ndarray_1.NDArray.zeros(weightsShape);\n        values.fill(1);\n        return values;\n    };\n    return OnesInitializer;\n}());\nexports.OnesInitializer = OnesInitializer;\nvar ConstantInitializer = (function () {\n    function ConstantInitializer(value) {\n        if (value === void 0) { value = 0; }\n        this.value = value;\n    }\n    ConstantInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {\n        var values = ndarray_1.NDArray.zeros(weightsShape);\n        values.fill(this.value);\n        return values;\n    };\n    return ConstantInitializer;\n}());\nexports.ConstantInitializer = ConstantInitializer;\nvar NDArrayInitializer = (function () {\n    function NDArrayInitializer(ndarray) {\n        this.ndarray = ndarray;\n    }\n    NDArrayInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {\n        return this.ndarray;\n    };\n    return NDArrayInitializer;\n}());\nexports.NDArrayInitializer = NDArrayInitializer;\nvar RandomNormalInitializer = (function () {\n    function RandomNormalInitializer(mean, stdev) {\n        if (mean === void 0) { mean = 0; }\n        if (stdev === void 0) { stdev = .05; }\n        this.mean = mean;\n        this.stdev = stdev;\n    }\n    RandomNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {\n        return ndarray_1.NDArray.randNormal(weightsShape, this.mean, this.stdev);\n    };\n    return RandomNormalInitializer;\n}());\nexports.RandomNormalInitializer = RandomNormalInitializer;\nvar RandomTruncatedNormalInitializer = (function () {\n    function RandomTruncatedNormalInitializer(mean, stdev) {\n        if (mean === void 0) { mean = 0; }\n        if (stdev === void 0) { stdev = .05; }\n        this.mean = mean;\n        this.stdev = stdev;\n    }\n    RandomTruncatedNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {\n        return ndarray_1.NDArray.randTruncatedNormal(weightsShape, this.mean, this.stdev);\n    };\n    return RandomTruncatedNormalInitializer;\n}());\nexports.RandomTruncatedNormalInitializer = RandomTruncatedNormalInitializer;\nvar RandomUniformInitializer = (function () {\n    function RandomUniformInitializer(minval, maxval) {\n        if (minval === void 0) { minval = -.05; }\n        if (maxval === void 0) { maxval = .05; }\n        this.minval = minval;\n        this.maxval = maxval;\n    }\n    RandomUniformInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {\n        return ndarray_1.NDArray.randUniform(weightsShape, this.minval, this.maxval);\n    };\n    return RandomUniformInitializer;\n}());\nexports.RandomUniformInitializer = RandomUniformInitializer;\n//# sourceMappingURL=initializers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL2luaXRpYWxpemVycy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvaW5pdGlhbGl6ZXJzLmpzPzI5NzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbWF0aC9uZGFycmF5XCIpO1xudmFyIFZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplcihzY2FsZSwgbW9kZSwgZGlzdHJpYnV0aW9uKSB7XG4gICAgICAgIGlmIChzY2FsZSA9PT0gdm9pZCAwKSB7IHNjYWxlID0gMS4wOyB9XG4gICAgICAgIGlmIChtb2RlID09PSB2b2lkIDApIHsgbW9kZSA9ICdmYW5faW4nOyB9XG4gICAgICAgIGlmIChkaXN0cmlidXRpb24gPT09IHZvaWQgMCkgeyBkaXN0cmlidXRpb24gPSAnbm9ybWFsJzsgfVxuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uID0gZGlzdHJpYnV0aW9uO1xuICAgIH1cbiAgICBWYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3ZWlnaHRzU2hhcGUsIGlucHV0VW5pdHMsIG91dHB1dFVuaXRzKSB7XG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2Zhbl9pbicpIHtcbiAgICAgICAgICAgIG4gPSBpbnB1dFVuaXRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gJ2Zhbl9vdXQnKSB7XG4gICAgICAgICAgICBuID0gb3V0cHV0VW5pdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tb2RlID09PSAnZmFuX2F2ZycpIHtcbiAgICAgICAgICAgIG4gPSAoaW5wdXRVbml0cyArIG91dHB1dFVuaXRzKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgbW9kZSBmb3IgdmFyaWFuY2Ugc2NhbGluZyBpbml0aWFsaXplcjogJyArIHRoaXMubW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlzdHJpYnV0aW9uID09PSAnbm9ybWFsJykge1xuICAgICAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5LnJhbmRUcnVuY2F0ZWROb3JtYWwod2VpZ2h0c1NoYXBlLCAwLjAsIE1hdGguc3FydCh0aGlzLnNjYWxlIC8gbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGlzdHJpYnV0aW9uID09PSAndW5pZm9ybScpIHtcbiAgICAgICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5yYW5kVW5pZm9ybSh3ZWlnaHRzU2hhcGUsIDAuMCwgTWF0aC5zcXJ0KDMgKiB0aGlzLnNjYWxlIC8gbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGRpc3RyaWJ1dGlvbiBmb3IgdmFyaWFuY2Ugc2NhbGluZyBpbml0aWFsaXplcjogJyArXG4gICAgICAgICAgICAgICAgdGhpcy5kaXN0cmlidXRpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5WYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplciA9IFZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyO1xudmFyIFplcm9zSW5pdGlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFplcm9zSW5pdGlhbGl6ZXIoKSB7XG4gICAgfVxuICAgIFplcm9zSW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkuemVyb3Mod2VpZ2h0c1NoYXBlKTtcbiAgICB9O1xuICAgIHJldHVybiBaZXJvc0luaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuWmVyb3NJbml0aWFsaXplciA9IFplcm9zSW5pdGlhbGl6ZXI7XG52YXIgT25lc0luaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPbmVzSW5pdGlhbGl6ZXIoKSB7XG4gICAgfVxuICAgIE9uZXNJbml0aWFsaXplci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3ZWlnaHRzU2hhcGUsIGlucHV0VW5pdHMsIG91dHB1dFVuaXRzKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5XzEuTkRBcnJheS56ZXJvcyh3ZWlnaHRzU2hhcGUpO1xuICAgICAgICB2YWx1ZXMuZmlsbCgxKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuICAgIHJldHVybiBPbmVzSW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5PbmVzSW5pdGlhbGl6ZXIgPSBPbmVzSW5pdGlhbGl6ZXI7XG52YXIgQ29uc3RhbnRJbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uc3RhbnRJbml0aWFsaXplcih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IDA7IH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBDb25zdGFudEluaXRpYWxpemVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHdlaWdodHNTaGFwZSwgaW5wdXRVbml0cywgb3V0cHV0VW5pdHMpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXlfMS5OREFycmF5Lnplcm9zKHdlaWdodHNTaGFwZSk7XG4gICAgICAgIHZhbHVlcy5maWxsKHRoaXMudmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnN0YW50SW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5Db25zdGFudEluaXRpYWxpemVyID0gQ29uc3RhbnRJbml0aWFsaXplcjtcbnZhciBOREFycmF5SW5pdGlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5EQXJyYXlJbml0aWFsaXplcihuZGFycmF5KSB7XG4gICAgICAgIHRoaXMubmRhcnJheSA9IG5kYXJyYXk7XG4gICAgfVxuICAgIE5EQXJyYXlJbml0aWFsaXplci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3ZWlnaHRzU2hhcGUsIGlucHV0VW5pdHMsIG91dHB1dFVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5kYXJyYXk7XG4gICAgfTtcbiAgICByZXR1cm4gTkRBcnJheUluaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuTkRBcnJheUluaXRpYWxpemVyID0gTkRBcnJheUluaXRpYWxpemVyO1xudmFyIFJhbmRvbU5vcm1hbEluaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSYW5kb21Ob3JtYWxJbml0aWFsaXplcihtZWFuLCBzdGRldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGRldiA9PT0gdm9pZCAwKSB7IHN0ZGV2ID0gLjA1OyB9XG4gICAgICAgIHRoaXMubWVhbiA9IG1lYW47XG4gICAgICAgIHRoaXMuc3RkZXYgPSBzdGRldjtcbiAgICB9XG4gICAgUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkucmFuZE5vcm1hbCh3ZWlnaHRzU2hhcGUsIHRoaXMubWVhbiwgdGhpcy5zdGRldik7XG4gICAgfTtcbiAgICByZXR1cm4gUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5SYW5kb21Ob3JtYWxJbml0aWFsaXplciA9IFJhbmRvbU5vcm1hbEluaXRpYWxpemVyO1xudmFyIFJhbmRvbVRydW5jYXRlZE5vcm1hbEluaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplcihtZWFuLCBzdGRldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGRldiA9PT0gdm9pZCAwKSB7IHN0ZGV2ID0gLjA1OyB9XG4gICAgICAgIHRoaXMubWVhbiA9IG1lYW47XG4gICAgICAgIHRoaXMuc3RkZXYgPSBzdGRldjtcbiAgICB9XG4gICAgUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkucmFuZFRydW5jYXRlZE5vcm1hbCh3ZWlnaHRzU2hhcGUsIHRoaXMubWVhbiwgdGhpcy5zdGRldik7XG4gICAgfTtcbiAgICByZXR1cm4gUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5SYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplciA9IFJhbmRvbVRydW5jYXRlZE5vcm1hbEluaXRpYWxpemVyO1xudmFyIFJhbmRvbVVuaWZvcm1Jbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyKG1pbnZhbCwgbWF4dmFsKSB7XG4gICAgICAgIGlmIChtaW52YWwgPT09IHZvaWQgMCkgeyBtaW52YWwgPSAtLjA1OyB9XG4gICAgICAgIGlmIChtYXh2YWwgPT09IHZvaWQgMCkgeyBtYXh2YWwgPSAuMDU7IH1cbiAgICAgICAgdGhpcy5taW52YWwgPSBtaW52YWw7XG4gICAgICAgIHRoaXMubWF4dmFsID0gbWF4dmFsO1xuICAgIH1cbiAgICBSYW5kb21Vbmlmb3JtSW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkucmFuZFVuaWZvcm0od2VpZ2h0c1NoYXBlLCB0aGlzLm1pbnZhbCwgdGhpcy5tYXh2YWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFJhbmRvbVVuaWZvcm1Jbml0aWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLlJhbmRvbVVuaWZvcm1Jbml0aWFsaXplciA9IFJhbmRvbVVuaWZvcm1Jbml0aWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXRpYWxpemVycy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/initializers.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/activation_functions.js":
/*!**********************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/activation_functions.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ./ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar TanHFunc = (function () {\n    function TanHFunc() {\n    }\n    TanHFunc.prototype.output = function (math, x) {\n        return math.scope(function () {\n            return math.tanh(x);\n        });\n    };\n    TanHFunc.prototype.der = function (math, x, y) {\n        return math.scope(function () {\n            var ySquared = math.elementWiseMul(y, y);\n            return math.scalarMinusArray(ndarray_1.Scalar.ONE, ySquared);\n        });\n    };\n    return TanHFunc;\n}());\nexports.TanHFunc = TanHFunc;\nvar ReLUFunc = (function () {\n    function ReLUFunc() {\n    }\n    ReLUFunc.prototype.output = function (math, x) {\n        return math.scope(function () {\n            return math.relu(x);\n        });\n    };\n    ReLUFunc.prototype.der = function (math, x, y) {\n        return math.scope(function () {\n            return math.step(x);\n        });\n    };\n    return ReLUFunc;\n}());\nexports.ReLUFunc = ReLUFunc;\nvar SigmoidFunc = (function () {\n    function SigmoidFunc() {\n    }\n    SigmoidFunc.prototype.output = function (math, x) {\n        return math.scope(function () {\n            return math.sigmoid(x);\n        });\n    };\n    SigmoidFunc.prototype.der = function (math, x, y) {\n        return math.scope(function () {\n            var ySquared = math.elementWiseMul(y, y);\n            return math.subStrict(y, ySquared);\n        });\n    };\n    return SigmoidFunc;\n}());\nexports.SigmoidFunc = SigmoidFunc;\nvar SquareFunc = (function () {\n    function SquareFunc() {\n    }\n    SquareFunc.prototype.output = function (math, x) {\n        return math.scope(function () {\n            return math.elementWiseMul(x, x);\n        });\n    };\n    SquareFunc.prototype.der = function (math, x, y) {\n        return math.scope(function () {\n            return math.scalarTimesArray(ndarray_1.Scalar.TWO, x);\n        });\n    };\n    return SquareFunc;\n}());\nexports.SquareFunc = SquareFunc;\n//# sourceMappingURL=activation_functions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvYWN0aXZhdGlvbl9mdW5jdGlvbnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvYWN0aXZhdGlvbl9mdW5jdGlvbnMuanM/YTY4MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi9uZGFycmF5XCIpO1xudmFyIFRhbkhGdW5jID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYW5IRnVuYygpIHtcbiAgICB9XG4gICAgVGFuSEZ1bmMucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uIChtYXRoLCB4KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLnRhbmgoeCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGFuSEZ1bmMucHJvdG90eXBlLmRlciA9IGZ1bmN0aW9uIChtYXRoLCB4LCB5KSB7XG4gICAgICAgIHJldHVybiBtYXRoLnNjb3BlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB5U3F1YXJlZCA9IG1hdGguZWxlbWVudFdpc2VNdWwoeSwgeSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5zY2FsYXJNaW51c0FycmF5KG5kYXJyYXlfMS5TY2FsYXIuT05FLCB5U3F1YXJlZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRhbkhGdW5jO1xufSgpKTtcbmV4cG9ydHMuVGFuSEZ1bmMgPSBUYW5IRnVuYztcbnZhciBSZUxVRnVuYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVMVUZ1bmMoKSB7XG4gICAgfVxuICAgIFJlTFVGdW5jLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbiAobWF0aCwgeCkge1xuICAgICAgICByZXR1cm4gbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5yZWx1KHgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlTFVGdW5jLnByb3RvdHlwZS5kZXIgPSBmdW5jdGlvbiAobWF0aCwgeCwgeSkge1xuICAgICAgICByZXR1cm4gbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5zdGVwKHgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSZUxVRnVuYztcbn0oKSk7XG5leHBvcnRzLlJlTFVGdW5jID0gUmVMVUZ1bmM7XG52YXIgU2lnbW9pZEZ1bmMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpZ21vaWRGdW5jKCkge1xuICAgIH1cbiAgICBTaWdtb2lkRnVuYy5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24gKG1hdGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGguc2lnbW9pZCh4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTaWdtb2lkRnVuYy5wcm90b3R5cGUuZGVyID0gZnVuY3Rpb24gKG1hdGgsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHlTcXVhcmVkID0gbWF0aC5lbGVtZW50V2lzZU11bCh5LCB5KTtcbiAgICAgICAgICAgIHJldHVybiBtYXRoLnN1YlN0cmljdCh5LCB5U3F1YXJlZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFNpZ21vaWRGdW5jO1xufSgpKTtcbmV4cG9ydHMuU2lnbW9pZEZ1bmMgPSBTaWdtb2lkRnVuYztcbnZhciBTcXVhcmVGdW5jID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcXVhcmVGdW5jKCkge1xuICAgIH1cbiAgICBTcXVhcmVGdW5jLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbiAobWF0aCwgeCkge1xuICAgICAgICByZXR1cm4gbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5lbGVtZW50V2lzZU11bCh4LCB4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTcXVhcmVGdW5jLnByb3RvdHlwZS5kZXIgPSBmdW5jdGlvbiAobWF0aCwgeCwgeSkge1xuICAgICAgICByZXR1cm4gbWF0aC5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0aC5zY2FsYXJUaW1lc0FycmF5KG5kYXJyYXlfMS5TY2FsYXIuVFdPLCB4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3F1YXJlRnVuYztcbn0oKSk7XG5leHBvcnRzLlNxdWFyZUZ1bmMgPSBTcXVhcmVGdW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZhdGlvbl9mdW5jdGlvbnMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/activation_functions.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/concat_util.js":
/*!*************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/concat_util.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nfunction assertParams(aShape, bShape, axis) {\n    var aRank = aShape.length;\n    var bRank = bShape.length;\n    util.assert(aShape.length === bShape.length, \"Error in concat\" + aRank + \"D: rank of x1 (\" + aRank + \") and x2 (\" + bRank + \") \" +\n        \"must be the same.\");\n    util.assert(axis >= 0 && axis < aRank, \"Error in concat\" + aRank + \"D: axis must be \" +\n        (\"between 0 and \" + (aRank - 1) + \".\"));\n    for (var i = 0; i < aRank; i++) {\n        util.assert((i === axis) || (aShape[i] === bShape[i]), \"Error in concat\" + aRank + \"D: Shape (\" + aShape + \") does not match \" +\n            (\"(\" + bShape + \") along the non-concatenated axis \" + i + \".\"));\n    }\n}\nexports.assertParams = assertParams;\nfunction computeOutShape(x1Shape, x2Shape, axis) {\n    util.assert(x1Shape.length === x2Shape.length, 'x1 and x2 should have the same rank.');\n    var outputShape = x1Shape.slice();\n    outputShape[axis] += x2Shape[axis];\n    return outputShape;\n}\nexports.computeOutShape = computeOutShape;\n//# sourceMappingURL=concat_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvY29uY2F0X3V0aWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvY29uY2F0X3V0aWwuanM/YTY4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBhc3NlcnRQYXJhbXMoYVNoYXBlLCBiU2hhcGUsIGF4aXMpIHtcbiAgICB2YXIgYVJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICAgIHZhciBiUmFuayA9IGJTaGFwZS5sZW5ndGg7XG4gICAgdXRpbC5hc3NlcnQoYVNoYXBlLmxlbmd0aCA9PT0gYlNoYXBlLmxlbmd0aCwgXCJFcnJvciBpbiBjb25jYXRcIiArIGFSYW5rICsgXCJEOiByYW5rIG9mIHgxIChcIiArIGFSYW5rICsgXCIpIGFuZCB4MiAoXCIgKyBiUmFuayArIFwiKSBcIiArXG4gICAgICAgIFwibXVzdCBiZSB0aGUgc2FtZS5cIik7XG4gICAgdXRpbC5hc3NlcnQoYXhpcyA+PSAwICYmIGF4aXMgPCBhUmFuaywgXCJFcnJvciBpbiBjb25jYXRcIiArIGFSYW5rICsgXCJEOiBheGlzIG11c3QgYmUgXCIgK1xuICAgICAgICAoXCJiZXR3ZWVuIDAgYW5kIFwiICsgKGFSYW5rIC0gMSkgKyBcIi5cIikpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYVJhbms7IGkrKykge1xuICAgICAgICB1dGlsLmFzc2VydCgoaSA9PT0gYXhpcykgfHwgKGFTaGFwZVtpXSA9PT0gYlNoYXBlW2ldKSwgXCJFcnJvciBpbiBjb25jYXRcIiArIGFSYW5rICsgXCJEOiBTaGFwZSAoXCIgKyBhU2hhcGUgKyBcIikgZG9lcyBub3QgbWF0Y2ggXCIgK1xuICAgICAgICAgICAgKFwiKFwiICsgYlNoYXBlICsgXCIpIGFsb25nIHRoZSBub24tY29uY2F0ZW5hdGVkIGF4aXMgXCIgKyBpICsgXCIuXCIpKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydFBhcmFtcyA9IGFzc2VydFBhcmFtcztcbmZ1bmN0aW9uIGNvbXB1dGVPdXRTaGFwZSh4MVNoYXBlLCB4MlNoYXBlLCBheGlzKSB7XG4gICAgdXRpbC5hc3NlcnQoeDFTaGFwZS5sZW5ndGggPT09IHgyU2hhcGUubGVuZ3RoLCAneDEgYW5kIHgyIHNob3VsZCBoYXZlIHRoZSBzYW1lIHJhbmsuJyk7XG4gICAgdmFyIG91dHB1dFNoYXBlID0geDFTaGFwZS5zbGljZSgpO1xuICAgIG91dHB1dFNoYXBlW2F4aXNdICs9IHgyU2hhcGVbYXhpc107XG4gICAgcmV0dXJuIG91dHB1dFNoYXBlO1xufVxuZXhwb3J0cy5jb21wdXRlT3V0U2hhcGUgPSBjb21wdXRlT3V0U2hhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXRfdXRpbC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/concat_util.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/conv_util.js":
/*!***********************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/conv_util.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nfunction computeConvInfo(inShape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad) {\n    if (typeof pad === 'number') {\n        var outShape_1 = computeOutputShape3D(inShape, filterHeight, outDepth, strideHeight, pad);\n        return {\n            inShape: inShape,\n            outShape: outShape_1,\n            padInfo: { top: pad, bottom: pad, left: pad, right: pad },\n            strideHeight: strideHeight,\n            strideWidth: strideWidth,\n            filterHeight: filterHeight,\n            filterWidth: filterWidth\n        };\n    }\n    var inHeight = inShape[0];\n    var inWidth = inShape[1];\n    var outShape;\n    var padInfo;\n    if (pad === 'same') {\n        var outHeight = Math.ceil(inHeight / strideHeight);\n        var outWidth = Math.ceil(inWidth / strideWidth);\n        outShape = [outHeight, outWidth, outDepth];\n        var padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;\n        var padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;\n        var top_1 = Math.floor(padAlongHeight / 2);\n        var bottom = padAlongHeight - top_1;\n        var left = Math.floor(padAlongWidth / 2);\n        var right = padAlongWidth - left;\n        padInfo = { top: top_1, bottom: bottom, left: left, right: right };\n    }\n    else if (pad === 'valid') {\n        var outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n        var outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n        outShape = [outHeight, outWidth, outDepth];\n        padInfo = { top: 0, bottom: 0, left: 0, right: 0 };\n    }\n    else {\n        throw Error(\"Unknown padding parameter: \" + pad);\n    }\n    return {\n        inShape: inShape,\n        outShape: outShape,\n        padInfo: padInfo,\n        strideHeight: strideHeight,\n        strideWidth: strideWidth,\n        filterHeight: filterHeight,\n        filterWidth: filterWidth\n    };\n}\nexports.computeConvInfo = computeConvInfo;\nfunction computeOutputShape3D(inShape, fieldSize, outDepth, stride, zeroPad) {\n    if (zeroPad == null) {\n        zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n    }\n    var inputRows = inShape[0];\n    var inputCols = inShape[1];\n    var outputRows = (inputRows - fieldSize + 2 * zeroPad) / stride + 1;\n    util.assert(util.isInt(outputRows), \"The output # of rows (\" + outputRows + \") must be an integer. Change the \" +\n        \"stride and/or zero pad parameters\");\n    var outputCols = (inputCols - fieldSize + 2 * zeroPad) / stride + 1;\n    util.assert(util.isInt(outputCols), \"The output # of columns (\" + outputCols + \") must be an integer. Change \" +\n        \"the stride and/or zero pad parameters\");\n    return [outputRows, outputCols, outDepth];\n}\nexports.computeOutputShape3D = computeOutputShape3D;\nfunction computeDefaultPad(inputShape, fieldSize, stride) {\n    return Math.floor((inputShape[0] * (stride - 1) - stride + fieldSize) / 2);\n}\nexports.computeDefaultPad = computeDefaultPad;\nfunction computeTexShapeFrom3D(shapeRowColDepth) {\n    return [shapeRowColDepth[0], shapeRowColDepth[1] * shapeRowColDepth[2]];\n}\nexports.computeTexShapeFrom3D = computeTexShapeFrom3D;\nfunction computeWeightsShape4D(inputDepth, outputDepth, filterHeight, filterWidth) {\n    return [filterHeight, filterWidth, inputDepth, outputDepth];\n}\nexports.computeWeightsShape4D = computeWeightsShape4D;\nfunction computeDilatedRC(rc, origStride) {\n    var rowsDilated = (rc[0] - 1) * origStride + 1;\n    var colsDilated = (rc[1] - 1) * origStride + 1;\n    return [rowsDilated, colsDilated];\n}\nexports.computeDilatedRC = computeDilatedRC;\n//# sourceMappingURL=conv_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvY29udl91dGlsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL2NvbnZfdXRpbC5qcz82Nzc4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGNvbXB1dGVDb252SW5mbyhpblNoYXBlLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBvdXREZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgcGFkKSB7XG4gICAgaWYgKHR5cGVvZiBwYWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBvdXRTaGFwZV8xID0gY29tcHV0ZU91dHB1dFNoYXBlM0QoaW5TaGFwZSwgZmlsdGVySGVpZ2h0LCBvdXREZXB0aCwgc3RyaWRlSGVpZ2h0LCBwYWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5TaGFwZTogaW5TaGFwZSxcbiAgICAgICAgICAgIG91dFNoYXBlOiBvdXRTaGFwZV8xLFxuICAgICAgICAgICAgcGFkSW5mbzogeyB0b3A6IHBhZCwgYm90dG9tOiBwYWQsIGxlZnQ6IHBhZCwgcmlnaHQ6IHBhZCB9LFxuICAgICAgICAgICAgc3RyaWRlSGVpZ2h0OiBzdHJpZGVIZWlnaHQsXG4gICAgICAgICAgICBzdHJpZGVXaWR0aDogc3RyaWRlV2lkdGgsXG4gICAgICAgICAgICBmaWx0ZXJIZWlnaHQ6IGZpbHRlckhlaWdodCxcbiAgICAgICAgICAgIGZpbHRlcldpZHRoOiBmaWx0ZXJXaWR0aFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgaW5IZWlnaHQgPSBpblNoYXBlWzBdO1xuICAgIHZhciBpbldpZHRoID0gaW5TaGFwZVsxXTtcbiAgICB2YXIgb3V0U2hhcGU7XG4gICAgdmFyIHBhZEluZm87XG4gICAgaWYgKHBhZCA9PT0gJ3NhbWUnKSB7XG4gICAgICAgIHZhciBvdXRIZWlnaHQgPSBNYXRoLmNlaWwoaW5IZWlnaHQgLyBzdHJpZGVIZWlnaHQpO1xuICAgICAgICB2YXIgb3V0V2lkdGggPSBNYXRoLmNlaWwoaW5XaWR0aCAvIHN0cmlkZVdpZHRoKTtcbiAgICAgICAgb3V0U2hhcGUgPSBbb3V0SGVpZ2h0LCBvdXRXaWR0aCwgb3V0RGVwdGhdO1xuICAgICAgICB2YXIgcGFkQWxvbmdIZWlnaHQgPSAob3V0SGVpZ2h0IC0gMSkgKiBzdHJpZGVIZWlnaHQgKyBmaWx0ZXJIZWlnaHQgLSBpbkhlaWdodDtcbiAgICAgICAgdmFyIHBhZEFsb25nV2lkdGggPSAob3V0V2lkdGggLSAxKSAqIHN0cmlkZVdpZHRoICsgZmlsdGVyV2lkdGggLSBpbldpZHRoO1xuICAgICAgICB2YXIgdG9wXzEgPSBNYXRoLmZsb29yKHBhZEFsb25nSGVpZ2h0IC8gMik7XG4gICAgICAgIHZhciBib3R0b20gPSBwYWRBbG9uZ0hlaWdodCAtIHRvcF8xO1xuICAgICAgICB2YXIgbGVmdCA9IE1hdGguZmxvb3IocGFkQWxvbmdXaWR0aCAvIDIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwYWRBbG9uZ1dpZHRoIC0gbGVmdDtcbiAgICAgICAgcGFkSW5mbyA9IHsgdG9wOiB0b3BfMSwgYm90dG9tOiBib3R0b20sIGxlZnQ6IGxlZnQsIHJpZ2h0OiByaWdodCB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChwYWQgPT09ICd2YWxpZCcpIHtcbiAgICAgICAgdmFyIG91dEhlaWdodCA9IE1hdGguY2VpbCgoaW5IZWlnaHQgLSBmaWx0ZXJIZWlnaHQgKyAxKSAvIHN0cmlkZUhlaWdodCk7XG4gICAgICAgIHZhciBvdXRXaWR0aCA9IE1hdGguY2VpbCgoaW5XaWR0aCAtIGZpbHRlcldpZHRoICsgMSkgLyBzdHJpZGVXaWR0aCk7XG4gICAgICAgIG91dFNoYXBlID0gW291dEhlaWdodCwgb3V0V2lkdGgsIG91dERlcHRoXTtcbiAgICAgICAgcGFkSW5mbyA9IHsgdG9wOiAwLCBib3R0b206IDAsIGxlZnQ6IDAsIHJpZ2h0OiAwIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gcGFkZGluZyBwYXJhbWV0ZXI6IFwiICsgcGFkKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5TaGFwZTogaW5TaGFwZSxcbiAgICAgICAgb3V0U2hhcGU6IG91dFNoYXBlLFxuICAgICAgICBwYWRJbmZvOiBwYWRJbmZvLFxuICAgICAgICBzdHJpZGVIZWlnaHQ6IHN0cmlkZUhlaWdodCxcbiAgICAgICAgc3RyaWRlV2lkdGg6IHN0cmlkZVdpZHRoLFxuICAgICAgICBmaWx0ZXJIZWlnaHQ6IGZpbHRlckhlaWdodCxcbiAgICAgICAgZmlsdGVyV2lkdGg6IGZpbHRlcldpZHRoXG4gICAgfTtcbn1cbmV4cG9ydHMuY29tcHV0ZUNvbnZJbmZvID0gY29tcHV0ZUNvbnZJbmZvO1xuZnVuY3Rpb24gY29tcHV0ZU91dHB1dFNoYXBlM0QoaW5TaGFwZSwgZmllbGRTaXplLCBvdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkKSB7XG4gICAgaWYgKHplcm9QYWQgPT0gbnVsbCkge1xuICAgICAgICB6ZXJvUGFkID0gY29tcHV0ZURlZmF1bHRQYWQoaW5TaGFwZSwgZmllbGRTaXplLCBzdHJpZGUpO1xuICAgIH1cbiAgICB2YXIgaW5wdXRSb3dzID0gaW5TaGFwZVswXTtcbiAgICB2YXIgaW5wdXRDb2xzID0gaW5TaGFwZVsxXTtcbiAgICB2YXIgb3V0cHV0Um93cyA9IChpbnB1dFJvd3MgLSBmaWVsZFNpemUgKyAyICogemVyb1BhZCkgLyBzdHJpZGUgKyAxO1xuICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQob3V0cHV0Um93cyksIFwiVGhlIG91dHB1dCAjIG9mIHJvd3MgKFwiICsgb3V0cHV0Um93cyArIFwiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSB0aGUgXCIgK1xuICAgICAgICBcInN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wiKTtcbiAgICB2YXIgb3V0cHV0Q29scyA9IChpbnB1dENvbHMgLSBmaWVsZFNpemUgKyAyICogemVyb1BhZCkgLyBzdHJpZGUgKyAxO1xuICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQob3V0cHV0Q29scyksIFwiVGhlIG91dHB1dCAjIG9mIGNvbHVtbnMgKFwiICsgb3V0cHV0Q29scyArIFwiKSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSBcIiArXG4gICAgICAgIFwidGhlIHN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wiKTtcbiAgICByZXR1cm4gW291dHB1dFJvd3MsIG91dHB1dENvbHMsIG91dERlcHRoXTtcbn1cbmV4cG9ydHMuY29tcHV0ZU91dHB1dFNoYXBlM0QgPSBjb21wdXRlT3V0cHV0U2hhcGUzRDtcbmZ1bmN0aW9uIGNvbXB1dGVEZWZhdWx0UGFkKGlucHV0U2hhcGUsIGZpZWxkU2l6ZSwgc3RyaWRlKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoKGlucHV0U2hhcGVbMF0gKiAoc3RyaWRlIC0gMSkgLSBzdHJpZGUgKyBmaWVsZFNpemUpIC8gMik7XG59XG5leHBvcnRzLmNvbXB1dGVEZWZhdWx0UGFkID0gY29tcHV0ZURlZmF1bHRQYWQ7XG5mdW5jdGlvbiBjb21wdXRlVGV4U2hhcGVGcm9tM0Qoc2hhcGVSb3dDb2xEZXB0aCkge1xuICAgIHJldHVybiBbc2hhcGVSb3dDb2xEZXB0aFswXSwgc2hhcGVSb3dDb2xEZXB0aFsxXSAqIHNoYXBlUm93Q29sRGVwdGhbMl1dO1xufVxuZXhwb3J0cy5jb21wdXRlVGV4U2hhcGVGcm9tM0QgPSBjb21wdXRlVGV4U2hhcGVGcm9tM0Q7XG5mdW5jdGlvbiBjb21wdXRlV2VpZ2h0c1NoYXBlNEQoaW5wdXREZXB0aCwgb3V0cHV0RGVwdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgpIHtcbiAgICByZXR1cm4gW2ZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIGlucHV0RGVwdGgsIG91dHB1dERlcHRoXTtcbn1cbmV4cG9ydHMuY29tcHV0ZVdlaWdodHNTaGFwZTREID0gY29tcHV0ZVdlaWdodHNTaGFwZTREO1xuZnVuY3Rpb24gY29tcHV0ZURpbGF0ZWRSQyhyYywgb3JpZ1N0cmlkZSkge1xuICAgIHZhciByb3dzRGlsYXRlZCA9IChyY1swXSAtIDEpICogb3JpZ1N0cmlkZSArIDE7XG4gICAgdmFyIGNvbHNEaWxhdGVkID0gKHJjWzFdIC0gMSkgKiBvcmlnU3RyaWRlICsgMTtcbiAgICByZXR1cm4gW3Jvd3NEaWxhdGVkLCBjb2xzRGlsYXRlZF07XG59XG5leHBvcnRzLmNvbXB1dGVEaWxhdGVkUkMgPSBjb21wdXRlRGlsYXRlZFJDO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udl91dGlsLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/conv_util.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/copy2d_util.js":
/*!*************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/copy2d_util.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction validateShapes(sourceSize, destSize) {\n    var srcArea = sourceSize[0] * sourceSize[1];\n    var dstArea = destSize[0] * destSize[1];\n    if (srcArea !== dstArea) {\n        var srcStr = '[' + sourceSize[0] + ', ' + sourceSize[1] + ']';\n        var dstStr = '[' + destSize[0] + ', ' + destSize[1] + ']';\n        throw new Error('copy2D shapes have different areas:\\n  sourceSize ' + srcStr +\n            ', area ' + srcArea + '\\n  destSize ' + dstStr + ', area ' + dstArea);\n    }\n}\nexports.validateShapes = validateShapes;\n//# sourceMappingURL=copy2d_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvY29weTJkX3V0aWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvY29weTJkX3V0aWwuanM/ODYwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHZhbGlkYXRlU2hhcGVzKHNvdXJjZVNpemUsIGRlc3RTaXplKSB7XG4gICAgdmFyIHNyY0FyZWEgPSBzb3VyY2VTaXplWzBdICogc291cmNlU2l6ZVsxXTtcbiAgICB2YXIgZHN0QXJlYSA9IGRlc3RTaXplWzBdICogZGVzdFNpemVbMV07XG4gICAgaWYgKHNyY0FyZWEgIT09IGRzdEFyZWEpIHtcbiAgICAgICAgdmFyIHNyY1N0ciA9ICdbJyArIHNvdXJjZVNpemVbMF0gKyAnLCAnICsgc291cmNlU2l6ZVsxXSArICddJztcbiAgICAgICAgdmFyIGRzdFN0ciA9ICdbJyArIGRlc3RTaXplWzBdICsgJywgJyArIGRlc3RTaXplWzFdICsgJ10nO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvcHkyRCBzaGFwZXMgaGF2ZSBkaWZmZXJlbnQgYXJlYXM6XFxuICBzb3VyY2VTaXplICcgKyBzcmNTdHIgK1xuICAgICAgICAgICAgJywgYXJlYSAnICsgc3JjQXJlYSArICdcXG4gIGRlc3RTaXplICcgKyBkc3RTdHIgKyAnLCBhcmVhICcgKyBkc3RBcmVhKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlU2hhcGVzID0gdmFsaWRhdGVTaGFwZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3B5MmRfdXRpbC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/copy2d_util.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/cost_functions.js":
/*!****************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/cost_functions.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ndarray_1 = __webpack_require__(/*! ./ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar SquareCostFunc = (function () {\n    function SquareCostFunc() {\n        this.halfOne = ndarray_1.Scalar.new(0.5);\n    }\n    SquareCostFunc.prototype.cost = function (math, x1, x2) {\n        var diff = math.subStrict(x1, x2);\n        var diffSquared = math.elementWiseMul(diff, diff);\n        var result = math.scalarTimesArray(this.halfOne, diffSquared);\n        diff.dispose();\n        diffSquared.dispose();\n        return result;\n    };\n    SquareCostFunc.prototype.der = function (math, x1, x2) {\n        return math.subStrict(x1, x2);\n    };\n    SquareCostFunc.prototype.dispose = function () {\n        this.halfOne.dispose();\n    };\n    return SquareCostFunc;\n}());\nexports.SquareCostFunc = SquareCostFunc;\n//# sourceMappingURL=cost_functions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvY29zdF9mdW5jdGlvbnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvY29zdF9mdW5jdGlvbnMuanM/YzI1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBuZGFycmF5XzEgPSByZXF1aXJlKFwiLi9uZGFycmF5XCIpO1xudmFyIFNxdWFyZUNvc3RGdW5jID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcXVhcmVDb3N0RnVuYygpIHtcbiAgICAgICAgdGhpcy5oYWxmT25lID0gbmRhcnJheV8xLlNjYWxhci5uZXcoMC41KTtcbiAgICB9XG4gICAgU3F1YXJlQ29zdEZ1bmMucHJvdG90eXBlLmNvc3QgPSBmdW5jdGlvbiAobWF0aCwgeDEsIHgyKSB7XG4gICAgICAgIHZhciBkaWZmID0gbWF0aC5zdWJTdHJpY3QoeDEsIHgyKTtcbiAgICAgICAgdmFyIGRpZmZTcXVhcmVkID0gbWF0aC5lbGVtZW50V2lzZU11bChkaWZmLCBkaWZmKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG1hdGguc2NhbGFyVGltZXNBcnJheSh0aGlzLmhhbGZPbmUsIGRpZmZTcXVhcmVkKTtcbiAgICAgICAgZGlmZi5kaXNwb3NlKCk7XG4gICAgICAgIGRpZmZTcXVhcmVkLmRpc3Bvc2UoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFNxdWFyZUNvc3RGdW5jLnByb3RvdHlwZS5kZXIgPSBmdW5jdGlvbiAobWF0aCwgeDEsIHgyKSB7XG4gICAgICAgIHJldHVybiBtYXRoLnN1YlN0cmljdCh4MSwgeDIpO1xuICAgIH07XG4gICAgU3F1YXJlQ29zdEZ1bmMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFsZk9uZS5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3F1YXJlQ29zdEZ1bmM7XG59KCkpO1xuZXhwb3J0cy5TcXVhcmVDb3N0RnVuYyA9IFNxdWFyZUNvc3RGdW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29zdF9mdW5jdGlvbnMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/cost_functions.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/math.js":
/*!******************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/math.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar concat_util = __webpack_require__(/*! ./concat_util */ \"./node_modules/deeplearn/dist/src/math/concat_util.js\");\nvar conv_util = __webpack_require__(/*! ./conv_util */ \"./node_modules/deeplearn/dist/src/math/conv_util.js\");\nvar copy2d_util = __webpack_require__(/*! ./copy2d_util */ \"./node_modules/deeplearn/dist/src/math/copy2d_util.js\");\nvar ndarray_1 = __webpack_require__(/*! ./ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar slice_util = __webpack_require__(/*! ./slice_util */ \"./node_modules/deeplearn/dist/src/math/slice_util.js\");\nvar NDArrayMath = (function () {\n    function NDArrayMath(safeMode) {\n        this.safeMode = safeMode;\n        this.ndarrayScopes = [];\n        this.ndarraysToKeep = [];\n        this.activeScopeNDArraysToKeep = [];\n        this.debugMode = false;\n    }\n    NDArrayMath.prototype.scope = function (scopeFn) {\n        var _this = this;\n        this.startScope();\n        var keepFn = function (ndarray) { return _this.keep(ndarray); };\n        var trackFn = function (ndarray) { return _this.track(ndarray); };\n        var result = scopeFn(keepFn, trackFn);\n        this.endScope(result);\n        return result;\n    };\n    NDArrayMath.prototype.enableDebugMode = function () {\n        this.debugMode = true;\n        console.warn('Debugging mode is ON. The output of every math call will ' +\n            'be downloaded to CPU and checked for NaNs. ' +\n            'This significantly impacts performance.');\n    };\n    NDArrayMath.prototype.startScope = function () {\n        var newScope = [];\n        this.ndarrayScopes.push(newScope);\n        this.activeScope = newScope;\n        var newNDArraysToKeep = [];\n        this.ndarraysToKeep.push(newNDArraysToKeep);\n        this.activeScopeNDArraysToKeep = newNDArraysToKeep;\n    };\n    NDArrayMath.prototype.endScope = function (result) {\n        var _this = this;\n        var arraysToKeep = this.activeScopeNDArraysToKeep;\n        if (result != null) {\n            arraysToKeep = arraysToKeep.concat(result);\n        }\n        for (var i = 0; i < this.activeScope.length; i++) {\n            var ndarray = this.activeScope[i];\n            if (this.isNDArrayDataInList(ndarray, arraysToKeep)) {\n                continue;\n            }\n            ndarray.dispose();\n        }\n        this.ndarrayScopes.pop();\n        this.activeScope = this.ndarrayScopes.length === 0 ?\n            null :\n            this.ndarrayScopes[this.ndarrayScopes.length - 1];\n        if (result instanceof ndarray_1.NDArray &&\n            !this.isNDArrayDataInList(result, this.activeScopeNDArraysToKeep)) {\n            this.track(result);\n        }\n        else if (Array.isArray(result)) {\n            result.forEach(function (r) {\n                if (r instanceof ndarray_1.NDArray &&\n                    !_this.isNDArrayDataInList(r, _this.activeScopeNDArraysToKeep)) {\n                    _this.track(r);\n                }\n            });\n        }\n        this.ndarraysToKeep.pop();\n        this.activeScopeNDArraysToKeep = this.ndarraysToKeep.length === 0 ?\n            null :\n            this.ndarraysToKeep[this.ndarraysToKeep.length - 1];\n    };\n    NDArrayMath.prototype.isNDArrayDataInList = function (ndarray, ndarrayList) {\n        for (var i = 0; i < ndarrayList.length; i++) {\n            if (ndarrayList[i].getData() === ndarray.getData()) {\n                return true;\n            }\n        }\n        return false;\n    };\n    NDArrayMath.prototype.keep = function (result) {\n        if (this.activeScope == null) {\n            if (this.safeMode) {\n                throw new Error('You are using math in safe mode. Enclose all ' +\n                    'math.method() calls inside a scope: ' +\n                    'math.scope(() => {math.method();...}) to avoid memory ' +\n                    'leaks.');\n            }\n            return result;\n        }\n        this.activeScopeNDArraysToKeep.push(result);\n        return result;\n    };\n    NDArrayMath.prototype.checkForNaN = function (vals, name) {\n        for (var i = 0; i < vals.length; i++) {\n            if (isNaN(vals[i])) {\n                throw Error(\"The result of the last math.\" + name + \" has NaNs.\");\n            }\n        }\n    };\n    NDArrayMath.prototype.track = function (result) {\n        if (this.activeScope == null) {\n            if (this.safeMode) {\n                throw new Error('You are using math in safe mode. Enclose all ' +\n                    'math.method() calls inside a scope: ' +\n                    'math.scope(() => {math.method();...}) to avoid memory ' +\n                    'leaks.');\n            }\n            return result;\n        }\n        this.activeScope.push(result);\n        return result;\n    };\n    NDArrayMath.prototype.dispose = function () { };\n    NDArrayMath.prototype.matMul = function (a, b, aOrientation, bOrientation) {\n        var _this = this;\n        if (aOrientation === void 0) { aOrientation = MatrixOrientation.REGULAR; }\n        if (bOrientation === void 0) { bOrientation = MatrixOrientation.REGULAR; }\n        var innerShapeA = (aOrientation === MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];\n        var innerShapeB = (bOrientation === MatrixOrientation.REGULAR) ? b.shape[0] : b.shape[1];\n        util.assert(a.rank === 2 && b.rank === 2, \"Error in matMul: inputs must be rank 2, got ranks \" + a.rank +\n            (\"and \" + b.rank + \".\"));\n        util.assert(innerShapeA === innerShapeB, \"Error in matMul: inner shapes (\" + innerShapeA + \") and (\" +\n            (innerShapeB + \") of NDArrays with shapes \" + a.shape + \" and \") +\n            (b.shape + \" and orientations \" + MatrixOrientation[aOrientation]) +\n            (\" and \" + MatrixOrientation[bOrientation] + \" must match.\"));\n        return this.executeOp('matMul', function () { return _this.matMulInternal(a, b, aOrientation, bOrientation); });\n    };\n    NDArrayMath.prototype.executeOp = function (name, f) {\n        var start;\n        if (this.debugMode) {\n            start = performance.now();\n        }\n        var result = f();\n        if (this.debugMode) {\n            var vals = result.getValues();\n            var time = util.rightPad((performance.now() - start) + 'ms', 9);\n            var paddedName = util.rightPad(name, 25);\n            var rank = result.rank;\n            var size = result.size;\n            var shape = util.rightPad(result.shape + '', 14);\n            console.log(\"%c\" + paddedName + \"\\t%c\" + time + \"\\t%c\" + rank + \"D \" + shape + \"\\t%c\" + size, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange');\n            this.checkForNaN(vals, name);\n        }\n        return this.track(result);\n    };\n    NDArrayMath.prototype.vectorTimesMatrix = function (v, matrix) {\n        util.assert(v.rank === 1, \"Error in vectorTimesMatrix: first input must be rank 1, but got \" +\n            (\"rank \" + v.rank + \".\"));\n        util.assert(matrix.rank === 2, \"Error in vectorTimesMatrix: second input must be rank 2, but got \" +\n            (\"rank \" + matrix.rank + \".\"));\n        util.assert(v.size === matrix.shape[0], \"Error in vectorTimesMatrix: size of vector (\" + v.size + \") \" +\n            (\"must match first dimension of matrix (\" + matrix.shape[0] + \")\"));\n        return this.matMul(v.as2D(1, -1), matrix).as1D();\n    };\n    NDArrayMath.prototype.matrixTimesVector = function (matrix, v) {\n        util.assert(v.rank === 1, \"Error in vectorTimesMatrix: second input must rank 1, but got \" +\n            (\"rank \" + v.rank + \".\"));\n        util.assert(matrix.rank === 2, \"Error in vectorTimesMatrix: first input must be a rank 2, but got \" +\n            (\"rank \" + matrix.rank + \".\"));\n        util.assert(v.size === matrix.shape[1], \"Error in vectorTimesMatrix: size of first rank 1 input \" + v.size + \" \" +\n            \"must match inner dimension of second rank 2 input, but got \" +\n            (\"shape \" + matrix.shape + \".\"));\n        return this.matMul(matrix, v.as2D(-1, 1)).as1D();\n    };\n    NDArrayMath.prototype.dotProduct = function (v1, v2) {\n        util.assert(v1.rank === 1 && v2.rank === 1, \"Error in dotProduct: inputs must be rank 1, but got ranks \" +\n            (v1.rank + \" and \" + v2.rank + \".\"));\n        util.assert(v1.size === v2.size, \"Error in dotProduct: size of inputs (\" + v1.size + \") and (\" +\n            (v2.size + \") must match.\"));\n        return this.matMul(v1.as2D(1, -1), v2.as2D(-1, 1)).asScalar();\n    };\n    NDArrayMath.prototype.outerProduct = function (v1, v2) {\n        util.assert(v1.rank === 1 && v2.rank === 1, \"Error in outerProduct: inputs must be rank 1, but got ranks \" +\n            (v1.rank + \" and \" + v2.rank + \".\"));\n        return this.matMul(v1.as2D(-1, 1), v2.as2D(1, -1));\n    };\n    NDArrayMath.prototype.clone = function (ndarray) {\n        var _this = this;\n        return this.executeOp('clone', function () { return _this.cloneInternal(ndarray); });\n    };\n    NDArrayMath.prototype.reshape = function (ndarray, newShape) {\n        console.warn('math.reshape() is deprecated. Please call reshape() ' +\n            'directly on the ndarray object');\n        return ndarray.reshape(newShape);\n    };\n    NDArrayMath.prototype.slice1D = function (input, begin, size) {\n        var _this = this;\n        slice_util.assertParamsValid(input, [begin], [size]);\n        return this.executeOp('slice1D', function () { return _this.slice1DInternal(input, begin, size); });\n    };\n    NDArrayMath.prototype.slice2D = function (input, begin, size) {\n        var _this = this;\n        slice_util.assertParamsValid(input, begin, size);\n        return this.executeOp('slice2D', function () { return _this.slice2DInternal(input, begin, size); });\n    };\n    NDArrayMath.prototype.slice3D = function (input, begin, size) {\n        var _this = this;\n        slice_util.assertParamsValid(input, begin, size);\n        return this.executeOp('slice3D', function () { return _this.slice3DInternal(input, begin, size); });\n    };\n    NDArrayMath.prototype.slice4D = function (input, begin, size) {\n        var _this = this;\n        slice_util.assertParamsValid(input, begin, size);\n        return this.executeOp('slice4D', function () { return _this.slice4DInternal(input, begin, size); });\n    };\n    NDArrayMath.prototype.copy2D = function (source, sourceBegin, sourceSize, dest, destBegin, destSize) {\n        var _this = this;\n        util.assert(sourceBegin[0] + sourceSize[0] <= source.shape[0] &&\n            sourceBegin[1] + sourceSize[1] <= source.shape[1], \"Error in copy2D: requested source start position \" + sourceBegin + \" \" +\n            (\"and source size \" + sourceSize + \" would overflow source NDArray\") +\n            (\"of shape \" + source.shape + \".\"));\n        util.assert(destBegin[0] + destSize[0] <= dest.shape[0] &&\n            destBegin[1] + destSize[1] <= dest.shape[1], \"Error in copy2D: requested dest start position \" + destBegin + \" \" +\n            (\"and source size \" + destSize + \" would overflow dest NDArray of\") +\n            (\"shape \" + dest.shape + \".\"));\n        copy2d_util.validateShapes(sourceSize, destSize);\n        this.executeOp('copy2D', function () {\n            _this.copy2DInternal(source, sourceBegin, sourceSize, dest, destBegin, destSize);\n            return dest;\n        });\n    };\n    NDArrayMath.prototype.concat1D = function (a, b) {\n        var _this = this;\n        concat_util.assertParams(a.shape, b.shape, 0);\n        return this.executeOp('concat1D', function () { return _this.concat1DInternal(a, b); });\n    };\n    NDArrayMath.prototype.concat2D = function (a, b, axis) {\n        var _this = this;\n        concat_util.assertParams(a.shape, b.shape, axis);\n        return this.executeOp('concat2D', function () { return _this.concat2DInternal(a, b, axis); });\n    };\n    NDArrayMath.prototype.concat3D = function (ndarray1, ndarray2, axis) {\n        var _this = this;\n        concat_util.assertParams(ndarray1.shape, ndarray2.shape, axis);\n        return this.executeOp('concat3D', function () { return _this.concat3DInternal(ndarray1, ndarray2, axis); });\n    };\n    NDArrayMath.prototype.concat4D = function (ndarray1, ndarray2, axis) {\n        var _this = this;\n        concat_util.assertParams(ndarray1.shape, ndarray2.shape, axis);\n        return this.executeOp('concat4D', function () { return _this.concat4DInternal(ndarray1, ndarray2, axis); });\n    };\n    NDArrayMath.prototype.logSumExp = function (ndarray) {\n        var _this = this;\n        return this.executeOp('logSumExp', function () { return _this.logSumExpInternal(ndarray); });\n    };\n    NDArrayMath.prototype.sum = function (ndarray) {\n        var _this = this;\n        return this.executeOp('sum', function () { return _this.sumInternal(ndarray); });\n    };\n    NDArrayMath.prototype.argMin = function (ndarray) {\n        var _this = this;\n        return this.executeOp('argMin', function () { return _this.argMinInternal(ndarray); });\n    };\n    NDArrayMath.prototype.argMax = function (ndarray) {\n        var _this = this;\n        return this.executeOp('argMax', function () { return _this.argMaxInternal(ndarray); });\n    };\n    NDArrayMath.prototype.argMaxEquals = function (x1, x2) {\n        var _this = this;\n        util.assertShapesMatch(x1.shape, x2.shape, 'Error in argMaxEquals: ');\n        return this.executeOp('argMaxEquals', function () { return _this.argMaxEqualsInternal(x1, x2); });\n    };\n    NDArrayMath.prototype.topK = function (ndarray, k) {\n        var _this = this;\n        util.assert(k <= ndarray.size, \"Error in topK: k value (\" + k + \") must be less than size of input \" +\n            (\"ndarray, got shape \" + ndarray.shape + \".\"));\n        var result;\n        this.executeOp('topK', function () {\n            result = _this.topKInternal(ndarray, k);\n            return result.values;\n        });\n        this.track(result.indices);\n        return result;\n    };\n    NDArrayMath.prototype.min = function (ndarray) {\n        var _this = this;\n        return this.executeOp('min', function () { return _this.minInternal(ndarray); });\n    };\n    NDArrayMath.prototype.max = function (ndarray) {\n        var _this = this;\n        return this.executeOp('max', function () { return _this.maxInternal(ndarray); });\n    };\n    NDArrayMath.prototype.softmax = function (x) {\n        var _this = this;\n        return this.executeOp('softmax', function () {\n            return _this.scope(function () {\n                var lse = _this.logSumExp(x);\n                var logResult = _this.arrayMinusScalar(x, lse);\n                return _this.exp(logResult);\n            });\n        });\n    };\n    NDArrayMath.prototype.switchDim = function (a, newDim) {\n        var _this = this;\n        util.assert(a.rank === newDim.length, \"Error in switchDim: length of input shape \" + a.shape + \" \" +\n            (\"must match size of newDim array \" + newDim + \".\"));\n        return this.executeOp('switchDim', function () { return _this.switchDimInternal(a, newDim); });\n    };\n    NDArrayMath.prototype.scalarPlusArray = function (c, a) {\n        util.assert(c.size === 1, \"Error in scalarPlusArray: first argument must be rank 0, but got \" +\n            (\"rank \" + c.rank + \".\"));\n        return this.add(c, a);\n    };\n    NDArrayMath.prototype.scalarMinusArray = function (c, a) {\n        util.assert(c.size === 1, \"Error in scalarMinusArray: first argument must be rank 0, but got \" +\n            (\"rank \" + c.rank + \".\"));\n        return this.sub(c, a);\n    };\n    NDArrayMath.prototype.arrayMinusScalar = function (a, c) {\n        util.assert(c.size === 1, \"Error in arrayMinusScalar: second argument must be rank 0, but \" +\n            (\"got rank \" + c.rank + \".\"));\n        return this.sub(a, c);\n    };\n    NDArrayMath.prototype.neg = function (a) {\n        var _this = this;\n        return this.executeOp('neg', function () { return _this.negInternal(a); });\n    };\n    NDArrayMath.prototype.add = function (a, b) {\n        var _this = this;\n        util.assertAndGetBroadcastedShape(a.shape, b.shape);\n        return this.executeOp('add', function () { return _this.addInternal(a, b); });\n    };\n    NDArrayMath.prototype.addStrict = function (a, b) {\n        util.assertShapesMatch(a.shape, b.shape, 'Error in addStrict: ');\n        return this.add(a, b);\n    };\n    NDArrayMath.prototype.sub = function (a, b) {\n        var _this = this;\n        util.assertAndGetBroadcastedShape(a.shape, b.shape);\n        return this.executeOp('sub', function () { return _this.subInternal(a, b); });\n    };\n    NDArrayMath.prototype.subStrict = function (a, b) {\n        util.assertShapesMatch(a.shape, b.shape, 'Error in subStrict: ');\n        return this.sub(a, b);\n    };\n    NDArrayMath.prototype.multiply = function (a, b) {\n        var _this = this;\n        util.assertAndGetBroadcastedShape(a.shape, b.shape);\n        return this.executeOp('multiply', function () { return _this.multiplyInternal(a, b); });\n    };\n    NDArrayMath.prototype.elementWiseMul = function (a, b) {\n        return this.multiplyStrict(a, b);\n    };\n    NDArrayMath.prototype.multiplyStrict = function (a, b) {\n        util.assertShapesMatch(a.shape, b.shape, 'Error in multiplyStrict: ');\n        return this.multiply(a, b);\n    };\n    NDArrayMath.prototype.divide = function (a, b) {\n        var _this = this;\n        util.assertAndGetBroadcastedShape(a.shape, b.shape);\n        return this.executeOp('divide', function () { return _this.divideInternal(a, b); });\n    };\n    NDArrayMath.prototype.divideStrict = function (a, b) {\n        util.assertShapesMatch(a.shape, b.shape, 'Error in divideStrict: ');\n        return this.divide(a, b);\n    };\n    NDArrayMath.prototype.scalarDividedByArray = function (c, a) {\n        util.assert(c.size === 1, \"Error in scalarDividedByArray: first argument must be rank 0, but \" +\n            (\"got NDArray of rank \" + c.rank + \".\"));\n        return this.divide(c, a);\n    };\n    NDArrayMath.prototype.arrayDividedByScalar = function (a, c) {\n        util.assert(c.size === 1, \"Error in arrayDividedByScalar: second argument must be rank 0, \" +\n            (\"but got NDArray of rank \" + c.rank + \".\"));\n        return this.divide(a, c);\n    };\n    NDArrayMath.prototype.exp = function (ndarray) {\n        var _this = this;\n        return this.executeOp('exp', function () { return _this.expInternal(ndarray); });\n    };\n    NDArrayMath.prototype.log = function (ndarray) {\n        var _this = this;\n        return this.executeOp('log', function () { return _this.logInternal(ndarray); });\n    };\n    NDArrayMath.prototype.sqrt = function (ndarray) {\n        var _this = this;\n        return this.executeOp('sqrt', function () { return _this.sqrtInternal(ndarray); });\n    };\n    NDArrayMath.prototype.abs = function (ndarray) {\n        var _this = this;\n        return this.executeOp('abs', function () { return _this.absInternal(ndarray); });\n    };\n    NDArrayMath.prototype.relu = function (ndarray) {\n        var _this = this;\n        return this.executeOp('relu', function () { return _this.reluInternal(ndarray); });\n    };\n    NDArrayMath.prototype.sigmoid = function (ndarray) {\n        var _this = this;\n        return this.executeOp('sigmoid', function () { return _this.sigmoidInternal(ndarray); });\n    };\n    NDArrayMath.prototype.sin = function (ndarray) {\n        var _this = this;\n        return this.executeOp('sin', function () { return _this.sinInternal(ndarray); });\n    };\n    NDArrayMath.prototype.cos = function (ndarray) {\n        var _this = this;\n        return this.executeOp('cos', function () { return _this.cosInternal(ndarray); });\n    };\n    NDArrayMath.prototype.tan = function (ndarray) {\n        var _this = this;\n        return this.executeOp('tan', function () { return _this.tanInternal(ndarray); });\n    };\n    NDArrayMath.prototype.asin = function (ndarray) {\n        var _this = this;\n        return this.executeOp('asin', function () { return _this.asinInternal(ndarray); });\n    };\n    NDArrayMath.prototype.acos = function (ndarray) {\n        var _this = this;\n        return this.executeOp('acos', function () { return _this.acosInternal(ndarray); });\n    };\n    NDArrayMath.prototype.atan = function (ndarray) {\n        var _this = this;\n        return this.executeOp('atan', function () { return _this.atanInternal(ndarray); });\n    };\n    NDArrayMath.prototype.sinh = function (ndarray) {\n        var _this = this;\n        return this.executeOp('sinh', function () { return _this.sinhInternal(ndarray); });\n    };\n    NDArrayMath.prototype.cosh = function (ndarray) {\n        var _this = this;\n        return this.executeOp('cosh', function () { return _this.coshInternal(ndarray); });\n    };\n    NDArrayMath.prototype.tanh = function (ndarray) {\n        var _this = this;\n        return this.executeOp('tanh', function () { return _this.tanhInternal(ndarray); });\n    };\n    NDArrayMath.prototype.step = function (ndarray) {\n        var _this = this;\n        return this.executeOp('step', function () { return _this.stepInternal(ndarray); });\n    };\n    NDArrayMath.prototype.scaledArrayAdd = function (c1, a, c2, b) {\n        var _this = this;\n        util.assert(c1.size === 1, \"Error in scaledArrayAdd: first argument must rank 0, but got \" +\n            (\" rank \" + c1.rank + \".\"));\n        util.assert(c2.size === 1, \"Error in scaledArrayAdd: third argument must be rank 0, but got \" +\n            (\"NDArray of rank \" + c2.rank + \".\"));\n        util.assertShapesMatch(a.shape, b.shape, 'Error in scaledArrayAdd: ');\n        return this.executeOp('scaledArrayAdd', function () { return _this.scaledArrayAddInternal(c1, a, c2, b); });\n    };\n    NDArrayMath.prototype.scalarTimesArray = function (c, a) {\n        util.assert(c.size === 1, \"Error in arrayDividedByScalar: first argument must be rank 0, but \" +\n            (\"got rank \" + c.rank + \".\"));\n        return this.multiply(c, a);\n    };\n    NDArrayMath.prototype.elementWiseMulBroadcast = function (a, b) {\n        util.assert(a.rank === 2, \"Error in elementWiseMulBroadcast: first argument must be \" +\n            (\"rank 2, but got rank \" + a.rank + \".\"));\n        util.assert(b.rank === 2, \"Error in elementWiseMulBroadcast: second argument must be \" +\n            (\"rank 2, but got rank \" + b.rank + \".\"));\n        return this.multiply(a, b);\n    };\n    NDArrayMath.prototype.conv2d = function (x, filter, bias, strides, pad) {\n        var _this = this;\n        util.assert(x.rank === 3, \"Error in conv2d: x must be rank 3, but got rank \" + x.rank + \".\");\n        util.assert(filter.rank === 4, \"Error in conv2d: filter must be rank 4, but got rank \" +\n            (filter.rank + \".\"));\n        if (bias != null) {\n            util.assert(bias.rank === 1, \"Error in conv2d: bias must be rank 1, but got rank \" +\n                (bias.rank + \".\"));\n        }\n        util.assert(x.shape[2] === filter.shape[2], \"Error in conv2d: depth of input (\" + x.shape[2] + \") must match  \" +\n            (\"input depth for filter \" + filter.shape[2] + \".\"));\n        var filterHeight = filter.shape[0];\n        var filterWidth = filter.shape[1];\n        var outDepth = filter.shape[3];\n        var _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];\n        var convInfo = conv_util.computeConvInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);\n        return this.executeOp('conv2d', function () { return _this.conv2dInternal(x, filter, bias, convInfo); });\n    };\n    NDArrayMath.prototype.conv2dBackProp = function (x, dy, filter, strides, pad) {\n        var dw = this.conv2dDerFilter(x, dy, filter.shape, strides, pad);\n        var db = this.conv2dDerBias(dy);\n        var dx = this.conv2dDerInput(x.shape, dy, filter, strides, pad);\n        return { db: db, dw: dw, dx: dx };\n    };\n    NDArrayMath.prototype.conv2dDerInput = function (inShape, dy, filter, strides, pad) {\n        var _this = this;\n        var inDepth = inShape[2];\n        var outDepth = dy.shape[2];\n        util.assert(inShape.length === 3, \"Error in conv2dDerInput: x must be rank 3, but got rank \" +\n            (inShape.length + \".\"));\n        util.assert(dy.rank === 3, \"Error in conv2dDerInput: dy must be rank 3, but got \" +\n            (\"rank \" + dy.rank));\n        util.assert(filter.rank === 4, \"Error in conv2dDerInput: filter must be rank 4, but got \" +\n            (\"rank \" + filter.rank));\n        util.assert(inDepth === filter.shape[2], \"Error in conv2dDerInput: depth of input (\" + inDepth + \") must \" +\n            (\"match input depth for filter \" + filter.shape[2] + \".\"));\n        util.assert(outDepth === filter.shape[3], \"Error in conv2dDerInput: depth of output (\" + outDepth + \") must\" +\n            (\"match output depth for filter \" + filter.shape[3] + \".\"));\n        var filterHeight = filter.shape[0];\n        var filterWidth = filter.shape[1];\n        var _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];\n        var convInfo = conv_util.computeConvInfo(inShape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);\n        return this.executeOp('conv2dDerInput', function () { return _this.conv2dDerInputInternal(dy, filter, convInfo); });\n    };\n    NDArrayMath.prototype.conv2dDerBias = function (dy) {\n        return this.track(this.conv2dDerBiasInternal(dy));\n    };\n    NDArrayMath.prototype.conv2dDerFilter = function (x, dy, filterSize, strides, pad) {\n        util.assert(x.rank === 3, \"Error in conv2dDerFilter: x must be rank 3, but got shape \" +\n            (x.shape + \".\"));\n        util.assert(dy.rank === 3, \"Error in conv2dDerFilter: dy must be rank 3, but got shape \" +\n            (dy.shape + \".\"));\n        util.assert(filterSize.length === 4, \"Error in conv2dDerFilter: filterSize must be length 4, but got \" +\n            (filterSize + \".\"));\n        util.assert(x.shape[2] === filterSize[2], \"Error in conv2dDerFilter: depth of x \" + x.shape[2] + \") must \" +\n            (\"match input depth in filter (\" + filterSize[2] + \".\"));\n        util.assert(dy.shape[2] === filterSize[3], \"Error in conv2dDerFilter: depth of dy (\" + dy.shape[2] + \") must \" +\n            (\"match output depth for filter (\" + filterSize[3] + \").\"));\n        var filterHeight = filterSize[0];\n        var filterWidth = filterSize[1];\n        var outDepth = filterSize[3];\n        var _a = parseTupleParam(strides), strideHeight = _a[0], strideWidth = _a[1];\n        var convInfo = conv_util.computeConvInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);\n        return this.track(this.conv2dDerFilterInternal(x, dy, convInfo));\n    };\n    NDArrayMath.prototype.conv2dTranspose = function (x, filter, outputShape, strides, pad) {\n        return this.conv2dDerInput(outputShape, x, filter, strides, pad);\n    };\n    NDArrayMath.prototype.maxPool = function (x, filterSize, strides, pad) {\n        var _this = this;\n        util.assert(x.rank === 3, 'Error in maxPool: x must be rank 3 but got rank ' + x.rank + '.');\n        var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];\n        var outDepth = x.shape[2];\n        var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];\n        var convInfo = conv_util.computeConvInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);\n        return this.executeOp('maxPool', function () { return _this.maxPoolInternal(x, convInfo); });\n    };\n    NDArrayMath.prototype.maxPoolBackprop = function (dy, x, filterSize, strides, pad) {\n        var _this = this;\n        util.assert(dy.rank === 3, \"Error in maxPoolBackprop: dy must be rank 3 but got rank \" +\n            (dy.rank + \".\"));\n        util.assert(x.rank === 3, \"Error in maxPoolBackprop: x must be rank 3 but got rank \" +\n            (x.rank + \".\"));\n        var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];\n        var outDepth = x.shape[2];\n        var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];\n        var convInfo = conv_util.computeConvInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);\n        return this.executeOp('maxPoolBackprop', function () { return _this.maxPoolBackpropInternal(dy, x, convInfo); });\n    };\n    NDArrayMath.prototype.minPool = function (x, filterSize, strides, pad) {\n        var _this = this;\n        util.assert(x.rank === 3, \"Error in minPool: x must be rank 3 but got rank \" + x.rank + \".\");\n        var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];\n        var outDepth = x.shape[2];\n        var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];\n        var convInfo = conv_util.computeConvInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);\n        return this.executeOp('minPool', function () { return _this.minPoolInternal(x, convInfo); });\n    };\n    NDArrayMath.prototype.avgPool = function (x, filterSize, strides, pad) {\n        var _this = this;\n        util.assert(x.rank === 3, \"Error in avgPool: x must be rank 3 but got rank \" + x.rank + \".\");\n        var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];\n        var outDepth = x.shape[2];\n        var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];\n        var convInfo = conv_util.computeConvInfo(x.shape, filterHeight, filterWidth, outDepth, strideHeight, strideWidth, pad);\n        return this.executeOp('avgPool', function () { return _this.avgPoolInternal(x, convInfo); });\n    };\n    NDArrayMath.prototype.resizeBilinear3D = function (x, newShape2D, alignCorners) {\n        var _this = this;\n        if (alignCorners === void 0) { alignCorners = false; }\n        util.assert(x.rank === 3, \"Error in resizeBilinear3D: x must be rank 3 but got rank \" + x.rank + \".\");\n        util.assert(newShape2D.length === 2, \"Error in resizeBilinear3D: new shape must 2D, but got shape \" +\n            (newShape2D + \".\"));\n        return this.executeOp('resizeBilinear3D', function () { return _this.resizeBilinear3DInternal(x, newShape2D, alignCorners); });\n    };\n    NDArrayMath.prototype.batchNormalization3D = function (x, mean, variance, varianceEpsilon, scale, offset) {\n        var _this = this;\n        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }\n        util.assert(x.rank === 3, \"Error in batchNormalization3D: x must be rank 3 but got rank \" +\n            (x.rank + \".\"));\n        util.assert(mean.rank === 3 || mean.rank === 1, \"Error in batchNormalization3D: mean must be rank 3 or rank 1 but \" +\n            (\"got rank \" + mean.rank + \".\"));\n        util.assert(variance.rank === 3 || variance.rank === 1, \"Error in batchNormalization3D: variance must be rank 3 or rank 1 \" +\n            (\"but got rank \" + variance.rank + \".\"));\n        if (scale != null) {\n            util.assert(scale.rank === 3 || scale.rank === 1, \"Error in batchNormalization3D: scale must be rank 3 or rank 1 \" +\n                (\"but got rank \" + scale.rank + \".\"));\n        }\n        if (offset != null) {\n            util.assert(offset.rank === 3 || offset.rank === 1, \"Error in batchNormalization3D: offset must be rank 3 or rank 1 \" +\n                (\"but got rank \" + offset.rank + \".\"));\n        }\n        return this.executeOp('batchNorm3D', function () { return _this.batchNormalization3DInternal(x, mean, variance, varianceEpsilon, scale, offset); });\n    };\n    NDArrayMath.prototype.multiRNNCell = function (lstmCells, data, c, h) {\n        util.assert(data.shape[0] === 1, \"Error in multiRNNCell: first dimension of data is \" + data.shape[0] + \", \" +\n            \"but batch sizes > 1 are not yet supported.\");\n        var res = this.scope(function () {\n            var input = data;\n            var newStates = [];\n            for (var i = 0; i < lstmCells.length; i++) {\n                var output = lstmCells[i](input, c[i], h[i]);\n                newStates.push(output[0]);\n                newStates.push(output[1]);\n                input = output[1];\n            }\n            return newStates;\n        });\n        var newC = [];\n        var newH = [];\n        for (var i = 0; i < res.length; i += 2) {\n            newC.push(res[i]);\n            newH.push(res[i + 1]);\n        }\n        return [newC, newH];\n    };\n    NDArrayMath.prototype.basicLSTMCell = function (forgetBias, lstmKernel, lstmBias, data, c, h) {\n        var _this = this;\n        var res = this.scope(function () {\n            util.assert(data.shape[0] === 1, \"Error in multiRNNCell: first dimension of data is \" +\n                (data.shape[0] + \", but batch sizes > 1 are not yet supported.\"));\n            var combined = _this.concat1D(data.as1D(), h.as1D());\n            var weighted = _this.vectorTimesMatrix(combined, lstmKernel);\n            var res = _this.addStrict(weighted, lstmBias);\n            var sliceSize = res.size / 4;\n            var i = _this.slice1D(res, 0, sliceSize);\n            var j = _this.slice1D(res, sliceSize, sliceSize);\n            var f = _this.slice1D(res, sliceSize * 2, sliceSize);\n            var o = _this.slice1D(res, sliceSize * 3, sliceSize);\n            var newC = _this.addStrict(_this.multiplyStrict(c.as1D(), _this.sigmoid(_this.scalarPlusArray(forgetBias, f))), _this.multiplyStrict(_this.sigmoid(i), _this.tanh(j)));\n            var newH = _this.multiplyStrict(_this.tanh(newC), _this.sigmoid(o));\n            return [newC, newH];\n        });\n        return [res[0].as2D(1, -1), res[1].as2D(1, -1)];\n    };\n    NDArrayMath.prototype.multinomial = function (probabilities, numSamples, seed) {\n        var _this = this;\n        var numOutcomes = probabilities.size;\n        if (numOutcomes < 2) {\n            throw new Error(\"Error in multinomial: you need at least 2 outcomes, but got \" +\n                (numOutcomes + \".\"));\n        }\n        seed = seed || Math.random();\n        return this.executeOp('multinomial', function () { return _this.multinomialInternal(probabilities, numSamples, seed); });\n    };\n    NDArrayMath.prototype.oneHot = function (indices, depth, onValue, offValue) {\n        var _this = this;\n        if (onValue === void 0) { onValue = 1; }\n        if (offValue === void 0) { offValue = 0; }\n        if (depth < 2) {\n            throw new Error(\"Error in oneHot: depth must be >=2, but it is \" + depth);\n        }\n        return this.executeOp('oneHot', function () { return _this.oneHotInternal(indices, depth, onValue, offValue); });\n    };\n    return NDArrayMath;\n}());\nexports.NDArrayMath = NDArrayMath;\nvar MatrixOrientation;\n(function (MatrixOrientation) {\n    MatrixOrientation[MatrixOrientation[\"REGULAR\"] = 0] = \"REGULAR\";\n    MatrixOrientation[MatrixOrientation[\"TRANSPOSED\"] = 1] = \"TRANSPOSED\";\n})(MatrixOrientation = exports.MatrixOrientation || (exports.MatrixOrientation = {}));\nfunction parseTupleParam(param) {\n    return typeof param === 'number' ? [param, param] : param;\n}\n//# sourceMappingURL=math.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvbWF0aC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC9tYXRoLmpzPzcxYmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGNvbmNhdF91dGlsID0gcmVxdWlyZShcIi4vY29uY2F0X3V0aWxcIik7XG52YXIgY29udl91dGlsID0gcmVxdWlyZShcIi4vY29udl91dGlsXCIpO1xudmFyIGNvcHkyZF91dGlsID0gcmVxdWlyZShcIi4vY29weTJkX3V0aWxcIik7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbmRhcnJheVwiKTtcbnZhciBzbGljZV91dGlsID0gcmVxdWlyZShcIi4vc2xpY2VfdXRpbFwiKTtcbnZhciBOREFycmF5TWF0aCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTkRBcnJheU1hdGgoc2FmZU1vZGUpIHtcbiAgICAgICAgdGhpcy5zYWZlTW9kZSA9IHNhZmVNb2RlO1xuICAgICAgICB0aGlzLm5kYXJyYXlTY29wZXMgPSBbXTtcbiAgICAgICAgdGhpcy5uZGFycmF5c1RvS2VlcCA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlTkRBcnJheXNUb0tlZXAgPSBbXTtcbiAgICAgICAgdGhpcy5kZWJ1Z01vZGUgPSBmYWxzZTtcbiAgICB9XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNjb3BlID0gZnVuY3Rpb24gKHNjb3BlRm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdGFydFNjb3BlKCk7XG4gICAgICAgIHZhciBrZWVwRm4gPSBmdW5jdGlvbiAobmRhcnJheSkgeyByZXR1cm4gX3RoaXMua2VlcChuZGFycmF5KTsgfTtcbiAgICAgICAgdmFyIHRyYWNrRm4gPSBmdW5jdGlvbiAobmRhcnJheSkgeyByZXR1cm4gX3RoaXMudHJhY2sobmRhcnJheSk7IH07XG4gICAgICAgIHZhciByZXN1bHQgPSBzY29wZUZuKGtlZXBGbiwgdHJhY2tGbik7XG4gICAgICAgIHRoaXMuZW5kU2NvcGUocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5lbmFibGVEZWJ1Z01vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVidWdNb2RlID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZWJ1Z2dpbmcgbW9kZSBpcyBPTi4gVGhlIG91dHB1dCBvZiBldmVyeSBtYXRoIGNhbGwgd2lsbCAnICtcbiAgICAgICAgICAgICdiZSBkb3dubG9hZGVkIHRvIENQVSBhbmQgY2hlY2tlZCBmb3IgTmFOcy4gJyArXG4gICAgICAgICAgICAnVGhpcyBzaWduaWZpY2FudGx5IGltcGFjdHMgcGVyZm9ybWFuY2UuJyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc3RhcnRTY29wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld1Njb3BlID0gW107XG4gICAgICAgIHRoaXMubmRhcnJheVNjb3Blcy5wdXNoKG5ld1Njb3BlKTtcbiAgICAgICAgdGhpcy5hY3RpdmVTY29wZSA9IG5ld1Njb3BlO1xuICAgICAgICB2YXIgbmV3TkRBcnJheXNUb0tlZXAgPSBbXTtcbiAgICAgICAgdGhpcy5uZGFycmF5c1RvS2VlcC5wdXNoKG5ld05EQXJyYXlzVG9LZWVwKTtcbiAgICAgICAgdGhpcy5hY3RpdmVTY29wZU5EQXJyYXlzVG9LZWVwID0gbmV3TkRBcnJheXNUb0tlZXA7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZW5kU2NvcGUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcnJheXNUb0tlZXAgPSB0aGlzLmFjdGl2ZVNjb3BlTkRBcnJheXNUb0tlZXA7XG4gICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlzVG9LZWVwID0gYXJyYXlzVG9LZWVwLmNvbmNhdChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RpdmVTY29wZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5kYXJyYXkgPSB0aGlzLmFjdGl2ZVNjb3BlW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNOREFycmF5RGF0YUluTGlzdChuZGFycmF5LCBhcnJheXNUb0tlZXApKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZGFycmF5LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5kYXJyYXlTY29wZXMucG9wKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlU2NvcGUgPSB0aGlzLm5kYXJyYXlTY29wZXMubGVuZ3RoID09PSAwID9cbiAgICAgICAgICAgIG51bGwgOlxuICAgICAgICAgICAgdGhpcy5uZGFycmF5U2NvcGVzW3RoaXMubmRhcnJheVNjb3Blcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5ICYmXG4gICAgICAgICAgICAhdGhpcy5pc05EQXJyYXlEYXRhSW5MaXN0KHJlc3VsdCwgdGhpcy5hY3RpdmVTY29wZU5EQXJyYXlzVG9LZWVwKSkge1xuICAgICAgICAgICAgdGhpcy50cmFjayhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIG5kYXJyYXlfMS5OREFycmF5ICYmXG4gICAgICAgICAgICAgICAgICAgICFfdGhpcy5pc05EQXJyYXlEYXRhSW5MaXN0KHIsIF90aGlzLmFjdGl2ZVNjb3BlTkRBcnJheXNUb0tlZXApKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyYWNrKHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmRhcnJheXNUb0tlZXAucG9wKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlU2NvcGVOREFycmF5c1RvS2VlcCA9IHRoaXMubmRhcnJheXNUb0tlZXAubGVuZ3RoID09PSAwID9cbiAgICAgICAgICAgIG51bGwgOlxuICAgICAgICAgICAgdGhpcy5uZGFycmF5c1RvS2VlcFt0aGlzLm5kYXJyYXlzVG9LZWVwLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmlzTkRBcnJheURhdGFJbkxpc3QgPSBmdW5jdGlvbiAobmRhcnJheSwgbmRhcnJheUxpc3QpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZGFycmF5TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5kYXJyYXlMaXN0W2ldLmdldERhdGEoKSA9PT0gbmRhcnJheS5nZXREYXRhKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUua2VlcCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlU2NvcGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2FmZU1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgdXNpbmcgbWF0aCBpbiBzYWZlIG1vZGUuIEVuY2xvc2UgYWxsICcgK1xuICAgICAgICAgICAgICAgICAgICAnbWF0aC5tZXRob2QoKSBjYWxscyBpbnNpZGUgYSBzY29wZTogJyArXG4gICAgICAgICAgICAgICAgICAgICdtYXRoLnNjb3BlKCgpID0+IHttYXRoLm1ldGhvZCgpOy4uLn0pIHRvIGF2b2lkIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWtzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlTkRBcnJheXNUb0tlZXAucHVzaChyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNoZWNrRm9yTmFOID0gZnVuY3Rpb24gKHZhbHMsIG5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odmFsc1tpXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSByZXN1bHQgb2YgdGhlIGxhc3QgbWF0aC5cIiArIG5hbWUgKyBcIiBoYXMgTmFOcy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS50cmFjayA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlU2NvcGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2FmZU1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgdXNpbmcgbWF0aCBpbiBzYWZlIG1vZGUuIEVuY2xvc2UgYWxsICcgK1xuICAgICAgICAgICAgICAgICAgICAnbWF0aC5tZXRob2QoKSBjYWxscyBpbnNpZGUgYSBzY29wZTogJyArXG4gICAgICAgICAgICAgICAgICAgICdtYXRoLnNjb3BlKCgpID0+IHttYXRoLm1ldGhvZCgpOy4uLn0pIHRvIGF2b2lkIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWtzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlLnB1c2gocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5tYXRNdWwgPSBmdW5jdGlvbiAoYSwgYiwgYU9yaWVudGF0aW9uLCBiT3JpZW50YXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFPcmllbnRhdGlvbiA9PT0gdm9pZCAwKSB7IGFPcmllbnRhdGlvbiA9IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVI7IH1cbiAgICAgICAgaWYgKGJPcmllbnRhdGlvbiA9PT0gdm9pZCAwKSB7IGJPcmllbnRhdGlvbiA9IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVI7IH1cbiAgICAgICAgdmFyIGlubmVyU2hhcGVBID0gKGFPcmllbnRhdGlvbiA9PT0gTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgPyBhLnNoYXBlWzFdIDogYS5zaGFwZVswXTtcbiAgICAgICAgdmFyIGlubmVyU2hhcGVCID0gKGJPcmllbnRhdGlvbiA9PT0gTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgPyBiLnNoYXBlWzBdIDogYi5zaGFwZVsxXTtcbiAgICAgICAgdXRpbC5hc3NlcnQoYS5yYW5rID09PSAyICYmIGIucmFuayA9PT0gMiwgXCJFcnJvciBpbiBtYXRNdWw6IGlucHV0cyBtdXN0IGJlIHJhbmsgMiwgZ290IHJhbmtzIFwiICsgYS5yYW5rICtcbiAgICAgICAgICAgIChcImFuZCBcIiArIGIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGlubmVyU2hhcGVBID09PSBpbm5lclNoYXBlQiwgXCJFcnJvciBpbiBtYXRNdWw6IGlubmVyIHNoYXBlcyAoXCIgKyBpbm5lclNoYXBlQSArIFwiKSBhbmQgKFwiICtcbiAgICAgICAgICAgIChpbm5lclNoYXBlQiArIFwiKSBvZiBOREFycmF5cyB3aXRoIHNoYXBlcyBcIiArIGEuc2hhcGUgKyBcIiBhbmQgXCIpICtcbiAgICAgICAgICAgIChiLnNoYXBlICsgXCIgYW5kIG9yaWVudGF0aW9ucyBcIiArIE1hdHJpeE9yaWVudGF0aW9uW2FPcmllbnRhdGlvbl0pICtcbiAgICAgICAgICAgIChcIiBhbmQgXCIgKyBNYXRyaXhPcmllbnRhdGlvbltiT3JpZW50YXRpb25dICsgXCIgbXVzdCBtYXRjaC5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ21hdE11bCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm1hdE11bEludGVybmFsKGEsIGIsIGFPcmllbnRhdGlvbiwgYk9yaWVudGF0aW9uKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZXhlY3V0ZU9wID0gZnVuY3Rpb24gKG5hbWUsIGYpIHtcbiAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGYoKTtcbiAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhciB0aW1lID0gdXRpbC5yaWdodFBhZCgocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgKyAnbXMnLCA5KTtcbiAgICAgICAgICAgIHZhciBwYWRkZWROYW1lID0gdXRpbC5yaWdodFBhZChuYW1lLCAyNSk7XG4gICAgICAgICAgICB2YXIgcmFuayA9IHJlc3VsdC5yYW5rO1xuICAgICAgICAgICAgdmFyIHNpemUgPSByZXN1bHQuc2l6ZTtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHV0aWwucmlnaHRQYWQocmVzdWx0LnNoYXBlICsgJycsIDE0KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiJWNcIiArIHBhZGRlZE5hbWUgKyBcIlxcdCVjXCIgKyB0aW1lICsgXCJcXHQlY1wiICsgcmFuayArIFwiRCBcIiArIHNoYXBlICsgXCJcXHQlY1wiICsgc2l6ZSwgJ2ZvbnQtd2VpZ2h0OmJvbGQnLCAnY29sb3I6cmVkJywgJ2NvbG9yOmJsdWUnLCAnY29sb3I6IG9yYW5nZScpO1xuICAgICAgICAgICAgdGhpcy5jaGVja0Zvck5hTih2YWxzLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmFjayhyZXN1bHQpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnZlY3RvclRpbWVzTWF0cml4ID0gZnVuY3Rpb24gKHYsIG1hdHJpeCkge1xuICAgICAgICB1dGlsLmFzc2VydCh2LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gdmVjdG9yVGltZXNNYXRyaXg6IGZpcnN0IGlucHV0IG11c3QgYmUgcmFuayAxLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyB2LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChtYXRyaXgucmFuayA9PT0gMiwgXCJFcnJvciBpbiB2ZWN0b3JUaW1lc01hdHJpeDogc2Vjb25kIGlucHV0IG11c3QgYmUgcmFuayAyLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBtYXRyaXgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYuc2l6ZSA9PT0gbWF0cml4LnNoYXBlWzBdLCBcIkVycm9yIGluIHZlY3RvclRpbWVzTWF0cml4OiBzaXplIG9mIHZlY3RvciAoXCIgKyB2LnNpemUgKyBcIikgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCBmaXJzdCBkaW1lbnNpb24gb2YgbWF0cml4IChcIiArIG1hdHJpeC5zaGFwZVswXSArIFwiKVwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdE11bCh2LmFzMkQoMSwgLTEpLCBtYXRyaXgpLmFzMUQoKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5tYXRyaXhUaW1lc1ZlY3RvciA9IGZ1bmN0aW9uIChtYXRyaXgsIHYpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodi5yYW5rID09PSAxLCBcIkVycm9yIGluIHZlY3RvclRpbWVzTWF0cml4OiBzZWNvbmQgaW5wdXQgbXVzdCByYW5rIDEsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIHYucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG1hdHJpeC5yYW5rID09PSAyLCBcIkVycm9yIGluIHZlY3RvclRpbWVzTWF0cml4OiBmaXJzdCBpbnB1dCBtdXN0IGJlIGEgcmFuayAyLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBtYXRyaXgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYuc2l6ZSA9PT0gbWF0cml4LnNoYXBlWzFdLCBcIkVycm9yIGluIHZlY3RvclRpbWVzTWF0cml4OiBzaXplIG9mIGZpcnN0IHJhbmsgMSBpbnB1dCBcIiArIHYuc2l6ZSArIFwiIFwiICtcbiAgICAgICAgICAgIFwibXVzdCBtYXRjaCBpbm5lciBkaW1lbnNpb24gb2Ygc2Vjb25kIHJhbmsgMiBpbnB1dCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJzaGFwZSBcIiArIG1hdHJpeC5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdE11bChtYXRyaXgsIHYuYXMyRCgtMSwgMSkpLmFzMUQoKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5kb3RQcm9kdWN0ID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICB1dGlsLmFzc2VydCh2MS5yYW5rID09PSAxICYmIHYyLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gZG90UHJvZHVjdDogaW5wdXRzIG11c3QgYmUgcmFuayAxLCBidXQgZ290IHJhbmtzIFwiICtcbiAgICAgICAgICAgICh2MS5yYW5rICsgXCIgYW5kIFwiICsgdjIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYxLnNpemUgPT09IHYyLnNpemUsIFwiRXJyb3IgaW4gZG90UHJvZHVjdDogc2l6ZSBvZiBpbnB1dHMgKFwiICsgdjEuc2l6ZSArIFwiKSBhbmQgKFwiICtcbiAgICAgICAgICAgICh2Mi5zaXplICsgXCIpIG11c3QgbWF0Y2guXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0TXVsKHYxLmFzMkQoMSwgLTEpLCB2Mi5hczJEKC0xLCAxKSkuYXNTY2FsYXIoKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5vdXRlclByb2R1Y3QgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYxLnJhbmsgPT09IDEgJiYgdjIucmFuayA9PT0gMSwgXCJFcnJvciBpbiBvdXRlclByb2R1Y3Q6IGlucHV0cyBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCByYW5rcyBcIiArXG4gICAgICAgICAgICAodjEucmFuayArIFwiIGFuZCBcIiArIHYyLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRNdWwodjEuYXMyRCgtMSwgMSksIHYyLmFzMkQoMSwgLTEpKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnY2xvbmUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jbG9uZUludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24gKG5kYXJyYXksIG5ld1NoYXBlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignbWF0aC5yZXNoYXBlKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIGNhbGwgcmVzaGFwZSgpICcgK1xuICAgICAgICAgICAgJ2RpcmVjdGx5IG9uIHRoZSBuZGFycmF5IG9iamVjdCcpO1xuICAgICAgICByZXR1cm4gbmRhcnJheS5yZXNoYXBlKG5ld1NoYXBlKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zbGljZTFEID0gZnVuY3Rpb24gKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzbGljZV91dGlsLmFzc2VydFBhcmFtc1ZhbGlkKGlucHV0LCBbYmVnaW5dLCBbc2l6ZV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3NsaWNlMUQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zbGljZTFESW50ZXJuYWwoaW5wdXQsIGJlZ2luLCBzaXplKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2xpY2UyRCA9IGZ1bmN0aW9uIChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2xpY2VfdXRpbC5hc3NlcnRQYXJhbXNWYWxpZChpbnB1dCwgYmVnaW4sIHNpemUpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3NsaWNlMkQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zbGljZTJESW50ZXJuYWwoaW5wdXQsIGJlZ2luLCBzaXplKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2xpY2UzRCA9IGZ1bmN0aW9uIChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2xpY2VfdXRpbC5hc3NlcnRQYXJhbXNWYWxpZChpbnB1dCwgYmVnaW4sIHNpemUpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3NsaWNlM0QnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zbGljZTNESW50ZXJuYWwoaW5wdXQsIGJlZ2luLCBzaXplKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2xpY2U0RCA9IGZ1bmN0aW9uIChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc2xpY2VfdXRpbC5hc3NlcnRQYXJhbXNWYWxpZChpbnB1dCwgYmVnaW4sIHNpemUpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3NsaWNlNEQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zbGljZTRESW50ZXJuYWwoaW5wdXQsIGJlZ2luLCBzaXplKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY29weTJEID0gZnVuY3Rpb24gKHNvdXJjZSwgc291cmNlQmVnaW4sIHNvdXJjZVNpemUsIGRlc3QsIGRlc3RCZWdpbiwgZGVzdFNpemUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoc291cmNlQmVnaW5bMF0gKyBzb3VyY2VTaXplWzBdIDw9IHNvdXJjZS5zaGFwZVswXSAmJlxuICAgICAgICAgICAgc291cmNlQmVnaW5bMV0gKyBzb3VyY2VTaXplWzFdIDw9IHNvdXJjZS5zaGFwZVsxXSwgXCJFcnJvciBpbiBjb3B5MkQ6IHJlcXVlc3RlZCBzb3VyY2Ugc3RhcnQgcG9zaXRpb24gXCIgKyBzb3VyY2VCZWdpbiArIFwiIFwiICtcbiAgICAgICAgICAgIChcImFuZCBzb3VyY2Ugc2l6ZSBcIiArIHNvdXJjZVNpemUgKyBcIiB3b3VsZCBvdmVyZmxvdyBzb3VyY2UgTkRBcnJheVwiKSArXG4gICAgICAgICAgICAoXCJvZiBzaGFwZSBcIiArIHNvdXJjZS5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGRlc3RCZWdpblswXSArIGRlc3RTaXplWzBdIDw9IGRlc3Quc2hhcGVbMF0gJiZcbiAgICAgICAgICAgIGRlc3RCZWdpblsxXSArIGRlc3RTaXplWzFdIDw9IGRlc3Quc2hhcGVbMV0sIFwiRXJyb3IgaW4gY29weTJEOiByZXF1ZXN0ZWQgZGVzdCBzdGFydCBwb3NpdGlvbiBcIiArIGRlc3RCZWdpbiArIFwiIFwiICtcbiAgICAgICAgICAgIChcImFuZCBzb3VyY2Ugc2l6ZSBcIiArIGRlc3RTaXplICsgXCIgd291bGQgb3ZlcmZsb3cgZGVzdCBOREFycmF5IG9mXCIpICtcbiAgICAgICAgICAgIChcInNoYXBlIFwiICsgZGVzdC5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIGNvcHkyZF91dGlsLnZhbGlkYXRlU2hhcGVzKHNvdXJjZVNpemUsIGRlc3RTaXplKTtcbiAgICAgICAgdGhpcy5leGVjdXRlT3AoJ2NvcHkyRCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNvcHkyREludGVybmFsKHNvdXJjZSwgc291cmNlQmVnaW4sIHNvdXJjZVNpemUsIGRlc3QsIGRlc3RCZWdpbiwgZGVzdFNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbmNhdDFEID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29uY2F0X3V0aWwuYXNzZXJ0UGFyYW1zKGEuc2hhcGUsIGIuc2hhcGUsIDApO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2NvbmNhdDFEJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY29uY2F0MURJbnRlcm5hbChhLCBiKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY29uY2F0MkQgPSBmdW5jdGlvbiAoYSwgYiwgYXhpcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjb25jYXRfdXRpbC5hc3NlcnRQYXJhbXMoYS5zaGFwZSwgYi5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnY29uY2F0MkQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb25jYXQyREludGVybmFsKGEsIGIsIGF4aXMpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb25jYXQzRCA9IGZ1bmN0aW9uIChuZGFycmF5MSwgbmRhcnJheTIsIGF4aXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29uY2F0X3V0aWwuYXNzZXJ0UGFyYW1zKG5kYXJyYXkxLnNoYXBlLCBuZGFycmF5Mi5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnY29uY2F0M0QnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb25jYXQzREludGVybmFsKG5kYXJyYXkxLCBuZGFycmF5MiwgYXhpcyk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbmNhdDREID0gZnVuY3Rpb24gKG5kYXJyYXkxLCBuZGFycmF5MiwgYXhpcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjb25jYXRfdXRpbC5hc3NlcnRQYXJhbXMobmRhcnJheTEuc2hhcGUsIG5kYXJyYXkyLnNoYXBlLCBheGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdjb25jYXQ0RCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbmNhdDRESW50ZXJuYWwobmRhcnJheTEsIG5kYXJyYXkyLCBheGlzKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubG9nU3VtRXhwID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdsb2dTdW1FeHAnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5sb2dTdW1FeHBJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzdW0nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zdW1JbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYXJnTWluID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdhcmdNaW4nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5hcmdNaW5JbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYXJnTWF4ID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdhcmdNYXgnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5hcmdNYXhJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYXJnTWF4RXF1YWxzID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKHgxLnNoYXBlLCB4Mi5zaGFwZSwgJ0Vycm9yIGluIGFyZ01heEVxdWFsczogJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnYXJnTWF4RXF1YWxzJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYXJnTWF4RXF1YWxzSW50ZXJuYWwoeDEsIHgyKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUudG9wSyA9IGZ1bmN0aW9uIChuZGFycmF5LCBrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGsgPD0gbmRhcnJheS5zaXplLCBcIkVycm9yIGluIHRvcEs6IGsgdmFsdWUgKFwiICsgayArIFwiKSBtdXN0IGJlIGxlc3MgdGhhbiBzaXplIG9mIGlucHV0IFwiICtcbiAgICAgICAgICAgIChcIm5kYXJyYXksIGdvdCBzaGFwZSBcIiArIG5kYXJyYXkuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0aGlzLmV4ZWN1dGVPcCgndG9wSycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IF90aGlzLnRvcEtJbnRlcm5hbChuZGFycmF5LCBrKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWVzO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFjayhyZXN1bHQuaW5kaWNlcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdtaW4nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5taW5JbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdtYXgnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tYXhJbnRlcm5hbChuZGFycmF5KTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc29mdG1heCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnc29mdG1heCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zY29wZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxzZSA9IF90aGlzLmxvZ1N1bUV4cCh4KTtcbiAgICAgICAgICAgICAgICB2YXIgbG9nUmVzdWx0ID0gX3RoaXMuYXJyYXlNaW51c1NjYWxhcih4LCBsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5leHAobG9nUmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zd2l0Y2hEaW0gPSBmdW5jdGlvbiAoYSwgbmV3RGltKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGEucmFuayA9PT0gbmV3RGltLmxlbmd0aCwgXCJFcnJvciBpbiBzd2l0Y2hEaW06IGxlbmd0aCBvZiBpbnB1dCBzaGFwZSBcIiArIGEuc2hhcGUgKyBcIiBcIiArXG4gICAgICAgICAgICAoXCJtdXN0IG1hdGNoIHNpemUgb2YgbmV3RGltIGFycmF5IFwiICsgbmV3RGltICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzd2l0Y2hEaW0nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zd2l0Y2hEaW1JbnRlcm5hbChhLCBuZXdEaW0pOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zY2FsYXJQbHVzQXJyYXkgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB1dGlsLmFzc2VydChjLnNpemUgPT09IDEsIFwiRXJyb3IgaW4gc2NhbGFyUGx1c0FycmF5OiBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgYy5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGMsIGEpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNjYWxhck1pbnVzQXJyYXkgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB1dGlsLmFzc2VydChjLnNpemUgPT09IDEsIFwiRXJyb3IgaW4gc2NhbGFyTWludXNBcnJheTogZmlyc3QgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YihjLCBhKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hcnJheU1pbnVzU2NhbGFyID0gZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYy5zaXplID09PSAxLCBcIkVycm9yIGluIGFycmF5TWludXNTY2FsYXI6IHNlY29uZCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYnV0IFwiICtcbiAgICAgICAgICAgIChcImdvdCByYW5rIFwiICsgYy5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKGEsIGMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnbmVnJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubmVnSW50ZXJuYWwoYSk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0ZWRTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdhZGQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5hZGRJbnRlcm5hbChhLCBiKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYWRkU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gYWRkU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGEsIGIpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0ZWRTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzdWInLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zdWJJbnRlcm5hbChhLCBiKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc3ViU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gc3ViU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKGEsIGIpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RlZFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ211bHRpcGx5JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubXVsdGlwbHlJbnRlcm5hbChhLCBiKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZWxlbWVudFdpc2VNdWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVN0cmljdChhLCBiKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5tdWx0aXBseVN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIG11bHRpcGx5U3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoYSwgYik7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RlZFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2RpdmlkZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmRpdmlkZUludGVybmFsKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5kaXZpZGVTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBkaXZpZGVTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGUoYSwgYik7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2NhbGFyRGl2aWRlZEJ5QXJyYXkgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB1dGlsLmFzc2VydChjLnNpemUgPT09IDEsIFwiRXJyb3IgaW4gc2NhbGFyRGl2aWRlZEJ5QXJyYXk6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgXCIgK1xuICAgICAgICAgICAgKFwiZ290IE5EQXJyYXkgb2YgcmFuayBcIiArIGMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZShjLCBhKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hcnJheURpdmlkZWRCeVNjYWxhciA9IGZ1bmN0aW9uIChhLCBjKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGMuc2l6ZSA9PT0gMSwgXCJFcnJvciBpbiBhcnJheURpdmlkZWRCeVNjYWxhcjogc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBcIiArXG4gICAgICAgICAgICAoXCJidXQgZ290IE5EQXJyYXkgb2YgcmFuayBcIiArIGMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZShhLCBjKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5leHAgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2V4cCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmV4cEludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2xvZycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmxvZ0ludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzcXJ0JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc3FydEludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2FicycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmFic0ludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5yZWx1ID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdyZWx1JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVsdUludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zaWdtb2lkID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzaWdtb2lkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2lnbW9pZEludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zaW4gPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3NpbicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNpbkludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb3MgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2NvcycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvc0ludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS50YW4gPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3RhbicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRhbkludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hc2luID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdhc2luJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYXNpbkludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hY29zID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdhY29zJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYWNvc0ludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hdGFuID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdhdGFuJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYXRhbkludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zaW5oID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzaW5oJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2luaEludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb3NoID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdjb3NoJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY29zaEludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS50YW5oID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCd0YW5oJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGFuaEludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzdGVwJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc3RlcEludGVybmFsKG5kYXJyYXkpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zY2FsZWRBcnJheUFkZCA9IGZ1bmN0aW9uIChjMSwgYSwgYzIsIGIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoYzEuc2l6ZSA9PT0gMSwgXCJFcnJvciBpbiBzY2FsZWRBcnJheUFkZDogZmlyc3QgYXJndW1lbnQgbXVzdCByYW5rIDAsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwiIHJhbmsgXCIgKyBjMS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoYzIuc2l6ZSA9PT0gMSwgXCJFcnJvciBpbiBzY2FsZWRBcnJheUFkZDogdGhpcmQgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwiTkRBcnJheSBvZiByYW5rIFwiICsgYzIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIHNjYWxlZEFycmF5QWRkOiAnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdzY2FsZWRBcnJheUFkZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNjYWxlZEFycmF5QWRkSW50ZXJuYWwoYzEsIGEsIGMyLCBiKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2NhbGFyVGltZXNBcnJheSA9IGZ1bmN0aW9uIChjLCBhKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGMuc2l6ZSA9PT0gMSwgXCJFcnJvciBpbiBhcnJheURpdmlkZWRCeVNjYWxhcjogZmlyc3QgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJnb3QgcmFuayBcIiArIGMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KGMsIGEpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmVsZW1lbnRXaXNlTXVsQnJvYWRjYXN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYS5yYW5rID09PSAyLCBcIkVycm9yIGluIGVsZW1lbnRXaXNlTXVsQnJvYWRjYXN0OiBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIFwiICtcbiAgICAgICAgICAgIChcInJhbmsgMiwgYnV0IGdvdCByYW5rIFwiICsgYS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoYi5yYW5rID09PSAyLCBcIkVycm9yIGluIGVsZW1lbnRXaXNlTXVsQnJvYWRjYXN0OiBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIDIsIGJ1dCBnb3QgcmFuayBcIiArIGIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KGEsIGIpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbnYyZCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIGJpYXMsIHN0cmlkZXMsIHBhZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gY29udjJkOiB4IG11c3QgYmUgcmFuayAzLCBidXQgZ290IHJhbmsgXCIgKyB4LnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGZpbHRlci5yYW5rID09PSA0LCBcIkVycm9yIGluIGNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKGZpbHRlci5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKGJpYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoYmlhcy5yYW5rID09PSAxLCBcIkVycm9yIGluIGNvbnYyZDogYmlhcyBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgICAgICAoYmlhcy5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydCh4LnNoYXBlWzJdID09PSBmaWx0ZXIuc2hhcGVbMl0sIFwiRXJyb3IgaW4gY29udjJkOiBkZXB0aCBvZiBpbnB1dCAoXCIgKyB4LnNoYXBlWzJdICsgXCIpIG11c3QgbWF0Y2ggIFwiICtcbiAgICAgICAgICAgIChcImlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIgKyBmaWx0ZXIuc2hhcGVbMl0gKyBcIi5cIikpO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gZmlsdGVyLnNoYXBlWzBdO1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBmaWx0ZXIuc2hhcGVbMV07XG4gICAgICAgIHZhciBvdXREZXB0aCA9IGZpbHRlci5zaGFwZVszXTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKHN0cmlkZXMpLCBzdHJpZGVIZWlnaHQgPSBfYVswXSwgc3RyaWRlV2lkdGggPSBfYVsxXTtcbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVDb252SW5mbyh4LnNoYXBlLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBvdXREZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgcGFkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdjb252MmQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb252MmRJbnRlcm5hbCh4LCBmaWx0ZXIsIGJpYXMsIGNvbnZJbmZvKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuY29udjJkQmFja1Byb3AgPSBmdW5jdGlvbiAoeCwgZHksIGZpbHRlciwgc3RyaWRlcywgcGFkKSB7XG4gICAgICAgIHZhciBkdyA9IHRoaXMuY29udjJkRGVyRmlsdGVyKHgsIGR5LCBmaWx0ZXIuc2hhcGUsIHN0cmlkZXMsIHBhZCk7XG4gICAgICAgIHZhciBkYiA9IHRoaXMuY29udjJkRGVyQmlhcyhkeSk7XG4gICAgICAgIHZhciBkeCA9IHRoaXMuY29udjJkRGVySW5wdXQoeC5zaGFwZSwgZHksIGZpbHRlciwgc3RyaWRlcywgcGFkKTtcbiAgICAgICAgcmV0dXJuIHsgZGI6IGRiLCBkdzogZHcsIGR4OiBkeCB9O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbnYyZERlcklucHV0ID0gZnVuY3Rpb24gKGluU2hhcGUsIGR5LCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaW5EZXB0aCA9IGluU2hhcGVbMl07XG4gICAgICAgIHZhciBvdXREZXB0aCA9IGR5LnNoYXBlWzJdO1xuICAgICAgICB1dGlsLmFzc2VydChpblNoYXBlLmxlbmd0aCA9PT0gMywgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogeCBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgIChpblNoYXBlLmxlbmd0aCArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGR5LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGR5IG11c3QgYmUgcmFuayAzLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBkeS5yYW5rKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGZpbHRlci5yYW5rID09PSA0LCBcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGZpbHRlci5yYW5rKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGluRGVwdGggPT09IGZpbHRlci5zaGFwZVsyXSwgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZGVwdGggb2YgaW5wdXQgKFwiICsgaW5EZXB0aCArIFwiKSBtdXN0IFwiICtcbiAgICAgICAgICAgIChcIm1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIgKyBmaWx0ZXIuc2hhcGVbMl0gKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChvdXREZXB0aCA9PT0gZmlsdGVyLnNoYXBlWzNdLCBcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkZXB0aCBvZiBvdXRwdXQgKFwiICsgb3V0RGVwdGggKyBcIikgbXVzdFwiICtcbiAgICAgICAgICAgIChcIm1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiICsgZmlsdGVyLnNoYXBlWzNdICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGZpbHRlci5zaGFwZVswXTtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gZmlsdGVyLnNoYXBlWzFdO1xuICAgICAgICB2YXIgX2EgPSBwYXJzZVR1cGxlUGFyYW0oc3RyaWRlcyksIHN0cmlkZUhlaWdodCA9IF9hWzBdLCBzdHJpZGVXaWR0aCA9IF9hWzFdO1xuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnZJbmZvKGluU2hhcGUsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIG91dERlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoLCBwYWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ2NvbnYyZERlcklucHV0JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY29udjJkRGVySW5wdXRJbnRlcm5hbChkeSwgZmlsdGVyLCBjb252SW5mbyk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbnYyZERlckJpYXMgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5jb252MmREZXJCaWFzSW50ZXJuYWwoZHkpKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb252MmREZXJGaWx0ZXIgPSBmdW5jdGlvbiAoeCwgZHksIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCkge1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiB4IG11c3QgYmUgcmFuayAzLCBidXQgZ290IHNoYXBlIFwiICtcbiAgICAgICAgICAgICh4LnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZHkucmFuayA9PT0gMywgXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGR5IG11c3QgYmUgcmFuayAzLCBidXQgZ290IHNoYXBlIFwiICtcbiAgICAgICAgICAgIChkeS5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGZpbHRlclNpemUubGVuZ3RoID09PSA0LCBcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZmlsdGVyU2l6ZSBtdXN0IGJlIGxlbmd0aCA0LCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChmaWx0ZXJTaXplICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5zaGFwZVsyXSA9PT0gZmlsdGVyU2l6ZVsyXSwgXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGRlcHRoIG9mIHggXCIgKyB4LnNoYXBlWzJdICsgXCIpIG11c3QgXCIgK1xuICAgICAgICAgICAgKFwibWF0Y2ggaW5wdXQgZGVwdGggaW4gZmlsdGVyIChcIiArIGZpbHRlclNpemVbMl0gKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChkeS5zaGFwZVsyXSA9PT0gZmlsdGVyU2l6ZVszXSwgXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGRlcHRoIG9mIGR5IChcIiArIGR5LnNoYXBlWzJdICsgXCIpIG11c3QgXCIgK1xuICAgICAgICAgICAgKFwibWF0Y2ggb3V0cHV0IGRlcHRoIGZvciBmaWx0ZXIgKFwiICsgZmlsdGVyU2l6ZVszXSArIFwiKS5cIikpO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gZmlsdGVyU2l6ZVswXTtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gZmlsdGVyU2l6ZVsxXTtcbiAgICAgICAgdmFyIG91dERlcHRoID0gZmlsdGVyU2l6ZVszXTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKHN0cmlkZXMpLCBzdHJpZGVIZWlnaHQgPSBfYVswXSwgc3RyaWRlV2lkdGggPSBfYVsxXTtcbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVDb252SW5mbyh4LnNoYXBlLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBvdXREZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgcGFkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5jb252MmREZXJGaWx0ZXJJbnRlcm5hbCh4LCBkeSwgY29udkluZm8pKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb252MmRUcmFuc3Bvc2UgPSBmdW5jdGlvbiAoeCwgZmlsdGVyLCBvdXRwdXRTaGFwZSwgc3RyaWRlcywgcGFkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnYyZERlcklucHV0KG91dHB1dFNoYXBlLCB4LCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUubWF4UG9vbCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAzLCAnRXJyb3IgaW4gbWF4UG9vbDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgJyArIHgucmFuayArICcuJyk7XG4gICAgICAgIHZhciBfYSA9IHBhcnNlVHVwbGVQYXJhbShmaWx0ZXJTaXplKSwgZmlsdGVySGVpZ2h0ID0gX2FbMF0sIGZpbHRlcldpZHRoID0gX2FbMV07XG4gICAgICAgIHZhciBvdXREZXB0aCA9IHguc2hhcGVbMl07XG4gICAgICAgIHZhciBfYiA9IHBhcnNlVHVwbGVQYXJhbShzdHJpZGVzKSwgc3RyaWRlSGVpZ2h0ID0gX2JbMF0sIHN0cmlkZVdpZHRoID0gX2JbMV07XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlQ29udkluZm8oeC5zaGFwZSwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgb3V0RGVwdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIHBhZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnbWF4UG9vbCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm1heFBvb2xJbnRlcm5hbCh4LCBjb252SW5mbyk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm1heFBvb2xCYWNrcHJvcCA9IGZ1bmN0aW9uIChkeSwgeCwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGR5LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKGR5LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoeC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKGZpbHRlclNpemUpLCBmaWx0ZXJIZWlnaHQgPSBfYVswXSwgZmlsdGVyV2lkdGggPSBfYVsxXTtcbiAgICAgICAgdmFyIG91dERlcHRoID0geC5zaGFwZVsyXTtcbiAgICAgICAgdmFyIF9iID0gcGFyc2VUdXBsZVBhcmFtKHN0cmlkZXMpLCBzdHJpZGVIZWlnaHQgPSBfYlswXSwgc3RyaWRlV2lkdGggPSBfYlsxXTtcbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVDb252SW5mbyh4LnNoYXBlLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBvdXREZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgcGFkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdtYXhQb29sQmFja3Byb3AnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tYXhQb29sQmFja3Byb3BJbnRlcm5hbChkeSwgeCwgY29udkluZm8pOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5taW5Qb29sID0gZnVuY3Rpb24gKHgsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gbWluUG9vbDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIgKyB4LnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHZhciBfYSA9IHBhcnNlVHVwbGVQYXJhbShmaWx0ZXJTaXplKSwgZmlsdGVySGVpZ2h0ID0gX2FbMF0sIGZpbHRlcldpZHRoID0gX2FbMV07XG4gICAgICAgIHZhciBvdXREZXB0aCA9IHguc2hhcGVbMl07XG4gICAgICAgIHZhciBfYiA9IHBhcnNlVHVwbGVQYXJhbShzdHJpZGVzKSwgc3RyaWRlSGVpZ2h0ID0gX2JbMF0sIHN0cmlkZVdpZHRoID0gX2JbMV07XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlQ29udkluZm8oeC5zaGFwZSwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgb3V0RGVwdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIHBhZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnbWluUG9vbCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm1pblBvb2xJbnRlcm5hbCh4LCBjb252SW5mbyk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmF2Z1Bvb2wgPSBmdW5jdGlvbiAoeCwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMywgXCJFcnJvciBpbiBhdmdQb29sOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIiArIHgucmFuayArIFwiLlwiKTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKGZpbHRlclNpemUpLCBmaWx0ZXJIZWlnaHQgPSBfYVswXSwgZmlsdGVyV2lkdGggPSBfYVsxXTtcbiAgICAgICAgdmFyIG91dERlcHRoID0geC5zaGFwZVsyXTtcbiAgICAgICAgdmFyIF9iID0gcGFyc2VUdXBsZVBhcmFtKHN0cmlkZXMpLCBzdHJpZGVIZWlnaHQgPSBfYlswXSwgc3RyaWRlV2lkdGggPSBfYlsxXTtcbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVDb252SW5mbyh4LnNoYXBlLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBvdXREZXB0aCwgc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgcGFkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdhdmdQb29sJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuYXZnUG9vbEludGVybmFsKHgsIGNvbnZJbmZvKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUucmVzaXplQmlsaW5lYXIzRCA9IGZ1bmN0aW9uICh4LCBuZXdTaGFwZTJELCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFsaWduQ29ybmVycyA9PT0gdm9pZCAwKSB7IGFsaWduQ29ybmVycyA9IGZhbHNlOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMywgXCJFcnJvciBpbiByZXNpemVCaWxpbmVhcjNEOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBcIiArIHgucmFuayArIFwiLlwiKTtcbiAgICAgICAgdXRpbC5hc3NlcnQobmV3U2hhcGUyRC5sZW5ndGggPT09IDIsIFwiRXJyb3IgaW4gcmVzaXplQmlsaW5lYXIzRDogbmV3IHNoYXBlIG11c3QgMkQsIGJ1dCBnb3Qgc2hhcGUgXCIgK1xuICAgICAgICAgICAgKG5ld1NoYXBlMkQgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlT3AoJ3Jlc2l6ZUJpbGluZWFyM0QnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZXNpemVCaWxpbmVhcjNESW50ZXJuYWwoeCwgbmV3U2hhcGUyRCwgYWxpZ25Db3JuZXJzKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuYmF0Y2hOb3JtYWxpemF0aW9uM0QgPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodmFyaWFuY2VFcHNpbG9uID09PSB2b2lkIDApIHsgdmFyaWFuY2VFcHNpbG9uID0gLjAwMTsgfVxuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDMsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgICh4LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChtZWFuLnJhbmsgPT09IDMgfHwgbWVhbi5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiBtZWFuIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgXCIgK1xuICAgICAgICAgICAgKFwiZ290IHJhbmsgXCIgKyBtZWFuLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh2YXJpYW5jZS5yYW5rID09PSAzIHx8IHZhcmlhbmNlLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IHZhcmlhbmNlIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBcIiArXG4gICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyB2YXJpYW5jZS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKHNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHNjYWxlLnJhbmsgPT09IDMgfHwgc2NhbGUucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogc2NhbGUgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyBzY2FsZS5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KG9mZnNldC5yYW5rID09PSAzIHx8IG9mZnNldC5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiBvZmZzZXQgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgICAgICAoXCJidXQgZ290IHJhbmsgXCIgKyBvZmZzZXQucmFuayArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdiYXRjaE5vcm0zRCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmJhdGNoTm9ybWFsaXphdGlvbjNESW50ZXJuYWwoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm11bHRpUk5OQ2VsbCA9IGZ1bmN0aW9uIChsc3RtQ2VsbHMsIGRhdGEsIGMsIGgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoZGF0YS5zaGFwZVswXSA9PT0gMSwgXCJFcnJvciBpbiBtdWx0aVJOTkNlbGw6IGZpcnN0IGRpbWVuc2lvbiBvZiBkYXRhIGlzIFwiICsgZGF0YS5zaGFwZVswXSArIFwiLCBcIiArXG4gICAgICAgICAgICBcImJ1dCBiYXRjaCBzaXplcyA+IDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkLlwiKTtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gZGF0YTtcbiAgICAgICAgICAgIHZhciBuZXdTdGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbHN0bUNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IGxzdG1DZWxsc1tpXShpbnB1dCwgY1tpXSwgaFtpXSk7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVzLnB1c2gob3V0cHV0WzBdKTtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZXMucHVzaChvdXRwdXRbMV0pO1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb3V0cHV0WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld1N0YXRlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuZXdDID0gW107XG4gICAgICAgIHZhciBuZXdIID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBuZXdDLnB1c2gocmVzW2ldKTtcbiAgICAgICAgICAgIG5ld0gucHVzaChyZXNbaSArIDFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25ld0MsIG5ld0hdO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmJhc2ljTFNUTUNlbGwgPSBmdW5jdGlvbiAoZm9yZ2V0QmlhcywgbHN0bUtlcm5lbCwgbHN0bUJpYXMsIGRhdGEsIGMsIGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuc2NvcGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoZGF0YS5zaGFwZVswXSA9PT0gMSwgXCJFcnJvciBpbiBtdWx0aVJOTkNlbGw6IGZpcnN0IGRpbWVuc2lvbiBvZiBkYXRhIGlzIFwiICtcbiAgICAgICAgICAgICAgICAoZGF0YS5zaGFwZVswXSArIFwiLCBidXQgYmF0Y2ggc2l6ZXMgPiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZC5cIikpO1xuICAgICAgICAgICAgdmFyIGNvbWJpbmVkID0gX3RoaXMuY29uY2F0MUQoZGF0YS5hczFEKCksIGguYXMxRCgpKTtcbiAgICAgICAgICAgIHZhciB3ZWlnaHRlZCA9IF90aGlzLnZlY3RvclRpbWVzTWF0cml4KGNvbWJpbmVkLCBsc3RtS2VybmVsKTtcbiAgICAgICAgICAgIHZhciByZXMgPSBfdGhpcy5hZGRTdHJpY3Qod2VpZ2h0ZWQsIGxzdG1CaWFzKTtcbiAgICAgICAgICAgIHZhciBzbGljZVNpemUgPSByZXMuc2l6ZSAvIDQ7XG4gICAgICAgICAgICB2YXIgaSA9IF90aGlzLnNsaWNlMUQocmVzLCAwLCBzbGljZVNpemUpO1xuICAgICAgICAgICAgdmFyIGogPSBfdGhpcy5zbGljZTFEKHJlcywgc2xpY2VTaXplLCBzbGljZVNpemUpO1xuICAgICAgICAgICAgdmFyIGYgPSBfdGhpcy5zbGljZTFEKHJlcywgc2xpY2VTaXplICogMiwgc2xpY2VTaXplKTtcbiAgICAgICAgICAgIHZhciBvID0gX3RoaXMuc2xpY2UxRChyZXMsIHNsaWNlU2l6ZSAqIDMsIHNsaWNlU2l6ZSk7XG4gICAgICAgICAgICB2YXIgbmV3QyA9IF90aGlzLmFkZFN0cmljdChfdGhpcy5tdWx0aXBseVN0cmljdChjLmFzMUQoKSwgX3RoaXMuc2lnbW9pZChfdGhpcy5zY2FsYXJQbHVzQXJyYXkoZm9yZ2V0QmlhcywgZikpKSwgX3RoaXMubXVsdGlwbHlTdHJpY3QoX3RoaXMuc2lnbW9pZChpKSwgX3RoaXMudGFuaChqKSkpO1xuICAgICAgICAgICAgdmFyIG5ld0ggPSBfdGhpcy5tdWx0aXBseVN0cmljdChfdGhpcy50YW5oKG5ld0MpLCBfdGhpcy5zaWdtb2lkKG8pKTtcbiAgICAgICAgICAgIHJldHVybiBbbmV3QywgbmV3SF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW3Jlc1swXS5hczJEKDEsIC0xKSwgcmVzWzFdLmFzMkQoMSwgLTEpXTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5tdWx0aW5vbWlhbCA9IGZ1bmN0aW9uIChwcm9iYWJpbGl0aWVzLCBudW1TYW1wbGVzLCBzZWVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBudW1PdXRjb21lcyA9IHByb2JhYmlsaXRpZXMuc2l6ZTtcbiAgICAgICAgaWYgKG51bU91dGNvbWVzIDwgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbXVsdGlub21pYWw6IHlvdSBuZWVkIGF0IGxlYXN0IDIgb3V0Y29tZXMsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgICAgIChudW1PdXRjb21lcyArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VlZCA9IHNlZWQgfHwgTWF0aC5yYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZU9wKCdtdWx0aW5vbWlhbCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm11bHRpbm9taWFsSW50ZXJuYWwocHJvYmFiaWxpdGllcywgbnVtU2FtcGxlcywgc2VlZCk7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLm9uZUhvdCA9IGZ1bmN0aW9uIChpbmRpY2VzLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9uVmFsdWUgPT09IHZvaWQgMCkgeyBvblZhbHVlID0gMTsgfVxuICAgICAgICBpZiAob2ZmVmFsdWUgPT09IHZvaWQgMCkgeyBvZmZWYWx1ZSA9IDA7IH1cbiAgICAgICAgaWYgKGRlcHRoIDwgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gb25lSG90OiBkZXB0aCBtdXN0IGJlID49MiwgYnV0IGl0IGlzIFwiICsgZGVwdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVPcCgnb25lSG90JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25lSG90SW50ZXJuYWwoaW5kaWNlcywgZGVwdGgsIG9uVmFsdWUsIG9mZlZhbHVlKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTkRBcnJheU1hdGg7XG59KCkpO1xuZXhwb3J0cy5OREFycmF5TWF0aCA9IE5EQXJyYXlNYXRoO1xudmFyIE1hdHJpeE9yaWVudGF0aW9uO1xuKGZ1bmN0aW9uIChNYXRyaXhPcmllbnRhdGlvbikge1xuICAgIE1hdHJpeE9yaWVudGF0aW9uW01hdHJpeE9yaWVudGF0aW9uW1wiUkVHVUxBUlwiXSA9IDBdID0gXCJSRUdVTEFSXCI7XG4gICAgTWF0cml4T3JpZW50YXRpb25bTWF0cml4T3JpZW50YXRpb25bXCJUUkFOU1BPU0VEXCJdID0gMV0gPSBcIlRSQU5TUE9TRURcIjtcbn0pKE1hdHJpeE9yaWVudGF0aW9uID0gZXhwb3J0cy5NYXRyaXhPcmllbnRhdGlvbiB8fCAoZXhwb3J0cy5NYXRyaXhPcmllbnRhdGlvbiA9IHt9KSk7XG5mdW5jdGlvbiBwYXJzZVR1cGxlUGFyYW0ocGFyYW0pIHtcbiAgICByZXR1cm4gdHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyA/IFtwYXJhbSwgcGFyYW1dIDogcGFyYW07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/math.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/math_cpu.js":
/*!**********************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/math_cpu.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar seedrandom = __webpack_require__(/*! seedrandom */ \"./node_modules/seedrandom/index.js\");\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar concat_util = __webpack_require__(/*! ./concat_util */ \"./node_modules/deeplearn/dist/src/math/concat_util.js\");\nvar conv_util = __webpack_require__(/*! ./conv_util */ \"./node_modules/deeplearn/dist/src/math/conv_util.js\");\nvar copy2D_util = __webpack_require__(/*! ./copy2d_util */ \"./node_modules/deeplearn/dist/src/math/copy2d_util.js\");\nvar math_1 = __webpack_require__(/*! ./math */ \"./node_modules/deeplearn/dist/src/math/math.js\");\nvar ndarray_1 = __webpack_require__(/*! ./ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar NDArrayMathCPU = (function (_super) {\n    __extends(NDArrayMathCPU, _super);\n    function NDArrayMathCPU(safeMode) {\n        if (safeMode === void 0) { safeMode = false; }\n        return _super.call(this, safeMode) || this;\n    }\n    NDArrayMathCPU.prototype.cloneInternal = function (ndarray) {\n        return ndarray_1.NDArray.make(ndarray.shape, { values: new Float32Array(ndarray.getValues()) });\n    };\n    NDArrayMathCPU.prototype.slice1DInternal = function (input, begin, size) {\n        var newVals = input.getValues().slice(begin, begin + size);\n        return ndarray_1.Array1D.new(newVals);\n    };\n    NDArrayMathCPU.prototype.slice2DInternal = function (input, begin, size) {\n        var result = ndarray_1.Array2D.zeros(size);\n        var startI = begin[0], startJ = begin[1];\n        for (var i = 0; i < size[0]; ++i) {\n            for (var j = 0; j < size[1]; ++j) {\n                var val = input.get(i + startI, j + startJ);\n                result.set(val, i, j);\n            }\n        }\n        return result;\n    };\n    NDArrayMathCPU.prototype.slice3DInternal = function (input, begin, size) {\n        var result = ndarray_1.Array3D.zeros(size);\n        var startI = begin[0], startJ = begin[1], startK = begin[2];\n        for (var i = 0; i < size[0]; ++i) {\n            for (var j = 0; j < size[1]; ++j) {\n                for (var k = 0; k < size[2]; ++k) {\n                    var val = input.get(i + startI, j + startJ, k + startK);\n                    result.set(val, i, j, k);\n                }\n            }\n        }\n        return result;\n    };\n    NDArrayMathCPU.prototype.slice4DInternal = function (input, begin, size) {\n        var result = ndarray_1.Array4D.zeros(size);\n        var startI = begin[0], startJ = begin[1], startK = begin[2], startL = begin[3];\n        for (var i = 0; i < size[0]; ++i) {\n            for (var j = 0; j < size[1]; ++j) {\n                for (var k = 0; k < size[2]; ++k) {\n                    for (var l = 0; l < size[3]; ++l) {\n                        var val = input.get(i + startI, j + startJ, k + startK, l + startL);\n                        result.set(val, i, j, k, l);\n                    }\n                }\n            }\n        }\n        return result;\n    };\n    NDArrayMathCPU.prototype.copy2DInternal = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {\n        copy2D_util.validateShapes(sourceSizeRowCol, destSizeRowCol);\n        var srcValues = source.getValues();\n        var dstValues = dest.getValues();\n        var n = sourceSizeRowCol[0] * sourceSizeRowCol[1];\n        for (var i = 0; i < n; ++i) {\n            var srcRow = sourceBeginRowCol[0] + Math.floor(i / sourceSizeRowCol[1]);\n            var srcCol = sourceBeginRowCol[1] + (i % sourceSizeRowCol[1]);\n            var srcOff = srcRow * source.shape[1] + srcCol;\n            var dstRow = destBeginRowCol[0] + Math.floor(i / destSizeRowCol[1]);\n            var dstCol = destBeginRowCol[1] + (i % destSizeRowCol[1]);\n            var dstOff = dstRow * dest.shape[1] + dstCol;\n            dstValues[dstOff] = srcValues[srcOff];\n        }\n    };\n    NDArrayMathCPU.prototype.concat1DInternal = function (a, b) {\n        var outShape = concat_util.computeOutShape(a.shape, b.shape, 0);\n        var result = ndarray_1.Array1D.zeros(outShape);\n        var aVals = a.getValues();\n        var bVals = b.getValues();\n        var vals = result.getValues();\n        vals.set(aVals, 0);\n        vals.set(bVals, a.size);\n        return result;\n    };\n    NDArrayMathCPU.prototype.concat2DInternal = function (a, b, axis) {\n        var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);\n        var result = ndarray_1.Array2D.zeros(outShape);\n        if (axis === 0) {\n            var aVals = a.getValues();\n            var bVals = b.getValues();\n            var vals = result.getValues();\n            vals.set(aVals, 0);\n            vals.set(bVals, a.size);\n            return result;\n        }\n        for (var i = 0; i < outShape[0]; ++i) {\n            for (var j = 0; j < outShape[1]; ++j) {\n                var index = [i, j];\n                var value = void 0;\n                if (index[axis] < a.shape[axis]) {\n                    value = a.get(i, j);\n                }\n                else {\n                    index[axis] -= a.shape[axis];\n                    var i2 = index[0], j2 = index[1];\n                    value = b.get(i2, j2);\n                }\n                result.set(value, i, j);\n            }\n        }\n        return result;\n    };\n    NDArrayMathCPU.prototype.concat3DInternal = function (a, b, axis) {\n        var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);\n        var result = ndarray_1.Array3D.zeros(outShape);\n        if (axis === 0) {\n            var aVals = a.getValues();\n            var bVals = b.getValues();\n            var vals = result.getValues();\n            vals.set(aVals, 0);\n            vals.set(bVals, a.size);\n            return result;\n        }\n        for (var i = 0; i < outShape[0]; ++i) {\n            for (var j = 0; j < outShape[1]; ++j) {\n                for (var k = 0; k < outShape[2]; ++k) {\n                    var index = [i, j, k];\n                    var value = void 0;\n                    if (index[axis] < a.shape[axis]) {\n                        value = a.get(i, j, k);\n                    }\n                    else {\n                        index[axis] -= a.shape[axis];\n                        var i2 = index[0], j2 = index[1], k2 = index[2];\n                        value = b.get(i2, j2, k2);\n                    }\n                    result.set(value, i, j, k);\n                }\n            }\n        }\n        return result;\n    };\n    NDArrayMathCPU.prototype.concat4DInternal = function (a, b, axis) {\n        var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);\n        var result = ndarray_1.Array4D.zeros(outShape);\n        if (axis === 0) {\n            var aVals = a.getValues();\n            var bVals = b.getValues();\n            var vals = result.getValues();\n            vals.set(aVals, 0);\n            vals.set(bVals, a.size);\n            return result;\n        }\n        for (var i = 0; i < outShape[0]; ++i) {\n            for (var j = 0; j < outShape[1]; ++j) {\n                for (var k = 0; k < outShape[2]; ++k) {\n                    for (var l = 0; l < outShape[3]; ++l) {\n                        var index = [i, j, k, l];\n                        var value = void 0;\n                        if (index[axis] < a.shape[axis]) {\n                            value = a.get(i, j, k, l);\n                        }\n                        else {\n                            index[axis] -= a.shape[axis];\n                            var i2 = index[0], j2 = index[1], k2 = index[2], l2 = index[3];\n                            value = b.get(i2, j2, k2, l2);\n                        }\n                        result.set(value, i, j, k, l);\n                    }\n                }\n            }\n        }\n        return result;\n    };\n    NDArrayMathCPU.prototype.scaledArrayAddInternal = function (c1, a, c2, b) {\n        var newShape = util.assertAndGetBroadcastedShape(a.shape, b.shape);\n        var newValues = new Float32Array(util.sizeFromShape(newShape));\n        var aValues = a.getValues();\n        var bValues = b.getValues();\n        var c1Val = c1.get();\n        var c2Val = c2.get();\n        for (var i = 0; i < newValues.length; ++i) {\n            newValues[i] = c1Val * aValues[i % a.size] + c2Val * bValues[i % b.size];\n        }\n        return ndarray_1.NDArray.make(newShape, { values: newValues });\n    };\n    NDArrayMathCPU.prototype.negInternal = function (a) {\n        return this.scalarTimesArray(ndarray_1.Scalar.NEG_ONE, a);\n    };\n    NDArrayMathCPU.prototype.addInternal = function (a, b) {\n        return this.scaledArrayAddInternal(ndarray_1.Scalar.ONE, a, ndarray_1.Scalar.ONE, b);\n    };\n    NDArrayMathCPU.prototype.subInternal = function (a, b) {\n        return this.scaledArrayAddInternal(ndarray_1.Scalar.ONE, a, ndarray_1.Scalar.NEG_ONE, b);\n    };\n    NDArrayMathCPU.prototype.matMulInternal = function (a, b, aOrientation, bOrientation) {\n        if (aOrientation === void 0) { aOrientation = math_1.MatrixOrientation.REGULAR; }\n        if (bOrientation === void 0) { bOrientation = math_1.MatrixOrientation.REGULAR; }\n        var sharedDim = (aOrientation === math_1.MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];\n        var leftDim = (aOrientation === math_1.MatrixOrientation.REGULAR) ? a.shape[0] : a.shape[1];\n        var rightDim = (bOrientation === math_1.MatrixOrientation.REGULAR) ? b.shape[1] : b.shape[0];\n        var normalGetter = function (matrix, i, j) {\n            return matrix.get(i, j);\n        };\n        var transposedGetter = function (matrix, i, j) {\n            return matrix.get(j, i);\n        };\n        var aGetter = (aOrientation === math_1.MatrixOrientation.REGULAR) ?\n            normalGetter :\n            transposedGetter;\n        var bGetter = (bOrientation === math_1.MatrixOrientation.REGULAR) ?\n            normalGetter :\n            transposedGetter;\n        var values = new Float32Array(leftDim * rightDim);\n        var index = 0;\n        for (var i = 0; i < leftDim; ++i) {\n            for (var j = 0; j < rightDim; ++j) {\n                var sum = 0;\n                for (var k = 0; k < sharedDim; ++k) {\n                    sum += aGetter(a, i, k) * bGetter(b, k, j);\n                }\n                values[index++] = sum;\n            }\n        }\n        return ndarray_1.Array2D.new([leftDim, rightDim], values);\n    };\n    NDArrayMathCPU.prototype.multiplyInternal = function (a, b) {\n        var newShape = util.assertAndGetBroadcastedShape(a.shape, b.shape);\n        var newValues = new Float32Array(util.sizeFromShape(newShape));\n        var aValues = a.getValues();\n        var bValues = b.getValues();\n        for (var i = 0; i < newValues.length; ++i) {\n            newValues[i] = aValues[i % a.size] * bValues[i % b.size];\n        }\n        return ndarray_1.NDArray.make(newShape, { values: newValues });\n    };\n    NDArrayMathCPU.prototype.divideInternal = function (a, b) {\n        var newShape = util.assertAndGetBroadcastedShape(a.shape, b.shape);\n        var newValues = new Float32Array(util.sizeFromShape(newShape));\n        var aValues = a.getValues();\n        var bValues = b.getValues();\n        for (var i = 0; i < newValues.length; ++i) {\n            newValues[i] = aValues[i % a.size] / bValues[i % b.size];\n        }\n        return ndarray_1.NDArray.make(newShape, { values: newValues });\n    };\n    NDArrayMathCPU.prototype.sumInternal = function (ndarray) {\n        var sum = 0;\n        var values = ndarray.getValues();\n        for (var i = 0; i < values.length; ++i) {\n            sum += values[i];\n        }\n        return ndarray_1.Scalar.new(sum);\n    };\n    NDArrayMathCPU.prototype.argMinInternal = function (ndarray) {\n        var min = Number.MAX_VALUE;\n        var minIndex = -1;\n        var values = ndarray.getValues();\n        for (var i = 0; i < values.length; ++i) {\n            var value = values[i];\n            if (isNaN(value)) {\n                return ndarray_1.Scalar.new(NaN);\n            }\n            if (value < min) {\n                min = value;\n                minIndex = i;\n            }\n        }\n        return ndarray_1.Scalar.new(minIndex);\n    };\n    NDArrayMathCPU.prototype.argMaxInternal = function (ndarray) {\n        var max = Number.NEGATIVE_INFINITY;\n        var maxIndex = -1;\n        var values = ndarray.getValues();\n        for (var i = 0; i < values.length; ++i) {\n            var value = values[i];\n            if (isNaN(value)) {\n                return ndarray_1.Scalar.new(NaN);\n            }\n            if (value > max) {\n                max = value;\n                maxIndex = i;\n            }\n        }\n        return ndarray_1.Scalar.new(maxIndex);\n    };\n    NDArrayMathCPU.prototype.argMaxEqualsInternal = function (x1, x2) {\n        var argMax1 = this.argMaxInternal(x1).get();\n        var argMax2 = this.argMaxInternal(x2).get();\n        if (isNaN(argMax1) || isNaN(argMax2)) {\n            return ndarray_1.Scalar.new(NaN);\n        }\n        return ndarray_1.Scalar.new(+(argMax1 === argMax2));\n    };\n    NDArrayMathCPU.prototype.topKInternal = function (ndarray, k) {\n        var values = ndarray.getValues();\n        var valuesAndIndices = [];\n        for (var i = 0; i < values.length; i++) {\n            valuesAndIndices.push({ value: values[i], index: i });\n        }\n        valuesAndIndices.sort(function (a, b) {\n            return b.value - a.value;\n        });\n        var topkValues = new Float32Array(k);\n        var topkIndices = new Float32Array(k);\n        for (var i = 0; i < k; i++) {\n            topkValues[i] = valuesAndIndices[i].value;\n            topkIndices[i] = valuesAndIndices[i].index;\n        }\n        return { values: ndarray_1.Array1D.new(topkValues), indices: ndarray_1.Array1D.new(topkIndices) };\n    };\n    NDArrayMathCPU.prototype.minInternal = function (ndarray) {\n        var values = ndarray.getValues();\n        var min = values[0];\n        for (var i = 1; i < values.length; ++i) {\n            var value = values[i];\n            if (isNaN(value)) {\n                return ndarray_1.Scalar.new(NaN);\n            }\n            if (value < min) {\n                min = value;\n            }\n        }\n        return ndarray_1.Scalar.new(min);\n    };\n    NDArrayMathCPU.prototype.maxInternal = function (ndarray) {\n        var values = ndarray.getValues();\n        var max = values[0];\n        for (var i = 1; i < values.length; ++i) {\n            var value = values[i];\n            if (isNaN(value)) {\n                return ndarray_1.Scalar.new(NaN);\n            }\n            if (value > max) {\n                max = value;\n            }\n        }\n        return ndarray_1.Scalar.new(max);\n    };\n    NDArrayMathCPU.prototype.expInternal = function (ndarray) {\n        var values = ndarray.getValues();\n        var newValues = new Float32Array(values.length);\n        for (var i = 0; i < values.length; ++i) {\n            newValues[i] = Math.exp(values[i]);\n        }\n        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });\n    };\n    NDArrayMathCPU.prototype.logInternal = function (ndarray) {\n        var values = ndarray.getValues();\n        var newValues = new Float32Array(values.length);\n        for (var i = 0; i < values.length; ++i) {\n            var value = values[i];\n            newValues[i] = Math.log(value);\n        }\n        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });\n    };\n    NDArrayMathCPU.prototype.sqrtInternal = function (ndarray) {\n        var values = ndarray.getValues();\n        var newValues = new Float32Array(values.length);\n        for (var i = 0; i < values.length; ++i) {\n            var value = values[i];\n            newValues[i] = Math.sqrt(value);\n        }\n        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });\n    };\n    NDArrayMathCPU.prototype.logSumExpInternal = function (ndarray) {\n        var xMax = this.max(ndarray);\n        var a = this.arrayMinusScalar(ndarray, xMax);\n        var b = this.exp(a);\n        var c = this.sum(b);\n        var d = this.log(c);\n        var result = this.add(xMax, d);\n        xMax.dispose();\n        a.dispose();\n        b.dispose();\n        c.dispose();\n        d.dispose();\n        return result;\n    };\n    NDArrayMathCPU.prototype.reluInternal = function (ndarray) {\n        var resultValues = new Float32Array(ndarray.size);\n        var values = ndarray.getValues();\n        for (var i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.max(0, values[i]);\n        }\n        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });\n    };\n    NDArrayMathCPU.prototype.absInternal = function (ndarray) {\n        var resultValues = new Float32Array(ndarray.size);\n        var values = ndarray.getValues();\n        for (var i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.abs(values[i]);\n        }\n        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });\n    };\n    NDArrayMathCPU.prototype.sigmoidInternal = function (ndarray) {\n        var resultValues = new Float32Array(ndarray.size);\n        var values = ndarray.getValues();\n        for (var i = 0; i < values.length; ++i) {\n            resultValues[i] = 1 / (1 + Math.exp(-values[i]));\n        }\n        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });\n    };\n    NDArrayMathCPU.prototype.sinInternal = function (ndarray) {\n        var resultValues = new Float32Array(ndarray.size);\n        var values = ndarray.getValues();\n        for (var i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.sin(values[i]);\n        }\n        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });\n    };\n    NDArrayMathCPU.prototype.cosInternal = function (ndarray) {\n        var resultValues = new Float32Array(ndarray.size);\n        var values = ndarray.getValues();\n        for (var i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.cos(values[i]);\n        }\n        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });\n    };\n    NDArrayMathCPU.prototype.tanInternal = function (ndarray) {\n        var resultValues = new Float32Array(ndarray.size);\n        var values = ndarray.getValues();\n        for (var i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.tan(values[i]);\n        }\n        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });\n    };\n    NDArrayMathCPU.prototype.asinInternal = function (ndarray) {\n        var resultValues = new Float32Array(ndarray.size);\n        var values = ndarray.getValues();\n        for (var i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.asin(values[i]);\n        }\n        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });\n    };\n    NDArrayMathCPU.prototype.acosInternal = function (ndarray) {\n        var resultValues = new Float32Array(ndarray.size);\n        var values = ndarray.getValues();\n        for (var i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.acos(values[i]);\n        }\n        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });\n    };\n    NDArrayMathCPU.prototype.atanInternal = function (ndarray) {\n        var resultValues = new Float32Array(ndarray.size);\n        var values = ndarray.getValues();\n        for (var i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.atan(values[i]);\n        }\n        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });\n    };\n    NDArrayMathCPU.prototype.sinhInternal = function (ndarray) {\n        var resultValues = new Float32Array(ndarray.size);\n        var values = ndarray.getValues();\n        for (var i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.sinh(values[i]);\n        }\n        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });\n    };\n    NDArrayMathCPU.prototype.coshInternal = function (ndarray) {\n        var resultValues = new Float32Array(ndarray.size);\n        var values = ndarray.getValues();\n        for (var i = 0; i < values.length; ++i) {\n            resultValues[i] = Math.cosh(values[i]);\n        }\n        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });\n    };\n    NDArrayMathCPU.prototype.tanhInternal = function (ndarray) {\n        var resultValues = new Float32Array(ndarray.size);\n        var values = ndarray.getValues();\n        for (var i = 0; i < values.length; ++i) {\n            resultValues[i] = util.tanh(values[i]);\n        }\n        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });\n    };\n    NDArrayMathCPU.prototype.stepInternal = function (ndarray) {\n        var resultValues = new Float32Array(ndarray.size);\n        var values = ndarray.getValues();\n        for (var i = 0; i < values.length; ++i) {\n            var value = values[i];\n            resultValues[i] = value > 0 ? 1 : (value < 0 ? 0 : value);\n        }\n        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });\n    };\n    NDArrayMathCPU.prototype.conv2dInternal = function (x, filter, bias, convInfo) {\n        var _a = x.shape, xRows = _a[0], xCols = _a[1], inputDepth = _a[2];\n        var filterHeight = filter.shape[0];\n        var filterWidth = filter.shape[1];\n        var outDepth = filter.shape[3];\n        var padLeft = convInfo.padInfo.left;\n        var padTop = convInfo.padInfo.top;\n        var y = ndarray_1.Array3D.zeros(convInfo.outShape);\n        for (var d2 = 0; d2 < outDepth; ++d2) {\n            for (var yR = 0; yR < y.shape[0]; ++yR) {\n                var xRCorner = yR * convInfo.strideHeight - padLeft;\n                var xRMin = Math.max(0, xRCorner);\n                var xRMax = Math.min(xRows, filterHeight + xRCorner);\n                for (var yC = 0; yC < y.shape[1]; ++yC) {\n                    var xCCorner = yC * convInfo.strideWidth - padTop;\n                    var xCMin = Math.max(0, xCCorner);\n                    var xCMax = Math.min(xCols, filterWidth + xCCorner);\n                    var dotProd = 0;\n                    for (var xR = xRMin; xR < xRMax; ++xR) {\n                        var wR = xR - xRCorner;\n                        for (var xC = xCMin; xC < xCMax; ++xC) {\n                            var wC = xC - xCCorner;\n                            for (var d1 = 0; d1 < inputDepth; ++d1) {\n                                var pixel = x.get(xR, xC, d1);\n                                var weight = filter.get(wR, wC, d1, d2);\n                                dotProd += pixel * weight;\n                            }\n                        }\n                    }\n                    var biasVal = (bias != null) ? bias.get(d2) : 0;\n                    y.set(dotProd + biasVal, yR, yC, d2);\n                }\n            }\n        }\n        return y;\n    };\n    NDArrayMathCPU.prototype.conv2dDerInputInternal = function (dy, filter, convInfo) {\n        var inDepth = filter.shape[2];\n        var outDepth = filter.shape[3];\n        var yRows = dy.shape[0];\n        var yCols = dy.shape[1];\n        var filterHeight = filter.shape[0];\n        var filterWidth = filter.shape[1];\n        var topPad = filterHeight - 1 - convInfo.padInfo.top;\n        var leftPad = filterWidth - 1 - convInfo.padInfo.left;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var dx = ndarray_1.Array3D.zeros(convInfo.inShape);\n        for (var d1 = 0; d1 < inDepth; ++d1) {\n            for (var xR = 0; xR < dx.shape[0]; ++xR) {\n                var xRCorner = xR - leftPad;\n                var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));\n                var yRMax = Math.min(yRows, (filterHeight + xRCorner) / strideHeight);\n                for (var xC = 0; xC < dx.shape[1]; ++xC) {\n                    var xCCorner = xC - topPad;\n                    var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));\n                    var yCMax = Math.min(yCols, (filterWidth + xCCorner) / strideWidth);\n                    var dotProd = 0;\n                    for (var yR = xRMin; yR < yRMax; ++yR) {\n                        var wR = yR * strideHeight - xRCorner;\n                        for (var yC = xCMin; yC < yCMax; ++yC) {\n                            var wC = yC * strideWidth - xCCorner;\n                            for (var d2 = 0; d2 < outDepth; ++d2) {\n                                var pixel = dy.get(yR, yC, d2);\n                                var weight = filter.get(filterHeight - 1 - wR, filterWidth - 1 - wC, d1, d2);\n                                dotProd += pixel * weight;\n                            }\n                        }\n                    }\n                    dx.set(dotProd, xR, xC, d1);\n                }\n            }\n        }\n        return dx;\n    };\n    NDArrayMathCPU.prototype.conv2dDerFilterInternal = function (x, dY, convInfo) {\n        var inputDepth = x.shape[2];\n        var outputDepth = dY.shape[2];\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var weightsShape = conv_util.computeWeightsShape4D(inputDepth, outputDepth, filterHeight, filterWidth);\n        var dW = ndarray_1.Array4D.zeros(weightsShape);\n        var yNumRows = dY.shape[0];\n        var yNumCols = dY.shape[1];\n        var xNumRows = x.shape[0];\n        var xNumCols = x.shape[1];\n        var leftPad = convInfo.padInfo.left;\n        var topPad = convInfo.padInfo.top;\n        for (var wR = 0; wR < filterHeight; ++wR) {\n            var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));\n            var yRMax = Math.min(yNumRows, (xNumRows + topPad - wR) / strideHeight);\n            for (var wC = 0; wC < filterWidth; ++wC) {\n                var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));\n                var yCMax = Math.min(yNumCols, (xNumCols + leftPad - wC) / strideWidth);\n                for (var d1 = 0; d1 < inputDepth; ++d1) {\n                    for (var d2 = 0; d2 < outputDepth; ++d2) {\n                        var dotProd = 0;\n                        for (var yR = yRMin; yR < yRMax; ++yR) {\n                            var xR = wR + yR * strideHeight - topPad;\n                            for (var yC = yCMin; yC < yCMax; ++yC) {\n                                var xC = wC + yC * strideWidth - leftPad;\n                                dotProd += x.get(xR, xC, d1) * dY.get(yR, yC, d2);\n                            }\n                        }\n                        dW.set(dotProd, wR, wC, d1, d2);\n                    }\n                }\n            }\n        }\n        return dW;\n    };\n    NDArrayMathCPU.prototype.conv2dDerBiasInternal = function (dY) {\n        var outputDepth = dY.shape[2];\n        var numRows = dY.shape[0];\n        var numCols = dY.shape[1];\n        var values = new Float32Array(outputDepth);\n        for (var d2 = 0; d2 < outputDepth; ++d2) {\n            var sum = 0;\n            for (var r = 0; r < numRows; ++r) {\n                for (var c = 0; c < numCols; ++c) {\n                    sum += dY.get(r, c, d2);\n                }\n            }\n            values[d2] = sum;\n        }\n        return ndarray_1.Array1D.new(values);\n    };\n    NDArrayMathCPU.prototype.switchDimInternal = function (t, newDim) {\n        var newShape = new Array(t.rank);\n        for (var i = 0; i < newShape.length; i++) {\n            newShape[i] = t.shape[newDim[i]];\n        }\n        var resultValues = new Float32Array(t.size);\n        var values = t.getValues();\n        var result = ndarray_1.NDArray.make(newShape, { values: resultValues });\n        for (var i = 0; i < t.size; ++i) {\n            var loc = t.indexToLoc(i);\n            var newLoc = new Array(loc.length);\n            for (var i_1 = 0; i_1 < newLoc.length; i_1++) {\n                newLoc[i_1] = loc[newDim[i_1]];\n            }\n            var newIndex = result.locToIndex(newLoc);\n            resultValues[newIndex] = values[i];\n        }\n        return result;\n    };\n    NDArrayMathCPU.prototype.pool = function (x, convInfo, poolType) {\n        var _a = x.shape, xRows = _a[0], xCols = _a[1], depth = _a[2];\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var y = ndarray_1.Array3D.zeros(convInfo.outShape);\n        var padTop = convInfo.padInfo.top;\n        var padLeft = convInfo.padInfo.left;\n        for (var d = 0; d < depth; ++d) {\n            for (var yR = 0; yR < y.shape[0]; ++yR) {\n                var xRCorner = yR * strideHeight - padTop;\n                var xRMin = Math.max(0, xRCorner);\n                var xRMax = Math.min(xRows, filterHeight + xRCorner);\n                for (var yC = 0; yC < y.shape[1]; ++yC) {\n                    var xCCorner = yC * strideWidth - padLeft;\n                    var xCMin = Math.max(0, xCCorner);\n                    var xCMax = Math.min(xCols, filterWidth + xCCorner);\n                    var minMaxValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n                        Number.POSITIVE_INFINITY);\n                    var avgValue = 0;\n                    for (var xR = xRMin; xR < xRMax; ++xR) {\n                        for (var xC = xCMin; xC < xCMax; ++xC) {\n                            var pixel = x.get(xR, xC, d);\n                            if (isNaN(pixel)) {\n                                minMaxValue = NaN;\n                                avgValue = NaN;\n                                break;\n                            }\n                            if ((poolType === 'max' && pixel > minMaxValue) ||\n                                (poolType === 'min' && pixel < minMaxValue)) {\n                                minMaxValue = pixel;\n                            }\n                            else if (poolType === 'avg') {\n                                avgValue += pixel / (filterHeight * filterWidth);\n                            }\n                        }\n                        if (isNaN(minMaxValue)) {\n                            break;\n                        }\n                    }\n                    y.set(poolType === 'avg' ? avgValue : minMaxValue, yR, yC, d);\n                }\n            }\n        }\n        return y;\n    };\n    NDArrayMathCPU.prototype.maxPoolInternal = function (x, convInfo) {\n        return this.pool(x, convInfo, 'max');\n    };\n    NDArrayMathCPU.prototype.maxPoolPositions = function (x, convInfo) {\n        var _a = x.shape, xRows = _a[0], xCols = _a[1], depth = _a[2];\n        var outputShape = convInfo.outShape;\n        var maxPositions = ndarray_1.Array3D.zeros(outputShape);\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var padTop = convInfo.padInfo.top;\n        var padLeft = convInfo.padInfo.left;\n        for (var d = 0; d < depth; ++d) {\n            for (var yR = 0; yR < outputShape[0]; ++yR) {\n                var xRCorner = yR * strideHeight - padTop;\n                var xRMin = Math.max(0, xRCorner);\n                var xRMax = Math.min(xRows, filterHeight + xRCorner);\n                for (var yC = 0; yC < outputShape[1]; ++yC) {\n                    var xCCorner = yC * strideWidth - padLeft;\n                    var xCMin = Math.max(0, xCCorner);\n                    var xCMax = Math.min(xCols, filterWidth + xCCorner);\n                    var maxValue = Number.NEGATIVE_INFINITY;\n                    var maxPosition = -1;\n                    for (var xR = xRMin; xR < xRMax; ++xR) {\n                        var wR = xR - xRCorner;\n                        for (var xC = xCMin; xC < xCMax; ++xC) {\n                            var wC = xC - xCCorner;\n                            var pixel = x.get(xR, xC, d);\n                            if (pixel > maxValue) {\n                                maxValue = pixel;\n                                maxPosition = wR * filterWidth + wC;\n                            }\n                        }\n                    }\n                    maxPositions.set(maxPosition, yR, yC, d);\n                }\n            }\n        }\n        return maxPositions;\n    };\n    NDArrayMathCPU.prototype.maxPoolBackpropInternal = function (dy, x, convInfo) {\n        var maxPositions = this.maxPoolPositions(x, convInfo);\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        var padTop = filterHeight - 1 - convInfo.padInfo.top;\n        var _a = dy.shape, dyRows = _a[0], dyCols = _a[1], depth = _a[2];\n        var dx = ndarray_1.Array3D.zeros(x.shape);\n        for (var d = 0; d < depth; ++d) {\n            for (var dxR = 0; dxR < dx.shape[0]; ++dxR) {\n                for (var dxC = 0; dxC < dx.shape[1]; ++dxC) {\n                    var dyRCorner = dxR - padTop;\n                    var dyCCorner = dxC - padLeft;\n                    var dotProd = 0;\n                    for (var wR = 0; wR < filterHeight; ++wR) {\n                        var dyR = (dyRCorner + wR) / strideHeight;\n                        if (dyR < 0 || dyR >= dyRows || Math.floor(dyR) !== dyR) {\n                            continue;\n                        }\n                        for (var wC = 0; wC < filterWidth; ++wC) {\n                            var dyC = (dyCCorner + wC) / strideWidth;\n                            if (dyC < 0 || dyC >= dyCols || Math.floor(dyC) !== dyC) {\n                                continue;\n                            }\n                            var maxPos = filterHeight * filterWidth - 1 -\n                                maxPositions.get(dyR, dyC, d);\n                            var curPos = wR * filterWidth + wC;\n                            var mask = maxPos === curPos ? 1 : 0;\n                            if (mask === 0) {\n                                continue;\n                            }\n                            var pixel = dy.get(dyR, dyC, d);\n                            dotProd += pixel * mask;\n                        }\n                    }\n                    dx.set(dotProd, dxR, dxC, d);\n                }\n            }\n        }\n        return dx;\n    };\n    NDArrayMathCPU.prototype.minPoolInternal = function (x, convInfo) {\n        return this.pool(x, convInfo, 'min');\n    };\n    NDArrayMathCPU.prototype.avgPoolInternal = function (x, convInfo) {\n        return this.pool(x, convInfo, 'avg');\n    };\n    NDArrayMathCPU.prototype.resizeBilinear3DInternal = function (x, newShape2D, alignCorners) {\n        var output = ndarray_1.Array3D.zeros([newShape2D[0], newShape2D[1], x.shape[2]]);\n        var effectiveInputSize = alignCorners ? [x.shape[0] - 1, x.shape[1] - 1, x.shape[2]] : x.shape;\n        var effectiveOutputSize = alignCorners ?\n            [output.shape[0] - 1, output.shape[1] - 1, output.shape[2]] :\n            output.shape;\n        for (var r = 0; r < output.shape[0]; r++) {\n            for (var c = 0; c < output.shape[1]; c++) {\n                for (var d = 0; d < output.shape[2]; d++) {\n                    var sourceFracRow = (effectiveInputSize[0]) * r / (effectiveOutputSize[0]);\n                    var sourceFracCol = (effectiveInputSize[1]) * c / (effectiveOutputSize[1]);\n                    var sourceRowFloor = Math.floor(sourceFracRow);\n                    var sourceRowCeil = Math.min(x.shape[0] - 1, Math.ceil(sourceFracRow));\n                    var sourceColFloor = Math.floor(sourceFracCol);\n                    var sourceColCeil = Math.min(x.shape[1] - 1, Math.ceil(sourceFracCol));\n                    var topLeft = x.get(sourceRowFloor, sourceColFloor, d);\n                    var bottomLeft = x.get(sourceRowCeil, sourceColFloor, d);\n                    var topRight = x.get(sourceRowFloor, sourceColCeil, d);\n                    var bottomRight = x.get(sourceRowCeil, sourceColCeil, d);\n                    var rowFrac = sourceFracRow - sourceRowFloor;\n                    var colFrac = sourceFracCol - sourceColFloor;\n                    var top_1 = topLeft + (topRight - topLeft) * colFrac;\n                    var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;\n                    var newValue = top_1 + (bottom - top_1) * rowFrac;\n                    output.set(newValue, r, c, d);\n                }\n            }\n        }\n        return output;\n    };\n    NDArrayMathCPU.prototype.batchNormalization3DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {\n        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }\n        var xValues = x.getValues();\n        var meanValues = mean.getValues();\n        var varianceValues = variance.getValues();\n        var scaleValues = scale ? scale.getValues() : new Float32Array([1]);\n        var offsetValues = offset ? offset.getValues() : new Float32Array([0]);\n        var outValues = new Float32Array(xValues.length);\n        for (var i = 0; i < xValues.length; i++) {\n            outValues[i] = offsetValues[i % offsetValues.length] +\n                (xValues[i] - meanValues[i % meanValues.length]) *\n                    scaleValues[i % scaleValues.length] /\n                    Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);\n        }\n        return ndarray_1.Array3D.make(x.shape, { values: outValues });\n    };\n    NDArrayMathCPU.prototype.multinomialInternal = function (probabilities, numSamples, seed) {\n        var probVals = probabilities.getValues();\n        var cdf = new Float32Array(probabilities.size - 1);\n        cdf[0] = probVals[0];\n        for (var event_1 = 1; event_1 < cdf.length; ++event_1) {\n            cdf[event_1] = cdf[event_1 - 1] + probVals[event_1];\n        }\n        var random = seedrandom.alea(seed.toString());\n        var res = new Float32Array(numSamples);\n        for (var i = 0; i < numSamples; ++i) {\n            var r = random();\n            res[i] = cdf.length;\n            for (var event_2 = 0; event_2 < cdf.length; event_2++) {\n                if (r < cdf[event_2]) {\n                    res[i] = event_2;\n                    break;\n                }\n            }\n        }\n        return ndarray_1.Array1D.new(res);\n    };\n    NDArrayMathCPU.prototype.oneHotInternal = function (indices, depth, onValue, offValue) {\n        var res = new Float32Array(indices.size * depth);\n        res.fill(offValue);\n        for (var event_3 = 0; event_3 < indices.size; ++event_3) {\n            res[event_3 * depth + indices.get(event_3)] = onValue;\n        }\n        return ndarray_1.Array2D.new([indices.size, depth], res);\n    };\n    return NDArrayMathCPU;\n}(math_1.NDArrayMath));\nexports.NDArrayMathCPU = NDArrayMathCPU;\n//# sourceMappingURL=math_cpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvbWF0aF9jcHUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvbWF0aF9jcHUuanM/ZGIyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNlZWRyYW5kb20gPSByZXF1aXJlKFwic2VlZHJhbmRvbVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgY29uY2F0X3V0aWwgPSByZXF1aXJlKFwiLi9jb25jYXRfdXRpbFwiKTtcbnZhciBjb252X3V0aWwgPSByZXF1aXJlKFwiLi9jb252X3V0aWxcIik7XG52YXIgY29weTJEX3V0aWwgPSByZXF1aXJlKFwiLi9jb3B5MmRfdXRpbFwiKTtcbnZhciBtYXRoXzEgPSByZXF1aXJlKFwiLi9tYXRoXCIpO1xudmFyIG5kYXJyYXlfMSA9IHJlcXVpcmUoXCIuL25kYXJyYXlcIik7XG52YXIgTkRBcnJheU1hdGhDUFUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOREFycmF5TWF0aENQVSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOREFycmF5TWF0aENQVShzYWZlTW9kZSkge1xuICAgICAgICBpZiAoc2FmZU1vZGUgPT09IHZvaWQgMCkgeyBzYWZlTW9kZSA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzYWZlTW9kZSkgfHwgdGhpcztcbiAgICB9XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNsb25lSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LmdldFZhbHVlcygpKSB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5zbGljZTFESW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciBuZXdWYWxzID0gaW5wdXQuZ2V0VmFsdWVzKCkuc2xpY2UoYmVnaW4sIGJlZ2luICsgc2l6ZSk7XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuQXJyYXkxRC5uZXcobmV3VmFscyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc2xpY2UyREludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLkFycmF5MkQuemVyb3Moc2l6ZSk7XG4gICAgICAgIHZhciBzdGFydEkgPSBiZWdpblswXSwgc3RhcnRKID0gYmVnaW5bMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZVswXTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNpemVbMV07ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBpbnB1dC5nZXQoaSArIHN0YXJ0SSwgaiArIHN0YXJ0Sik7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldCh2YWwsIGksIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc2xpY2UzREludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLkFycmF5M0QuemVyb3Moc2l6ZSk7XG4gICAgICAgIHZhciBzdGFydEkgPSBiZWdpblswXSwgc3RhcnRKID0gYmVnaW5bMV0sIHN0YXJ0SyA9IGJlZ2luWzJdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVbMF07ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaXplWzFdOyArK2opIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNpemVbMl07ICsraykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gaW5wdXQuZ2V0KGkgKyBzdGFydEksIGogKyBzdGFydEosIGsgKyBzdGFydEspO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KHZhbCwgaSwgaiwgayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc2xpY2U0REludGVybmFsID0gZnVuY3Rpb24gKGlucHV0LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLkFycmF5NEQuemVyb3Moc2l6ZSk7XG4gICAgICAgIHZhciBzdGFydEkgPSBiZWdpblswXSwgc3RhcnRKID0gYmVnaW5bMV0sIHN0YXJ0SyA9IGJlZ2luWzJdLCBzdGFydEwgPSBiZWdpblszXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplWzBdOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2l6ZVsxXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzaXplWzJdOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBzaXplWzNdOyArK2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBpbnB1dC5nZXQoaSArIHN0YXJ0SSwgaiArIHN0YXJ0SiwgayArIHN0YXJ0SywgbCArIHN0YXJ0TCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KHZhbCwgaSwgaiwgaywgbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jb3B5MkRJbnRlcm5hbCA9IGZ1bmN0aW9uIChzb3VyY2UsIHNvdXJjZUJlZ2luUm93Q29sLCBzb3VyY2VTaXplUm93Q29sLCBkZXN0LCBkZXN0QmVnaW5Sb3dDb2wsIGRlc3RTaXplUm93Q29sKSB7XG4gICAgICAgIGNvcHkyRF91dGlsLnZhbGlkYXRlU2hhcGVzKHNvdXJjZVNpemVSb3dDb2wsIGRlc3RTaXplUm93Q29sKTtcbiAgICAgICAgdmFyIHNyY1ZhbHVlcyA9IHNvdXJjZS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGRzdFZhbHVlcyA9IGRlc3QuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBuID0gc291cmNlU2l6ZVJvd0NvbFswXSAqIHNvdXJjZVNpemVSb3dDb2xbMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc3JjUm93ID0gc291cmNlQmVnaW5Sb3dDb2xbMF0gKyBNYXRoLmZsb29yKGkgLyBzb3VyY2VTaXplUm93Q29sWzFdKTtcbiAgICAgICAgICAgIHZhciBzcmNDb2wgPSBzb3VyY2VCZWdpblJvd0NvbFsxXSArIChpICUgc291cmNlU2l6ZVJvd0NvbFsxXSk7XG4gICAgICAgICAgICB2YXIgc3JjT2ZmID0gc3JjUm93ICogc291cmNlLnNoYXBlWzFdICsgc3JjQ29sO1xuICAgICAgICAgICAgdmFyIGRzdFJvdyA9IGRlc3RCZWdpblJvd0NvbFswXSArIE1hdGguZmxvb3IoaSAvIGRlc3RTaXplUm93Q29sWzFdKTtcbiAgICAgICAgICAgIHZhciBkc3RDb2wgPSBkZXN0QmVnaW5Sb3dDb2xbMV0gKyAoaSAlIGRlc3RTaXplUm93Q29sWzFdKTtcbiAgICAgICAgICAgIHZhciBkc3RPZmYgPSBkc3RSb3cgKiBkZXN0LnNoYXBlWzFdICsgZHN0Q29sO1xuICAgICAgICAgICAgZHN0VmFsdWVzW2RzdE9mZl0gPSBzcmNWYWx1ZXNbc3JjT2ZmXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNvbmNhdDFESW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSwgMCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuQXJyYXkxRC56ZXJvcyhvdXRTaGFwZSk7XG4gICAgICAgIHZhciBhVmFscyA9IGEuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBiVmFscyA9IGIuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmdldFZhbHVlcygpO1xuICAgICAgICB2YWxzLnNldChhVmFscywgMCk7XG4gICAgICAgIHZhbHMuc2V0KGJWYWxzLCBhLnNpemUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNvbmNhdDJESW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYiwgYXhpcykge1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuQXJyYXkyRC56ZXJvcyhvdXRTaGFwZSk7XG4gICAgICAgIGlmIChheGlzID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgYVZhbHMgPSBhLmdldFZhbHVlcygpO1xuICAgICAgICAgICAgdmFyIGJWYWxzID0gYi5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmdldFZhbHVlcygpO1xuICAgICAgICAgICAgdmFscy5zZXQoYVZhbHMsIDApO1xuICAgICAgICAgICAgdmFscy5zZXQoYlZhbHMsIGEuc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0U2hhcGVbMF07ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdXRTaGFwZVsxXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gW2ksIGpdO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhbYXhpc10gPCBhLnNoYXBlW2F4aXNdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYS5nZXQoaSwgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleFtheGlzXSAtPSBhLnNoYXBlW2F4aXNdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaTIgPSBpbmRleFswXSwgajIgPSBpbmRleFsxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBiLmdldChpMiwgajIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KHZhbHVlLCBpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNvbmNhdDNESW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYiwgYXhpcykge1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuQXJyYXkzRC56ZXJvcyhvdXRTaGFwZSk7XG4gICAgICAgIGlmIChheGlzID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgYVZhbHMgPSBhLmdldFZhbHVlcygpO1xuICAgICAgICAgICAgdmFyIGJWYWxzID0gYi5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmdldFZhbHVlcygpO1xuICAgICAgICAgICAgdmFscy5zZXQoYVZhbHMsIDApO1xuICAgICAgICAgICAgdmFscy5zZXQoYlZhbHMsIGEuc2l6ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0U2hhcGVbMF07ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdXRTaGFwZVsxXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXRTaGFwZVsyXTsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IFtpLCBqLCBrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhbYXhpc10gPCBhLnNoYXBlW2F4aXNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGEuZ2V0KGksIGosIGspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhbYXhpc10gLT0gYS5zaGFwZVtheGlzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpMiA9IGluZGV4WzBdLCBqMiA9IGluZGV4WzFdLCBrMiA9IGluZGV4WzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBiLmdldChpMiwgajIsIGsyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KHZhbHVlLCBpLCBqLCBrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jb25jYXQ0REludGVybmFsID0gZnVuY3Rpb24gKGEsIGIsIGF4aXMpIHtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gY29uY2F0X3V0aWwuY29tcHV0ZU91dFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUsIGF4aXMpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmRhcnJheV8xLkFycmF5NEQuemVyb3Mob3V0U2hhcGUpO1xuICAgICAgICBpZiAoYXhpcyA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGFWYWxzID0gYS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhciBiVmFscyA9IGIuZ2V0VmFsdWVzKCk7XG4gICAgICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5nZXRWYWx1ZXMoKTtcbiAgICAgICAgICAgIHZhbHMuc2V0KGFWYWxzLCAwKTtcbiAgICAgICAgICAgIHZhbHMuc2V0KGJWYWxzLCBhLnNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dFNoYXBlWzBdOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3V0U2hhcGVbMV07ICsraikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3V0U2hhcGVbMl07ICsraykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IG91dFNoYXBlWzNdOyArK2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IFtpLCBqLCBrLCBsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleFtheGlzXSA8IGEuc2hhcGVbYXhpc10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGEuZ2V0KGksIGosIGssIGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhbYXhpc10gLT0gYS5zaGFwZVtheGlzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaTIgPSBpbmRleFswXSwgajIgPSBpbmRleFsxXSwgazIgPSBpbmRleFsyXSwgbDIgPSBpbmRleFszXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGIuZ2V0KGkyLCBqMiwgazIsIGwyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQodmFsdWUsIGksIGosIGssIGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc2NhbGVkQXJyYXlBZGRJbnRlcm5hbCA9IGZ1bmN0aW9uIChjMSwgYSwgYzIsIGIpIHtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RlZFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh1dGlsLnNpemVGcm9tU2hhcGUobmV3U2hhcGUpKTtcbiAgICAgICAgdmFyIGFWYWx1ZXMgPSBhLmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgYlZhbHVlcyA9IGIuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBjMVZhbCA9IGMxLmdldCgpO1xuICAgICAgICB2YXIgYzJWYWwgPSBjMi5nZXQoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdWYWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IGMxVmFsICogYVZhbHVlc1tpICUgYS5zaXplXSArIGMyVmFsICogYlZhbHVlc1tpICUgYi5zaXplXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZXdTaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5uZWdJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxhclRpbWVzQXJyYXkobmRhcnJheV8xLlNjYWxhci5ORUdfT05FLCBhKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5hZGRJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlZEFycmF5QWRkSW50ZXJuYWwobmRhcnJheV8xLlNjYWxhci5PTkUsIGEsIG5kYXJyYXlfMS5TY2FsYXIuT05FLCBiKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5zdWJJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlZEFycmF5QWRkSW50ZXJuYWwobmRhcnJheV8xLlNjYWxhci5PTkUsIGEsIG5kYXJyYXlfMS5TY2FsYXIuTkVHX09ORSwgYik7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUubWF0TXVsSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYiwgYU9yaWVudGF0aW9uLCBiT3JpZW50YXRpb24pIHtcbiAgICAgICAgaWYgKGFPcmllbnRhdGlvbiA9PT0gdm9pZCAwKSB7IGFPcmllbnRhdGlvbiA9IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSOyB9XG4gICAgICAgIGlmIChiT3JpZW50YXRpb24gPT09IHZvaWQgMCkgeyBiT3JpZW50YXRpb24gPSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUjsgfVxuICAgICAgICB2YXIgc2hhcmVkRGltID0gKGFPcmllbnRhdGlvbiA9PT0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID8gYS5zaGFwZVsxXSA6IGEuc2hhcGVbMF07XG4gICAgICAgIHZhciBsZWZ0RGltID0gKGFPcmllbnRhdGlvbiA9PT0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID8gYS5zaGFwZVswXSA6IGEuc2hhcGVbMV07XG4gICAgICAgIHZhciByaWdodERpbSA9IChiT3JpZW50YXRpb24gPT09IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGIuc2hhcGVbMV0gOiBiLnNoYXBlWzBdO1xuICAgICAgICB2YXIgbm9ybWFsR2V0dGVyID0gZnVuY3Rpb24gKG1hdHJpeCwgaSwgaikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeC5nZXQoaSwgaik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0cmFuc3Bvc2VkR2V0dGVyID0gZnVuY3Rpb24gKG1hdHJpeCwgaSwgaikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeC5nZXQoaiwgaSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhR2V0dGVyID0gKGFPcmllbnRhdGlvbiA9PT0gbWF0aF8xLk1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID9cbiAgICAgICAgICAgIG5vcm1hbEdldHRlciA6XG4gICAgICAgICAgICB0cmFuc3Bvc2VkR2V0dGVyO1xuICAgICAgICB2YXIgYkdldHRlciA9IChiT3JpZW50YXRpb24gPT09IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/XG4gICAgICAgICAgICBub3JtYWxHZXR0ZXIgOlxuICAgICAgICAgICAgdHJhbnNwb3NlZEdldHRlcjtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobGVmdERpbSAqIHJpZ2h0RGltKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWZ0RGltOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmlnaHREaW07ICsraikge1xuICAgICAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2hhcmVkRGltOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IGFHZXR0ZXIoYSwgaSwgaykgKiBiR2V0dGVyKGIsIGssIGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZXNbaW5kZXgrK10gPSBzdW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5BcnJheTJELm5ldyhbbGVmdERpbSwgcmlnaHREaW1dLCB2YWx1ZXMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLm11bHRpcGx5SW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSB1dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdGVkU2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHV0aWwuc2l6ZUZyb21TaGFwZShuZXdTaGFwZSkpO1xuICAgICAgICB2YXIgYVZhbHVlcyA9IGEuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBiVmFsdWVzID0gYi5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdWYWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IGFWYWx1ZXNbaSAlIGEuc2l6ZV0gKiBiVmFsdWVzW2kgJSBiLnNpemVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5ld1NoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmRpdmlkZUludGVybmFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RlZFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh1dGlsLnNpemVGcm9tU2hhcGUobmV3U2hhcGUpKTtcbiAgICAgICAgdmFyIGFWYWx1ZXMgPSBhLmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgYlZhbHVlcyA9IGIuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3VmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBhVmFsdWVzW2kgJSBhLnNpemVdIC8gYlZhbHVlc1tpICUgYi5zaXplXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZXdTaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5zdW1JbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHN1bSArPSB2YWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5TY2FsYXIubmV3KHN1bSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuYXJnTWluSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIG1pbkluZGV4ID0gLTE7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZGFycmF5XzEuU2NhbGFyLm5ldyhOYU4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgbWluSW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuU2NhbGFyLm5ldyhtaW5JbmRleCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuYXJnTWF4SW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgbWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICB2YXIgbWF4SW5kZXggPSAtMTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5TY2FsYXIubmV3KE5hTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBtYXhJbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5TY2FsYXIubmV3KG1heEluZGV4KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5hcmdNYXhFcXVhbHNJbnRlcm5hbCA9IGZ1bmN0aW9uICh4MSwgeDIpIHtcbiAgICAgICAgdmFyIGFyZ01heDEgPSB0aGlzLmFyZ01heEludGVybmFsKHgxKS5nZXQoKTtcbiAgICAgICAgdmFyIGFyZ01heDIgPSB0aGlzLmFyZ01heEludGVybmFsKHgyKS5nZXQoKTtcbiAgICAgICAgaWYgKGlzTmFOKGFyZ01heDEpIHx8IGlzTmFOKGFyZ01heDIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmRhcnJheV8xLlNjYWxhci5uZXcoTmFOKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLlNjYWxhci5uZXcoKyhhcmdNYXgxID09PSBhcmdNYXgyKSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUudG9wS0ludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXksIGspIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciB2YWx1ZXNBbmRJbmRpY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZXNBbmRJbmRpY2VzLnB1c2goeyB2YWx1ZTogdmFsdWVzW2ldLCBpbmRleDogaSB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNBbmRJbmRpY2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLnZhbHVlIC0gYS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0b3BrVmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShrKTtcbiAgICAgICAgdmFyIHRvcGtJbmRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShrKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICAgIHRvcGtWYWx1ZXNbaV0gPSB2YWx1ZXNBbmRJbmRpY2VzW2ldLnZhbHVlO1xuICAgICAgICAgICAgdG9wa0luZGljZXNbaV0gPSB2YWx1ZXNBbmRJbmRpY2VzW2ldLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbHVlczogbmRhcnJheV8xLkFycmF5MUQubmV3KHRvcGtWYWx1ZXMpLCBpbmRpY2VzOiBuZGFycmF5XzEuQXJyYXkxRC5uZXcodG9wa0luZGljZXMpIH07XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUubWluSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIG1pbiA9IHZhbHVlc1swXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmRhcnJheV8xLlNjYWxhci5uZXcoTmFOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuU2NhbGFyLm5ldyhtaW4pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLm1heEludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBtYXggPSB2YWx1ZXNbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5TY2FsYXIubmV3KE5hTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLlNjYWxhci5uZXcobWF4KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5leHBJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGguZXhwKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5sb2dJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGgubG9nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnNxcnRJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGguc3FydCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5sb2dTdW1FeHBJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciB4TWF4ID0gdGhpcy5tYXgobmRhcnJheSk7XG4gICAgICAgIHZhciBhID0gdGhpcy5hcnJheU1pbnVzU2NhbGFyKG5kYXJyYXksIHhNYXgpO1xuICAgICAgICB2YXIgYiA9IHRoaXMuZXhwKGEpO1xuICAgICAgICB2YXIgYyA9IHRoaXMuc3VtKGIpO1xuICAgICAgICB2YXIgZCA9IHRoaXMubG9nKGMpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5hZGQoeE1heCwgZCk7XG4gICAgICAgIHhNYXguZGlzcG9zZSgpO1xuICAgICAgICBhLmRpc3Bvc2UoKTtcbiAgICAgICAgYi5kaXNwb3NlKCk7XG4gICAgICAgIGMuZGlzcG9zZSgpO1xuICAgICAgICBkLmRpc3Bvc2UoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5yZWx1SW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGgubWF4KDAsIHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5hYnNJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5hYnModmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnNpZ21vaWRJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gMSAvICgxICsgTWF0aC5leHAoLXZhbHVlc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc2luSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguc2luKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jb3NJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5jb3ModmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnRhbkludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLnRhbih2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuYXNpbkludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmFzaW4odmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmFjb3NJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5hY29zKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5hdGFuSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguYXRhbih2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc2luaEludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLnNpbmgodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhcnJheV8xLk5EQXJyYXkubWFrZShuZGFycmF5LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmNvc2hJbnRlcm5hbCA9IGZ1bmN0aW9uIChuZGFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5jb3NoKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS50YW5oSW50ZXJuYWwgPSBmdW5jdGlvbiAobmRhcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHV0aWwudGFuaCh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5kYXJyYXkuc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuc3RlcEludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXkpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkobmRhcnJheS5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSB2YWx1ZSA+IDAgPyAxIDogKHZhbHVlIDwgMCA/IDAgOiB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5OREFycmF5Lm1ha2UobmRhcnJheS5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jb252MmRJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIGJpYXMsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBfYSA9IHguc2hhcGUsIHhSb3dzID0gX2FbMF0sIHhDb2xzID0gX2FbMV0sIGlucHV0RGVwdGggPSBfYVsyXTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGZpbHRlci5zaGFwZVswXTtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gZmlsdGVyLnNoYXBlWzFdO1xuICAgICAgICB2YXIgb3V0RGVwdGggPSBmaWx0ZXIuc2hhcGVbM107XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciB5ID0gbmRhcnJheV8xLkFycmF5M0QuemVyb3MoY29udkluZm8ub3V0U2hhcGUpO1xuICAgICAgICBmb3IgKHZhciBkMiA9IDA7IGQyIDwgb3V0RGVwdGg7ICsrZDIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHlSID0gMDsgeVIgPCB5LnNoYXBlWzBdOyArK3lSKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geVIgKiBjb252SW5mby5zdHJpZGVIZWlnaHQgLSBwYWRMZWZ0O1xuICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IE1hdGgubWF4KDAsIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgeFJNYXggPSBNYXRoLm1pbih4Um93cywgZmlsdGVySGVpZ2h0ICsgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0gMDsgeUMgPCB5LnNoYXBlWzFdOyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHlDICogY29udkluZm8uc3RyaWRlV2lkdGggLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q01pbiA9IE1hdGgubWF4KDAsIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWF4ID0gTWF0aC5taW4oeENvbHMsIGZpbHRlcldpZHRoICsgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhSID0geFJNaW47IHhSIDwgeFJNYXg7ICsreFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3UiA9IHhSIC0geFJDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IHhDTWluOyB4QyA8IHhDTWF4OyArK3hDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdDID0geEMgLSB4Q0Nvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkMSA9IDA7IGQxIDwgaW5wdXREZXB0aDsgKytkMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSB4LmdldCh4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodCA9IGZpbHRlci5nZXQod1IsIHdDLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYmlhc1ZhbCA9IChiaWFzICE9IG51bGwpID8gYmlhcy5nZXQoZDIpIDogMDtcbiAgICAgICAgICAgICAgICAgICAgeS5zZXQoZG90UHJvZCArIGJpYXNWYWwsIHlSLCB5QywgZDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5jb252MmREZXJJbnB1dEludGVybmFsID0gZnVuY3Rpb24gKGR5LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBpbkRlcHRoID0gZmlsdGVyLnNoYXBlWzJdO1xuICAgICAgICB2YXIgb3V0RGVwdGggPSBmaWx0ZXIuc2hhcGVbM107XG4gICAgICAgIHZhciB5Um93cyA9IGR5LnNoYXBlWzBdO1xuICAgICAgICB2YXIgeUNvbHMgPSBkeS5zaGFwZVsxXTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGZpbHRlci5zaGFwZVswXTtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gZmlsdGVyLnNoYXBlWzFdO1xuICAgICAgICB2YXIgdG9wUGFkID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgbGVmdFBhZCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBkeCA9IG5kYXJyYXlfMS5BcnJheTNELnplcm9zKGNvbnZJbmZvLmluU2hhcGUpO1xuICAgICAgICBmb3IgKHZhciBkMSA9IDA7IGQxIDwgaW5EZXB0aDsgKytkMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgeFIgPSAwOyB4UiA8IGR4LnNoYXBlWzBdOyArK3hSKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geFIgLSBsZWZ0UGFkO1xuICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCh4UkNvcm5lciAvIHN0cmlkZUhlaWdodCkpO1xuICAgICAgICAgICAgICAgIHZhciB5Uk1heCA9IE1hdGgubWluKHlSb3dzLCAoZmlsdGVySGVpZ2h0ICsgeFJDb3JuZXIpIC8gc3RyaWRlSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IDA7IHhDIDwgZHguc2hhcGVbMV07ICsreEMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDQ29ybmVyID0geEMgLSB0b3BQYWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q01pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCh4Q0Nvcm5lciAvIHN0cmlkZVdpZHRoKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5Q01heCA9IE1hdGgubWluKHlDb2xzLCAoZmlsdGVyV2lkdGggKyB4Q0Nvcm5lcikgLyBzdHJpZGVXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeVIgPSB4Uk1pbjsgeVIgPCB5Uk1heDsgKyt5Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdSID0geVIgKiBzdHJpZGVIZWlnaHQgLSB4UkNvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0geENNaW47IHlDIDwgeUNNYXg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd0MgPSB5QyAqIHN0cmlkZVdpZHRoIC0geENDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwOyBkMiA8IG91dERlcHRoOyArK2QyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGR5LmdldCh5UiwgeUMsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodCA9IGZpbHRlci5nZXQoZmlsdGVySGVpZ2h0IC0gMSAtIHdSLCBmaWx0ZXJXaWR0aCAtIDEgLSB3QywgZDEsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSBwaXhlbCAqIHdlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZHguc2V0KGRvdFByb2QsIHhSLCB4QywgZDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHg7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVySW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgZFksIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBpbnB1dERlcHRoID0geC5zaGFwZVsyXTtcbiAgICAgICAgdmFyIG91dHB1dERlcHRoID0gZFkuc2hhcGVbMl07XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHdlaWdodHNTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlV2VpZ2h0c1NoYXBlNEQoaW5wdXREZXB0aCwgb3V0cHV0RGVwdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgpO1xuICAgICAgICB2YXIgZFcgPSBuZGFycmF5XzEuQXJyYXk0RC56ZXJvcyh3ZWlnaHRzU2hhcGUpO1xuICAgICAgICB2YXIgeU51bVJvd3MgPSBkWS5zaGFwZVswXTtcbiAgICAgICAgdmFyIHlOdW1Db2xzID0gZFkuc2hhcGVbMV07XG4gICAgICAgIHZhciB4TnVtUm93cyA9IHguc2hhcGVbMF07XG4gICAgICAgIHZhciB4TnVtQ29scyA9IHguc2hhcGVbMV07XG4gICAgICAgIHZhciBsZWZ0UGFkID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgdG9wUGFkID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIGZvciAodmFyIHdSID0gMDsgd1IgPCBmaWx0ZXJIZWlnaHQ7ICsrd1IpIHtcbiAgICAgICAgICAgIHZhciB5Uk1pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgodG9wUGFkIC0gd1IpIC8gc3RyaWRlSGVpZ2h0KSk7XG4gICAgICAgICAgICB2YXIgeVJNYXggPSBNYXRoLm1pbih5TnVtUm93cywgKHhOdW1Sb3dzICsgdG9wUGFkIC0gd1IpIC8gc3RyaWRlSGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBmaWx0ZXJXaWR0aDsgKyt3Qykge1xuICAgICAgICAgICAgICAgIHZhciB5Q01pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgobGVmdFBhZCAtIHdDKSAvIHN0cmlkZVdpZHRoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHlDTWF4ID0gTWF0aC5taW4oeU51bUNvbHMsICh4TnVtQ29scyArIGxlZnRQYWQgLSB3QykgLyBzdHJpZGVXaWR0aCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGlucHV0RGVwdGg7ICsrZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDIgPSAwOyBkMiA8IG91dHB1dERlcHRoOyArK2QyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IHlSTWluOyB5UiA8IHlSTWF4OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhSID0gd1IgKyB5UiAqIHN0cmlkZUhlaWdodCAtIHRvcFBhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IHlDTWluOyB5QyA8IHlDTWF4OyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4QyA9IHdDICsgeUMgKiBzdHJpZGVXaWR0aCAtIGxlZnRQYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0geC5nZXQoeFIsIHhDLCBkMSkgKiBkWS5nZXQoeVIsIHlDLCBkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZFcuc2V0KGRvdFByb2QsIHdSLCB3QywgZDEsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZFc7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUuY29udjJkRGVyQmlhc0ludGVybmFsID0gZnVuY3Rpb24gKGRZKSB7XG4gICAgICAgIHZhciBvdXRwdXREZXB0aCA9IGRZLnNoYXBlWzJdO1xuICAgICAgICB2YXIgbnVtUm93cyA9IGRZLnNoYXBlWzBdO1xuICAgICAgICB2YXIgbnVtQ29scyA9IGRZLnNoYXBlWzFdO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShvdXRwdXREZXB0aCk7XG4gICAgICAgIGZvciAodmFyIGQyID0gMDsgZDIgPCBvdXRwdXREZXB0aDsgKytkMikge1xuICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IG51bVJvd3M7ICsrcikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbnVtQ29sczsgKytjKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBkWS5nZXQociwgYywgZDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlc1tkMl0gPSBzdW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5BcnJheTFELm5ldyh2YWx1ZXMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLnN3aXRjaERpbUludGVybmFsID0gZnVuY3Rpb24gKHQsIG5ld0RpbSkge1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSBuZXcgQXJyYXkodC5yYW5rKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3U2hhcGVbaV0gPSB0LnNoYXBlW25ld0RpbVtpXV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHQuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZGFycmF5XzEuTkRBcnJheS5tYWtlKG5ld1NoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHQuc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0gdC5pbmRleFRvTG9jKGkpO1xuICAgICAgICAgICAgdmFyIG5ld0xvYyA9IG5ldyBBcnJheShsb2MubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSA8IG5ld0xvYy5sZW5ndGg7IGlfMSsrKSB7XG4gICAgICAgICAgICAgICAgbmV3TG9jW2lfMV0gPSBsb2NbbmV3RGltW2lfMV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld0luZGV4ID0gcmVzdWx0LmxvY1RvSW5kZXgobmV3TG9jKTtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tuZXdJbmRleF0gPSB2YWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5wb29sID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvLCBwb29sVHlwZSkge1xuICAgICAgICB2YXIgX2EgPSB4LnNoYXBlLCB4Um93cyA9IF9hWzBdLCB4Q29scyA9IF9hWzFdLCBkZXB0aCA9IF9hWzJdO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciB5ID0gbmRhcnJheV8xLkFycmF5M0QuemVyb3MoY29udkluZm8ub3V0U2hhcGUpO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRlcHRoOyArK2QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHlSID0gMDsgeVIgPCB5LnNoYXBlWzBdOyArK3lSKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geVIgKiBzdHJpZGVIZWlnaHQgLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgdmFyIHhSTWluID0gTWF0aC5tYXgoMCwgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgIHZhciB4Uk1heCA9IE1hdGgubWluKHhSb3dzLCBmaWx0ZXJIZWlnaHQgKyB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSAwOyB5QyA8IHkuc2hhcGVbMV07ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDQ29ybmVyID0geUMgKiBzdHJpZGVXaWR0aCAtIHBhZExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q01pbiA9IE1hdGgubWF4KDAsIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWF4ID0gTWF0aC5taW4oeENvbHMsIGZpbHRlcldpZHRoICsgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWluTWF4VmFsdWUgPSAocG9vbFR5cGUgPT09ICdtYXgnID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdmdWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhSID0geFJNaW47IHhSIDwgeFJNYXg7ICsreFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhDID0geENNaW47IHhDIDwgeENNYXg7ICsreEMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSB4LmdldCh4UiwgeEMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihwaXhlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSBOYU47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2Z1ZhbHVlID0gTmFOO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwb29sVHlwZSA9PT0gJ21heCcgJiYgcGl4ZWwgPiBtaW5NYXhWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBvb2xUeXBlID09PSAnbWluJyAmJiBwaXhlbCA8IG1pbk1heFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwb29sVHlwZSA9PT0gJ2F2ZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZnVmFsdWUgKz0gcGl4ZWwgLyAoZmlsdGVySGVpZ2h0ICogZmlsdGVyV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihtaW5NYXhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5LnNldChwb29sVHlwZSA9PT0gJ2F2ZycgPyBhdmdWYWx1ZSA6IG1pbk1heFZhbHVlLCB5UiwgeUMsIGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5tYXhQb29sSW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgY29udkluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9vbCh4LCBjb252SW5mbywgJ21heCcpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLm1heFBvb2xQb3NpdGlvbnMgPSBmdW5jdGlvbiAoeCwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIF9hID0geC5zaGFwZSwgeFJvd3MgPSBfYVswXSwgeENvbHMgPSBfYVsxXSwgZGVwdGggPSBfYVsyXTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gY29udkluZm8ub3V0U2hhcGU7XG4gICAgICAgIHZhciBtYXhQb3NpdGlvbnMgPSBuZGFycmF5XzEuQXJyYXkzRC56ZXJvcyhvdXRwdXRTaGFwZSk7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkZXB0aDsgKytkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB5UiA9IDA7IHlSIDwgb3V0cHV0U2hhcGVbMF07ICsreVIpIHtcbiAgICAgICAgICAgICAgICB2YXIgeFJDb3JuZXIgPSB5UiAqIHN0cmlkZUhlaWdodCAtIHBhZFRvcDtcbiAgICAgICAgICAgICAgICB2YXIgeFJNaW4gPSBNYXRoLm1heCgwLCB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgdmFyIHhSTWF4ID0gTWF0aC5taW4oeFJvd3MsIGZpbHRlckhlaWdodCArIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IDA7IHlDIDwgb3V0cHV0U2hhcGVbMV07ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDQ29ybmVyID0geUMgKiBzdHJpZGVXaWR0aCAtIHBhZExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Q01pbiA9IE1hdGgubWF4KDAsIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWF4ID0gTWF0aC5taW4oeENvbHMsIGZpbHRlcldpZHRoICsgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4VmFsdWUgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhQb3NpdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4UiA9IHhSTWluOyB4UiA8IHhSTWF4OyArK3hSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd1IgPSB4UiAtIHhSQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeEMgPSB4Q01pbjsgeEMgPCB4Q01heDsgKyt4Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3QyA9IHhDIC0geENDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0geC5nZXQoeFIsIHhDLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGl4ZWwgPiBtYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhQb3NpdGlvbiA9IHdSICogZmlsdGVyV2lkdGggKyB3QztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF4UG9zaXRpb25zLnNldChtYXhQb3NpdGlvbiwgeVIsIHlDLCBkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heFBvc2l0aW9ucztcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5tYXhQb29sQmFja3Byb3BJbnRlcm5hbCA9IGZ1bmN0aW9uIChkeSwgeCwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIG1heFBvc2l0aW9ucyA9IHRoaXMubWF4UG9vbFBvc2l0aW9ucyh4LCBjb252SW5mbyk7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBmaWx0ZXJXaWR0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBwYWRUb3AgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBfYSA9IGR5LnNoYXBlLCBkeVJvd3MgPSBfYVswXSwgZHlDb2xzID0gX2FbMV0sIGRlcHRoID0gX2FbMl07XG4gICAgICAgIHZhciBkeCA9IG5kYXJyYXlfMS5BcnJheTNELnplcm9zKHguc2hhcGUpO1xuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRlcHRoOyArK2QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGR4UiA9IDA7IGR4UiA8IGR4LnNoYXBlWzBdOyArK2R4Uikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGR4QyA9IDA7IGR4QyA8IGR4LnNoYXBlWzFdOyArK2R4Qykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHlSQ29ybmVyID0gZHhSIC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHlDQ29ybmVyID0gZHhDIC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB3UiA9IDA7IHdSIDwgZmlsdGVySGVpZ2h0OyArK3dSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlSID0gKGR5UkNvcm5lciArIHdSKSAvIHN0cmlkZUhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSBkeVJvd3MgfHwgTWF0aC5mbG9vcihkeVIpICE9PSBkeVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBmaWx0ZXJXaWR0aDsgKyt3Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeUMgPSAoZHlDQ29ybmVyICsgd0MpIC8gc3RyaWRlV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR5QyA8IDAgfHwgZHlDID49IGR5Q29scyB8fCBNYXRoLmZsb29yKGR5QykgIT09IGR5Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heFBvcyA9IGZpbHRlckhlaWdodCAqIGZpbHRlcldpZHRoIC0gMSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFBvc2l0aW9ucy5nZXQoZHlSLCBkeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJQb3MgPSB3UiAqIGZpbHRlcldpZHRoICsgd0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hc2sgPSBtYXhQb3MgPT09IGN1clBvcyA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBkeS5nZXQoZHlSLCBkeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWwgKiBtYXNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGR4LnNldChkb3RQcm9kLCBkeFIsIGR4QywgZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkeDtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5taW5Qb29sSW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgY29udkluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9vbCh4LCBjb252SW5mbywgJ21pbicpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmF2Z1Bvb2xJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb29sKHgsIGNvbnZJbmZvLCAnYXZnJyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aENQVS5wcm90b3R5cGUucmVzaXplQmlsaW5lYXIzREludGVybmFsID0gZnVuY3Rpb24gKHgsIG5ld1NoYXBlMkQsIGFsaWduQ29ybmVycykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gbmRhcnJheV8xLkFycmF5M0QuemVyb3MoW25ld1NoYXBlMkRbMF0sIG5ld1NoYXBlMkRbMV0sIHguc2hhcGVbMl1dKTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUlucHV0U2l6ZSA9IGFsaWduQ29ybmVycyA/IFt4LnNoYXBlWzBdIC0gMSwgeC5zaGFwZVsxXSAtIDEsIHguc2hhcGVbMl1dIDogeC5zaGFwZTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZU91dHB1dFNpemUgPSBhbGlnbkNvcm5lcnMgP1xuICAgICAgICAgICAgW291dHB1dC5zaGFwZVswXSAtIDEsIG91dHB1dC5zaGFwZVsxXSAtIDEsIG91dHB1dC5zaGFwZVsyXV0gOlxuICAgICAgICAgICAgb3V0cHV0LnNoYXBlO1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IG91dHB1dC5zaGFwZVswXTsgcisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG91dHB1dC5zaGFwZVsxXTsgYysrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBvdXRwdXQuc2hhcGVbMl07IGQrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlRnJhY1JvdyA9IChlZmZlY3RpdmVJbnB1dFNpemVbMF0pICogciAvIChlZmZlY3RpdmVPdXRwdXRTaXplWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUZyYWNDb2wgPSAoZWZmZWN0aXZlSW5wdXRTaXplWzFdKSAqIGMgLyAoZWZmZWN0aXZlT3V0cHV0U2l6ZVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VSb3dGbG9vciA9IE1hdGguZmxvb3Ioc291cmNlRnJhY1Jvdyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VSb3dDZWlsID0gTWF0aC5taW4oeC5zaGFwZVswXSAtIDEsIE1hdGguY2VpbChzb3VyY2VGcmFjUm93KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VDb2xGbG9vciA9IE1hdGguZmxvb3Ioc291cmNlRnJhY0NvbCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VDb2xDZWlsID0gTWF0aC5taW4oeC5zaGFwZVsxXSAtIDEsIE1hdGguY2VpbChzb3VyY2VGcmFjQ29sKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3BMZWZ0ID0geC5nZXQoc291cmNlUm93Rmxvb3IsIHNvdXJjZUNvbEZsb29yLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbUxlZnQgPSB4LmdldChzb3VyY2VSb3dDZWlsLCBzb3VyY2VDb2xGbG9vciwgZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3BSaWdodCA9IHguZ2V0KHNvdXJjZVJvd0Zsb29yLCBzb3VyY2VDb2xDZWlsLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0geC5nZXQoc291cmNlUm93Q2VpbCwgc291cmNlQ29sQ2VpbCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3dGcmFjID0gc291cmNlRnJhY1JvdyAtIHNvdXJjZVJvd0Zsb29yO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sRnJhYyA9IHNvdXJjZUZyYWNDb2wgLSBzb3VyY2VDb2xGbG9vcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvcF8xID0gdG9wTGVmdCArICh0b3BSaWdodCAtIHRvcExlZnQpICogY29sRnJhYztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbSA9IGJvdHRvbUxlZnQgKyAoYm90dG9tUmlnaHQgLSBib3R0b21MZWZ0KSAqIGNvbEZyYWM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRvcF8xICsgKGJvdHRvbSAtIHRvcF8xKSAqIHJvd0ZyYWM7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXQobmV3VmFsdWUsIHIsIGMsIGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhDUFUucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbjNESW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICBpZiAodmFyaWFuY2VFcHNpbG9uID09PSB2b2lkIDApIHsgdmFyaWFuY2VFcHNpbG9uID0gLjAwMTsgfVxuICAgICAgICB2YXIgeFZhbHVlcyA9IHguZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBtZWFuVmFsdWVzID0gbWVhbi5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIHZhcmlhbmNlVmFsdWVzID0gdmFyaWFuY2UuZ2V0VmFsdWVzKCk7XG4gICAgICAgIHZhciBzY2FsZVZhbHVlcyA9IHNjYWxlID8gc2NhbGUuZ2V0VmFsdWVzKCkgOiBuZXcgRmxvYXQzMkFycmF5KFsxXSk7XG4gICAgICAgIHZhciBvZmZzZXRWYWx1ZXMgPSBvZmZzZXQgPyBvZmZzZXQuZ2V0VmFsdWVzKCkgOiBuZXcgRmxvYXQzMkFycmF5KFswXSk7XG4gICAgICAgIHZhciBvdXRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHhWYWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRWYWx1ZXNbaV0gPSBvZmZzZXRWYWx1ZXNbaSAlIG9mZnNldFZhbHVlcy5sZW5ndGhdICtcbiAgICAgICAgICAgICAgICAoeFZhbHVlc1tpXSAtIG1lYW5WYWx1ZXNbaSAlIG1lYW5WYWx1ZXMubGVuZ3RoXSkgKlxuICAgICAgICAgICAgICAgICAgICBzY2FsZVZhbHVlc1tpICUgc2NhbGVWYWx1ZXMubGVuZ3RoXSAvXG4gICAgICAgICAgICAgICAgICAgIE1hdGguc3FydCh2YXJpYW5jZVZhbHVlc1tpICUgdmFyaWFuY2VWYWx1ZXMubGVuZ3RoXSArIHZhcmlhbmNlRXBzaWxvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kYXJyYXlfMS5BcnJheTNELm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG91dFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5tdWx0aW5vbWlhbEludGVybmFsID0gZnVuY3Rpb24gKHByb2JhYmlsaXRpZXMsIG51bVNhbXBsZXMsIHNlZWQpIHtcbiAgICAgICAgdmFyIHByb2JWYWxzID0gcHJvYmFiaWxpdGllcy5nZXRWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGNkZiA9IG5ldyBGbG9hdDMyQXJyYXkocHJvYmFiaWxpdGllcy5zaXplIC0gMSk7XG4gICAgICAgIGNkZlswXSA9IHByb2JWYWxzWzBdO1xuICAgICAgICBmb3IgKHZhciBldmVudF8xID0gMTsgZXZlbnRfMSA8IGNkZi5sZW5ndGg7ICsrZXZlbnRfMSkge1xuICAgICAgICAgICAgY2RmW2V2ZW50XzFdID0gY2RmW2V2ZW50XzEgLSAxXSArIHByb2JWYWxzW2V2ZW50XzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5kb20gPSBzZWVkcmFuZG9tLmFsZWEoc2VlZC50b1N0cmluZygpKTtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBGbG9hdDMyQXJyYXkobnVtU2FtcGxlcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2FtcGxlczsgKytpKSB7XG4gICAgICAgICAgICB2YXIgciA9IHJhbmRvbSgpO1xuICAgICAgICAgICAgcmVzW2ldID0gY2RmLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGV2ZW50XzIgPSAwOyBldmVudF8yIDwgY2RmLmxlbmd0aDsgZXZlbnRfMisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHIgPCBjZGZbZXZlbnRfMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2ldID0gZXZlbnRfMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuQXJyYXkxRC5uZXcocmVzKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoQ1BVLnByb3RvdHlwZS5vbmVIb3RJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbmRpY2VzLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBGbG9hdDMyQXJyYXkoaW5kaWNlcy5zaXplICogZGVwdGgpO1xuICAgICAgICByZXMuZmlsbChvZmZWYWx1ZSk7XG4gICAgICAgIGZvciAodmFyIGV2ZW50XzMgPSAwOyBldmVudF8zIDwgaW5kaWNlcy5zaXplOyArK2V2ZW50XzMpIHtcbiAgICAgICAgICAgIHJlc1tldmVudF8zICogZGVwdGggKyBpbmRpY2VzLmdldChldmVudF8zKV0gPSBvblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuQXJyYXkyRC5uZXcoW2luZGljZXMuc2l6ZSwgZGVwdGhdLCByZXMpO1xuICAgIH07XG4gICAgcmV0dXJuIE5EQXJyYXlNYXRoQ1BVO1xufShtYXRoXzEuTkRBcnJheU1hdGgpKTtcbmV4cG9ydHMuTkRBcnJheU1hdGhDUFUgPSBOREFycmF5TWF0aENQVTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGhfY3B1LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/math_cpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/math_gpu.js":
/*!**********************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/math_gpu.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar math_1 = __webpack_require__(/*! ./math */ \"./node_modules/deeplearn/dist/src/math/math.js\");\nvar ndarray = __webpack_require__(/*! ./ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar ndarray_1 = __webpack_require__(/*! ./ndarray */ \"./node_modules/deeplearn/dist/src/math/ndarray.js\");\nvar addscaledmat_gpu_1 = __webpack_require__(/*! ./webgl/addscaledmat_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/addscaledmat_gpu.js\");\nvar argmaxequals_gpu_1 = __webpack_require__(/*! ./webgl/argmaxequals_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/argmaxequals_gpu.js\");\nvar argminmax_gpu_1 = __webpack_require__(/*! ./webgl/argminmax_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/argminmax_gpu.js\");\nvar batchnorm_gpu_1 = __webpack_require__(/*! ./webgl/batchnorm_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/batchnorm_gpu.js\");\nvar binaryop_gpu = __webpack_require__(/*! ./webgl/binaryop_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/binaryop_gpu.js\");\nvar binaryop_gpu_1 = __webpack_require__(/*! ./webgl/binaryop_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/binaryop_gpu.js\");\nvar concat_gpu_1 = __webpack_require__(/*! ./webgl/concat_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/concat_gpu.js\");\nvar conv_backprop_gpu_1 = __webpack_require__(/*! ./webgl/conv_backprop_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/conv_backprop_gpu.js\");\nvar conv_gpu_1 = __webpack_require__(/*! ./webgl/conv_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/conv_gpu.js\");\nvar copy_gpu_1 = __webpack_require__(/*! ./webgl/copy_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/copy_gpu.js\");\nvar gpgpu_context_1 = __webpack_require__(/*! ./webgl/gpgpu_context */ \"./node_modules/deeplearn/dist/src/math/webgl/gpgpu_context.js\");\nvar gpgpu_math = __webpack_require__(/*! ./webgl/gpgpu_math */ \"./node_modules/deeplearn/dist/src/math/webgl/gpgpu_math.js\");\nvar gpgpu_util = __webpack_require__(/*! ./webgl/gpgpu_util */ \"./node_modules/deeplearn/dist/src/math/webgl/gpgpu_util.js\");\nvar logsumexp_gpu_1 = __webpack_require__(/*! ./webgl/logsumexp_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/logsumexp_gpu.js\");\nvar max_pool_backprop_gpu_1 = __webpack_require__(/*! ./webgl/max_pool_backprop_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/max_pool_backprop_gpu.js\");\nvar minmax_gpu_1 = __webpack_require__(/*! ./webgl/minmax_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/minmax_gpu.js\");\nvar mulmat_gpu_1 = __webpack_require__(/*! ./webgl/mulmat_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/mulmat_gpu.js\");\nvar multinomial_gpu_1 = __webpack_require__(/*! ./webgl/multinomial_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/multinomial_gpu.js\");\nvar onehot_gpu_1 = __webpack_require__(/*! ./webgl/onehot_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/onehot_gpu.js\");\nvar pool_gpu_1 = __webpack_require__(/*! ./webgl/pool_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/pool_gpu.js\");\nvar reducesum_gpu_1 = __webpack_require__(/*! ./webgl/reducesum_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/reducesum_gpu.js\");\nvar resize_bilinear_gpu_1 = __webpack_require__(/*! ./webgl/resize_bilinear_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/resize_bilinear_gpu.js\");\nvar slice_gpu_1 = __webpack_require__(/*! ./webgl/slice_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/slice_gpu.js\");\nvar texture_manager_1 = __webpack_require__(/*! ./webgl/texture_manager */ \"./node_modules/deeplearn/dist/src/math/webgl/texture_manager.js\");\nvar unary_op = __webpack_require__(/*! ./webgl/unaryop_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/unaryop_gpu.js\");\nvar unaryop_gpu_1 = __webpack_require__(/*! ./webgl/unaryop_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/unaryop_gpu.js\");\nvar webgl_util = __webpack_require__(/*! ./webgl/webgl_util */ \"./node_modules/deeplearn/dist/src/math/webgl/webgl_util.js\");\nvar NDArrayMathGPU = (function (_super) {\n    __extends(NDArrayMathGPU, _super);\n    function NDArrayMathGPU(gpgpu, safeMode) {\n        if (safeMode === void 0) { safeMode = false; }\n        var _this = _super.call(this, safeMode) || this;\n        _this.binaryCache = {};\n        if (gpgpu == null) {\n            var gl = gpgpu_util.createWebGLContext();\n            _this.gpgpu = new gpgpu_context_1.GPGPUContext(gl);\n            _this.gpgpuCreatedLocally = true;\n        }\n        else {\n            _this.gpgpu = gpgpu;\n            _this.gpgpuCreatedLocally = false;\n        }\n        _this.textureManager = new texture_manager_1.TextureManager(_this.gpgpu);\n        ndarray.initializeGPU(_this.gpgpu, _this.textureManager);\n        return _this;\n    }\n    NDArrayMathGPU.prototype.getGPGPUContext = function () {\n        return this.gpgpu;\n    };\n    NDArrayMathGPU.prototype.cloneInternal = function (a) {\n        var texShape = a.getTextureShapeRC();\n        var source = a.as2D(texShape[0], texShape[1]);\n        var output = this.makeOutputArray(texShape);\n        this.copy2D(source, [0, 0], texShape, output, [0, 0], texShape);\n        return output.reshape(a.shape);\n    };\n    NDArrayMathGPU.prototype.slice1DInternal = function (input, begin, size) {\n        var program = new slice_gpu_1.SliceProgram([size]);\n        var customSetup = program.getCustomSetupFunc([begin]);\n        return this.compileAndRun(program, [input], null, customSetup);\n    };\n    NDArrayMathGPU.prototype.slice2DInternal = function (input, begin, size) {\n        var program = new slice_gpu_1.SliceProgram(size);\n        var customSetup = program.getCustomSetupFunc(begin);\n        return this.compileAndRun(program, [input], null, customSetup);\n    };\n    NDArrayMathGPU.prototype.slice3DInternal = function (input, begin, size) {\n        var program = new slice_gpu_1.SliceProgram(size);\n        var customSetup = program.getCustomSetupFunc(begin);\n        return this.compileAndRun(program, [input], null, customSetup);\n    };\n    NDArrayMathGPU.prototype.slice4DInternal = function (input, begin, size) {\n        var program = new slice_gpu_1.SliceProgram(size);\n        var customSetup = program.getCustomSetupFunc(begin);\n        return this.compileAndRun(program, [input], null, customSetup);\n    };\n    NDArrayMathGPU.prototype.copy2DInternal = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {\n        var program = new copy_gpu_1.Copy2DProgram(sourceSizeRowCol[1], destSizeRowCol[1]);\n        var customSetup = program.getCustomSetupFunc(sourceBeginRowCol, destBeginRowCol, destSizeRowCol);\n        this.compileAndRun(program, [source], dest, customSetup);\n    };\n    NDArrayMathGPU.prototype.concat1DInternal = function (a, b) {\n        var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape, 0);\n        return this.compileAndRun(program, [a, b]);\n    };\n    NDArrayMathGPU.prototype.concat2DInternal = function (a, b, axis) {\n        var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape, axis);\n        return this.compileAndRun(program, [a, b]);\n    };\n    NDArrayMathGPU.prototype.concat3DInternal = function (x1, x2, axis) {\n        var program = new concat_gpu_1.ConcatProgram(x1.shape, x2.shape, axis);\n        return this.compileAndRun(program, [x1, x2]);\n    };\n    NDArrayMathGPU.prototype.concat4DInternal = function (x1, x2, axis) {\n        var program = new concat_gpu_1.ConcatProgram(x1.shape, x2.shape, axis);\n        return this.compileAndRun(program, [x1, x2]);\n    };\n    NDArrayMathGPU.prototype.scaledArrayAddInternal = function (c1, a, c2, b) {\n        var program = new addscaledmat_gpu_1.AddScaledMatProgram(a.shape, b.shape);\n        return this.compileAndRun(program, [a, b, c1, c2]);\n    };\n    NDArrayMathGPU.prototype.negInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.NEG);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.makeOutputArray = function (shape) {\n        var textureShapeRC = webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl, shape);\n        var texture = this.textureManager.acquireTexture(textureShapeRC);\n        return ndarray_1.NDArray.make(shape, { texture: texture, textureShapeRC: textureShapeRC });\n    };\n    NDArrayMathGPU.prototype.compileAndRun = function (program, inputs, output, customSetup) {\n        var _this = this;\n        if (output == null) {\n            output = this.makeOutputArray(program.outputShape);\n        }\n        var key = gpgpu_math.makeShaderKey(program, inputs, output);\n        var binary = this.getAndSaveBinary(key, function () {\n            return gpgpu_math.compileProgram(_this.gpgpu, program, inputs, output);\n        });\n        gpgpu_math.runProgram(binary, inputs, output, customSetup);\n        return output;\n    };\n    NDArrayMathGPU.prototype.matMulInternal = function (a, b, aOrientation, bOrientation) {\n        var program = new mulmat_gpu_1.MatMulProgram(a.shape, b.shape, aOrientation, bOrientation);\n        return this.compileAndRun(program, [a, b]);\n    };\n    NDArrayMathGPU.prototype.multiplyInternal = function (a, b) {\n        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MUL, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b]);\n    };\n    NDArrayMathGPU.prototype.batchNormalization3DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {\n        var inputs = [x, mean, variance];\n        if (varianceEpsilon == null) {\n            varianceEpsilon = 0.000001;\n        }\n        var offsetShape = null;\n        if (offset != null) {\n            offsetShape = offset.shape;\n            inputs.push(offset);\n        }\n        var scaleShape = null;\n        if (scale != null) {\n            scaleShape = scale.shape;\n            inputs.push(scale);\n        }\n        var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);\n        return this.compileAndRun(program, inputs);\n    };\n    NDArrayMathGPU.prototype.switchDimInternal = function (a, newDim) {\n        throw new Error('Not yet implemented!');\n    };\n    NDArrayMathGPU.prototype.sumInternal = function (a) {\n        var program = new reducesum_gpu_1.ReduceSumProgram(a.size);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.argMinInternal = function (a) {\n        var program = new argminmax_gpu_1.ArgMinMaxProgram(a.size, 'min');\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.argMaxInternal = function (a) {\n        var program = new argminmax_gpu_1.ArgMinMaxProgram(a.size, 'max');\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.argMaxEqualsInternal = function (x1, x2) {\n        var program = new argmaxequals_gpu_1.ArgMaxEqualsProgram(x1.size, x2.size);\n        return this.compileAndRun(program, [x1, x2]);\n    };\n    NDArrayMathGPU.prototype.topKInternal = function (ndarray, k) {\n        throw new Error('topK GPU not yet implemented!');\n    };\n    NDArrayMathGPU.prototype.minInternal = function (a) {\n        var program = new minmax_gpu_1.MinMaxProgram(a.size, 'min');\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.maxInternal = function (a) {\n        var program = new minmax_gpu_1.MinMaxProgram(a.size, 'max');\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.divideInternal = function (a, b) {\n        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.DIV, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b]);\n    };\n    NDArrayMathGPU.prototype.addInternal = function (a, b) {\n        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ADD, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b]);\n    };\n    NDArrayMathGPU.prototype.subInternal = function (a, b) {\n        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SUB, a.shape, b.shape);\n        return this.compileAndRun(program, [a, b]);\n    };\n    NDArrayMathGPU.prototype.logSumExpInternal = function (a) {\n        var program = new logsumexp_gpu_1.LogSumExpProgram(a.size);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.expInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.EXP);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.logInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.LOG);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.sqrtInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SQRT);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.reluInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.RELU);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.absInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ABS);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.sigmoidInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SIGMOID);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.sinInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SIN);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.cosInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.COS);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.tanInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.TAN);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.asinInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ASIN);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.acosInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ACOS);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.atanInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.ATAN);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.sinhInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.SINH);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.coshInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.COSH);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.tanhInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.TANH);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.stepInternal = function (a) {\n        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unary_op.STEP);\n        return this.compileAndRun(program, [a]);\n    };\n    NDArrayMathGPU.prototype.conv2dInternal = function (x, filter, bias, convInfo) {\n        var program = new conv_gpu_1.Conv2DProgram(convInfo, bias != null);\n        var inputs = bias != null ? [x, filter, bias] : [x, filter];\n        return this.compileAndRun(program, inputs);\n    };\n    NDArrayMathGPU.prototype.conv2dDerInputInternal = function (dy, filter, convInfo) {\n        var program = new conv_backprop_gpu_1.Conv2DDerInputProgram(convInfo);\n        return this.compileAndRun(program, [dy, filter]);\n    };\n    NDArrayMathGPU.prototype.conv2dDerFilterInternal = function (x, dY, convInfo) {\n        var program = new conv_backprop_gpu_1.Conv2DDerWeightsProgram(convInfo);\n        return this.compileAndRun(program, [x, dY]);\n    };\n    NDArrayMathGPU.prototype.conv2dDerBiasInternal = function (dY) {\n        var program = new conv_backprop_gpu_1.Conv2DDerBiasProgram(dY.shape);\n        return this.compileAndRun(program, [dY]);\n    };\n    NDArrayMathGPU.prototype.maxPoolInternal = function (x, convInfo) {\n        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'max', false);\n        return this.compileAndRun(program, [x]);\n    };\n    NDArrayMathGPU.prototype.minPoolInternal = function (x, convInfo) {\n        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'min', false);\n        return this.compileAndRun(program, [x]);\n    };\n    NDArrayMathGPU.prototype.avgPoolInternal = function (x, convInfo) {\n        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'avg', false);\n        return this.compileAndRun(program, [x]);\n    };\n    NDArrayMathGPU.prototype.maxPoolBackpropInternal = function (dy, x, convInfo) {\n        var getPositions = true;\n        var maxPoolPositionsProgram = new pool_gpu_1.Pool2DProgram(convInfo, 'max', getPositions);\n        var maxPoolPositions = this.compileAndRun(maxPoolPositionsProgram, [x]);\n        var maxPoolBackPropProgram = new max_pool_backprop_gpu_1.MaxPool2DBackpropProgram(convInfo);\n        var result = this.compileAndRun(maxPoolBackPropProgram, [dy, maxPoolPositions]);\n        maxPoolPositions.dispose();\n        return result;\n    };\n    NDArrayMathGPU.prototype.resizeBilinear3DInternal = function (x, newShape2D, alignCorners) {\n        var program = new resize_bilinear_gpu_1.ResizeBilinear3DProgram(x.shape, newShape2D, alignCorners);\n        return this.compileAndRun(program, [x]);\n    };\n    NDArrayMathGPU.prototype.multinomialInternal = function (probs, numSamples, seed) {\n        var program = new multinomial_gpu_1.MultinomialProgram(probs.size, numSamples);\n        var customSetup = program.getCustomSetupFunc(seed);\n        return this.compileAndRun(program, [probs], null, customSetup);\n    };\n    NDArrayMathGPU.prototype.oneHotInternal = function (indices, depth, onValue, offValue) {\n        var program = new onehot_gpu_1.OneHotProgram(indices.size, depth, onValue, offValue);\n        return this.compileAndRun(program, [indices]);\n    };\n    NDArrayMathGPU.prototype.getAndSaveBinary = function (key, getBinary) {\n        if (!(key in this.binaryCache)) {\n            this.binaryCache[key] = getBinary();\n        }\n        return this.binaryCache[key];\n    };\n    NDArrayMathGPU.prototype.getTextureManager = function () {\n        return this.textureManager;\n    };\n    NDArrayMathGPU.prototype.dispose = function () {\n        for (var key in this.binaryCache) {\n            this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);\n        }\n        this.textureManager.dispose();\n        if (this.gpgpuCreatedLocally) {\n            this.gpgpu.dispose();\n        }\n    };\n    return NDArrayMathGPU;\n}(math_1.NDArrayMath));\nexports.NDArrayMathGPU = NDArrayMathGPU;\n//# sourceMappingURL=math_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvbWF0aF9ncHUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvbWF0aF9ncHUuanM/YTFlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1hdGhfMSA9IHJlcXVpcmUoXCIuL21hdGhcIik7XG52YXIgbmRhcnJheSA9IHJlcXVpcmUoXCIuL25kYXJyYXlcIik7XG52YXIgbmRhcnJheV8xID0gcmVxdWlyZShcIi4vbmRhcnJheVwiKTtcbnZhciBhZGRzY2FsZWRtYXRfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9hZGRzY2FsZWRtYXRfZ3B1XCIpO1xudmFyIGFyZ21heGVxdWFsc19ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2FyZ21heGVxdWFsc19ncHVcIik7XG52YXIgYXJnbWlubWF4X2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvYXJnbWlubWF4X2dwdVwiKTtcbnZhciBiYXRjaG5vcm1fZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9iYXRjaG5vcm1fZ3B1XCIpO1xudmFyIGJpbmFyeW9wX2dwdSA9IHJlcXVpcmUoXCIuL3dlYmdsL2JpbmFyeW9wX2dwdVwiKTtcbnZhciBiaW5hcnlvcF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2JpbmFyeW9wX2dwdVwiKTtcbnZhciBjb25jYXRfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jb25jYXRfZ3B1XCIpO1xudmFyIGNvbnZfYmFja3Byb3BfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jb252X2JhY2twcm9wX2dwdVwiKTtcbnZhciBjb252X2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvY29udl9ncHVcIik7XG52YXIgY29weV9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2NvcHlfZ3B1XCIpO1xudmFyIGdwZ3B1X2NvbnRleHRfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2dwZ3B1X2NvbnRleHRcIik7XG52YXIgZ3BncHVfbWF0aCA9IHJlcXVpcmUoXCIuL3dlYmdsL2dwZ3B1X21hdGhcIik7XG52YXIgZ3BncHVfdXRpbCA9IHJlcXVpcmUoXCIuL3dlYmdsL2dwZ3B1X3V0aWxcIik7XG52YXIgbG9nc3VtZXhwX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvbG9nc3VtZXhwX2dwdVwiKTtcbnZhciBtYXhfcG9vbF9iYWNrcHJvcF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL21heF9wb29sX2JhY2twcm9wX2dwdVwiKTtcbnZhciBtaW5tYXhfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9taW5tYXhfZ3B1XCIpO1xudmFyIG11bG1hdF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL211bG1hdF9ncHVcIik7XG52YXIgbXVsdGlub21pYWxfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9tdWx0aW5vbWlhbF9ncHVcIik7XG52YXIgb25laG90X2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvb25laG90X2dwdVwiKTtcbnZhciBwb29sX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvcG9vbF9ncHVcIik7XG52YXIgcmVkdWNlc3VtX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvcmVkdWNlc3VtX2dwdVwiKTtcbnZhciByZXNpemVfYmlsaW5lYXJfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9yZXNpemVfYmlsaW5lYXJfZ3B1XCIpO1xudmFyIHNsaWNlX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvc2xpY2VfZ3B1XCIpO1xudmFyIHRleHR1cmVfbWFuYWdlcl8xID0gcmVxdWlyZShcIi4vd2ViZ2wvdGV4dHVyZV9tYW5hZ2VyXCIpO1xudmFyIHVuYXJ5X29wID0gcmVxdWlyZShcIi4vd2ViZ2wvdW5hcnlvcF9ncHVcIik7XG52YXIgdW5hcnlvcF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3VuYXJ5b3BfZ3B1XCIpO1xudmFyIHdlYmdsX3V0aWwgPSByZXF1aXJlKFwiLi93ZWJnbC93ZWJnbF91dGlsXCIpO1xudmFyIE5EQXJyYXlNYXRoR1BVID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTkRBcnJheU1hdGhHUFUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTkRBcnJheU1hdGhHUFUoZ3BncHUsIHNhZmVNb2RlKSB7XG4gICAgICAgIGlmIChzYWZlTW9kZSA9PT0gdm9pZCAwKSB7IHNhZmVNb2RlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2FmZU1vZGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJpbmFyeUNhY2hlID0ge307XG4gICAgICAgIGlmIChncGdwdSA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZ2wgPSBncGdwdV91dGlsLmNyZWF0ZVdlYkdMQ29udGV4dCgpO1xuICAgICAgICAgICAgX3RoaXMuZ3BncHUgPSBuZXcgZ3BncHVfY29udGV4dF8xLkdQR1BVQ29udGV4dChnbCk7XG4gICAgICAgICAgICBfdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmdwZ3B1ID0gZ3BncHU7XG4gICAgICAgICAgICBfdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMudGV4dHVyZU1hbmFnZXIgPSBuZXcgdGV4dHVyZV9tYW5hZ2VyXzEuVGV4dHVyZU1hbmFnZXIoX3RoaXMuZ3BncHUpO1xuICAgICAgICBuZGFycmF5LmluaXRpYWxpemVHUFUoX3RoaXMuZ3BncHUsIF90aGlzLnRleHR1cmVNYW5hZ2VyKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuZ2V0R1BHUFVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncGdwdTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jbG9uZUludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHRleFNoYXBlID0gYS5nZXRUZXh0dXJlU2hhcGVSQygpO1xuICAgICAgICB2YXIgc291cmNlID0gYS5hczJEKHRleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheSh0ZXhTaGFwZSk7XG4gICAgICAgIHRoaXMuY29weTJEKHNvdXJjZSwgWzAsIDBdLCB0ZXhTaGFwZSwgb3V0cHV0LCBbMCwgMF0sIHRleFNoYXBlKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dC5yZXNoYXBlKGEuc2hhcGUpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnNsaWNlMURJbnRlcm5hbCA9IGZ1bmN0aW9uIChpbnB1dCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgc2xpY2VfZ3B1XzEuU2xpY2VQcm9ncmFtKFtzaXplXSk7XG4gICAgICAgIHZhciBjdXN0b21TZXR1cCA9IHByb2dyYW0uZ2V0Q3VzdG9tU2V0dXBGdW5jKFtiZWdpbl0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtpbnB1dF0sIG51bGwsIGN1c3RvbVNldHVwKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zbGljZTJESW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHNsaWNlX2dwdV8xLlNsaWNlUHJvZ3JhbShzaXplKTtcbiAgICAgICAgdmFyIGN1c3RvbVNldHVwID0gcHJvZ3JhbS5nZXRDdXN0b21TZXR1cEZ1bmMoYmVnaW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtpbnB1dF0sIG51bGwsIGN1c3RvbVNldHVwKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zbGljZTNESW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHNsaWNlX2dwdV8xLlNsaWNlUHJvZ3JhbShzaXplKTtcbiAgICAgICAgdmFyIGN1c3RvbVNldHVwID0gcHJvZ3JhbS5nZXRDdXN0b21TZXR1cEZ1bmMoYmVnaW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtpbnB1dF0sIG51bGwsIGN1c3RvbVNldHVwKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zbGljZTRESW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHNsaWNlX2dwdV8xLlNsaWNlUHJvZ3JhbShzaXplKTtcbiAgICAgICAgdmFyIGN1c3RvbVNldHVwID0gcHJvZ3JhbS5nZXRDdXN0b21TZXR1cEZ1bmMoYmVnaW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtpbnB1dF0sIG51bGwsIGN1c3RvbVNldHVwKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jb3B5MkRJbnRlcm5hbCA9IGZ1bmN0aW9uIChzb3VyY2UsIHNvdXJjZUJlZ2luUm93Q29sLCBzb3VyY2VTaXplUm93Q29sLCBkZXN0LCBkZXN0QmVnaW5Sb3dDb2wsIGRlc3RTaXplUm93Q29sKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvcHlfZ3B1XzEuQ29weTJEUHJvZ3JhbShzb3VyY2VTaXplUm93Q29sWzFdLCBkZXN0U2l6ZVJvd0NvbFsxXSk7XG4gICAgICAgIHZhciBjdXN0b21TZXR1cCA9IHByb2dyYW0uZ2V0Q3VzdG9tU2V0dXBGdW5jKHNvdXJjZUJlZ2luUm93Q29sLCBkZXN0QmVnaW5Sb3dDb2wsIGRlc3RTaXplUm93Q29sKTtcbiAgICAgICAgdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtzb3VyY2VdLCBkZXN0LCBjdXN0b21TZXR1cCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29uY2F0MURJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbmNhdF9ncHVfMS5Db25jYXRQcm9ncmFtKGEuc2hhcGUsIGIuc2hhcGUsIDApO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29uY2F0MkRJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiLCBheGlzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbmNhdF9ncHVfMS5Db25jYXRQcm9ncmFtKGEuc2hhcGUsIGIuc2hhcGUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29uY2F0M0RJbnRlcm5hbCA9IGZ1bmN0aW9uICh4MSwgeDIsIGF4aXMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29uY2F0X2dwdV8xLkNvbmNhdFByb2dyYW0oeDEuc2hhcGUsIHgyLnNoYXBlLCBheGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeDEsIHgyXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29uY2F0NERJbnRlcm5hbCA9IGZ1bmN0aW9uICh4MSwgeDIsIGF4aXMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29uY2F0X2dwdV8xLkNvbmNhdFByb2dyYW0oeDEuc2hhcGUsIHgyLnNoYXBlLCBheGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeDEsIHgyXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc2NhbGVkQXJyYXlBZGRJbnRlcm5hbCA9IGZ1bmN0aW9uIChjMSwgYSwgYzIsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYWRkc2NhbGVkbWF0X2dwdV8xLkFkZFNjYWxlZE1hdFByb2dyYW0oYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGIsIGMxLCBjMl0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLm5lZ0ludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5ORUcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubWFrZU91dHB1dEFycmF5ID0gZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlU2hhcGVSQyA9IHdlYmdsX3V0aWwuZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZSh0aGlzLmdwZ3B1LmdsLCBzaGFwZSk7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZSh0ZXh0dXJlU2hhcGVSQyk7XG4gICAgICAgIHJldHVybiBuZGFycmF5XzEuTkRBcnJheS5tYWtlKHNoYXBlLCB7IHRleHR1cmU6IHRleHR1cmUsIHRleHR1cmVTaGFwZVJDOiB0ZXh0dXJlU2hhcGVSQyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jb21waWxlQW5kUnVuID0gZnVuY3Rpb24gKHByb2dyYW0sIGlucHV0cywgb3V0cHV0LCBjdXN0b21TZXR1cCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3V0cHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSBncGdwdV9tYXRoLm1ha2VTaGFkZXJLZXkocHJvZ3JhbSwgaW5wdXRzLCBvdXRwdXQpO1xuICAgICAgICB2YXIgYmluYXJ5ID0gdGhpcy5nZXRBbmRTYXZlQmluYXJ5KGtleSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdwZ3B1X21hdGguY29tcGlsZVByb2dyYW0oX3RoaXMuZ3BncHUsIHByb2dyYW0sIGlucHV0cywgb3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdwZ3B1X21hdGgucnVuUHJvZ3JhbShiaW5hcnksIGlucHV0cywgb3V0cHV0LCBjdXN0b21TZXR1cCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubWF0TXVsSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYiwgYU9yaWVudGF0aW9uLCBiT3JpZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgbXVsbWF0X2dwdV8xLk1hdE11bFByb2dyYW0oYS5zaGFwZSwgYi5zaGFwZSwgYU9yaWVudGF0aW9uLCBiT3JpZW50YXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubXVsdGlwbHlJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuTVVMLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbjNESW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICB2YXIgaW5wdXRzID0gW3gsIG1lYW4sIHZhcmlhbmNlXTtcbiAgICAgICAgaWYgKHZhcmlhbmNlRXBzaWxvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXJpYW5jZUVwc2lsb24gPSAwLjAwMDAwMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2Zmc2V0U2hhcGUgPSBudWxsO1xuICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9mZnNldFNoYXBlID0gb2Zmc2V0LnNoYXBlO1xuICAgICAgICAgICAgaW5wdXRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NhbGVTaGFwZSA9IG51bGw7XG4gICAgICAgIGlmIChzY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzY2FsZVNoYXBlID0gc2NhbGUuc2hhcGU7XG4gICAgICAgICAgICBpbnB1dHMucHVzaChzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmF0Y2hub3JtX2dwdV8xLkJhdGNoTm9ybVByb2dyYW0oeC5zaGFwZSwgbWVhbi5zaGFwZSwgdmFyaWFuY2Uuc2hhcGUsIG9mZnNldFNoYXBlLCBzY2FsZVNoYXBlLCB2YXJpYW5jZUVwc2lsb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIGlucHV0cyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc3dpdGNoRGltSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgbmV3RGltKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHlldCBpbXBsZW1lbnRlZCEnKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zdW1JbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHJlZHVjZXN1bV9ncHVfMS5SZWR1Y2VTdW1Qcm9ncmFtKGEuc2l6ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5hcmdNaW5JbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGFyZ21pbm1heF9ncHVfMS5BcmdNaW5NYXhQcm9ncmFtKGEuc2l6ZSwgJ21pbicpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuYXJnTWF4SW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBhcmdtaW5tYXhfZ3B1XzEuQXJnTWluTWF4UHJvZ3JhbShhLnNpemUsICdtYXgnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmFyZ01heEVxdWFsc0ludGVybmFsID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBhcmdtYXhlcXVhbHNfZ3B1XzEuQXJnTWF4RXF1YWxzUHJvZ3JhbSh4MS5zaXplLCB4Mi5zaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeDEsIHgyXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUudG9wS0ludGVybmFsID0gZnVuY3Rpb24gKG5kYXJyYXksIGspIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b3BLIEdQVSBub3QgeWV0IGltcGxlbWVudGVkIScpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLm1pbkludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgbWlubWF4X2dwdV8xLk1pbk1heFByb2dyYW0oYS5zaXplLCAnbWluJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5tYXhJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IG1pbm1heF9ncHVfMS5NaW5NYXhQcm9ncmFtKGEuc2l6ZSwgJ21heCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuZGl2aWRlSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkRJViwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5hZGRJbnRlcm5hbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuQURELCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnN1YkludGVybmFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5TVUIsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubG9nU3VtRXhwSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBsb2dzdW1leHBfZ3B1XzEuTG9nU3VtRXhwUHJvZ3JhbShhLnNpemUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuZXhwSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLkVYUCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5sb2dJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuTE9HKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnNxcnRJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuU1FSVCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5yZWx1SW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLlJFTFUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuYWJzSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLkFCUyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5zaWdtb2lkSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLlNJR01PSUQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc2luSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLlNJTik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5jb3NJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuQ09TKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLnRhbkludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5UQU4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuYXNpbkludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5BU0lOKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmFjb3NJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuQUNPUyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5hdGFuSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLkFUQU4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc2luaEludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5TSU5IKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNvc2hJbnRlcm5hbCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgdW5hcnlfb3AuQ09TSCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS50YW5oSW50ZXJuYWwgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIHVuYXJ5X29wLlRBTkgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuc3RlcEludGVybmFsID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCB1bmFyeV9vcC5TVEVQKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNvbnYyZEludGVybmFsID0gZnVuY3Rpb24gKHgsIGZpbHRlciwgYmlhcywgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29udl9ncHVfMS5Db252MkRQcm9ncmFtKGNvbnZJbmZvLCBiaWFzICE9IG51bGwpO1xuICAgICAgICB2YXIgaW5wdXRzID0gYmlhcyAhPSBudWxsID8gW3gsIGZpbHRlciwgYmlhc10gOiBbeCwgZmlsdGVyXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBpbnB1dHMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNvbnYyZERlcklucHV0SW50ZXJuYWwgPSBmdW5jdGlvbiAoZHksIGZpbHRlciwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29udl9iYWNrcHJvcF9ncHVfMS5Db252MkREZXJJbnB1dFByb2dyYW0oY29udkluZm8pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtkeSwgZmlsdGVyXSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUuY29udjJkRGVyRmlsdGVySW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgZFksIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbnZfYmFja3Byb3BfZ3B1XzEuQ29udjJERGVyV2VpZ2h0c1Byb2dyYW0oY29udkluZm8pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4LCBkWV0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmNvbnYyZERlckJpYXNJbnRlcm5hbCA9IGZ1bmN0aW9uIChkWSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb252X2JhY2twcm9wX2dwdV8xLkNvbnYyRERlckJpYXNQcm9ncmFtKGRZLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbZFldKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5tYXhQb29sSW50ZXJuYWwgPSBmdW5jdGlvbiAoeCwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgcG9vbF9ncHVfMS5Qb29sMkRQcm9ncmFtKGNvbnZJbmZvLCAnbWF4JywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUubWluUG9vbEludGVybmFsID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHBvb2xfZ3B1XzEuUG9vbDJEUHJvZ3JhbShjb252SW5mbywgJ21pbicsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmF2Z1Bvb2xJbnRlcm5hbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBwb29sX2dwdV8xLlBvb2wyRFByb2dyYW0oY29udkluZm8sICdhdmcnLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5tYXhQb29sQmFja3Byb3BJbnRlcm5hbCA9IGZ1bmN0aW9uIChkeSwgeCwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIGdldFBvc2l0aW9ucyA9IHRydWU7XG4gICAgICAgIHZhciBtYXhQb29sUG9zaXRpb25zUHJvZ3JhbSA9IG5ldyBwb29sX2dwdV8xLlBvb2wyRFByb2dyYW0oY29udkluZm8sICdtYXgnLCBnZXRQb3NpdGlvbnMpO1xuICAgICAgICB2YXIgbWF4UG9vbFBvc2l0aW9ucyA9IHRoaXMuY29tcGlsZUFuZFJ1bihtYXhQb29sUG9zaXRpb25zUHJvZ3JhbSwgW3hdKTtcbiAgICAgICAgdmFyIG1heFBvb2xCYWNrUHJvcFByb2dyYW0gPSBuZXcgbWF4X3Bvb2xfYmFja3Byb3BfZ3B1XzEuTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtKGNvbnZJbmZvKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY29tcGlsZUFuZFJ1bihtYXhQb29sQmFja1Byb3BQcm9ncmFtLCBbZHksIG1heFBvb2xQb3NpdGlvbnNdKTtcbiAgICAgICAgbWF4UG9vbFBvc2l0aW9ucy5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUucmVzaXplQmlsaW5lYXIzREludGVybmFsID0gZnVuY3Rpb24gKHgsIG5ld1NoYXBlMkQsIGFsaWduQ29ybmVycykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyByZXNpemVfYmlsaW5lYXJfZ3B1XzEuUmVzaXplQmlsaW5lYXIzRFByb2dyYW0oeC5zaGFwZSwgbmV3U2hhcGUyRCwgYWxpZ25Db3JuZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLm11bHRpbm9taWFsSW50ZXJuYWwgPSBmdW5jdGlvbiAocHJvYnMsIG51bVNhbXBsZXMsIHNlZWQpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgbXVsdGlub21pYWxfZ3B1XzEuTXVsdGlub21pYWxQcm9ncmFtKHByb2JzLnNpemUsIG51bVNhbXBsZXMpO1xuICAgICAgICB2YXIgY3VzdG9tU2V0dXAgPSBwcm9ncmFtLmdldEN1c3RvbVNldHVwRnVuYyhzZWVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbcHJvYnNdLCBudWxsLCBjdXN0b21TZXR1cCk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aEdQVS5wcm90b3R5cGUub25lSG90SW50ZXJuYWwgPSBmdW5jdGlvbiAoaW5kaWNlcywgZGVwdGgsIG9uVmFsdWUsIG9mZlZhbHVlKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IG9uZWhvdF9ncHVfMS5PbmVIb3RQcm9ncmFtKGluZGljZXMuc2l6ZSwgZGVwdGgsIG9uVmFsdWUsIG9mZlZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbaW5kaWNlc10pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmdldEFuZFNhdmVCaW5hcnkgPSBmdW5jdGlvbiAoa2V5LCBnZXRCaW5hcnkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuYmluYXJ5Q2FjaGUpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeUNhY2hlW2tleV0gPSBnZXRCaW5hcnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlDYWNoZVtrZXldO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGhHUFUucHJvdG90eXBlLmdldFRleHR1cmVNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlTWFuYWdlcjtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoR1BVLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5iaW5hcnlDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5ncGdwdS5kZWxldGVQcm9ncmFtKHRoaXMuYmluYXJ5Q2FjaGVba2V5XS53ZWJHTFByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5KSB7XG4gICAgICAgICAgICB0aGlzLmdwZ3B1LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5EQXJyYXlNYXRoR1BVO1xufShtYXRoXzEuTkRBcnJheU1hdGgpKTtcbmV4cG9ydHMuTkRBcnJheU1hdGhHUFUgPSBOREFycmF5TWF0aEdQVTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGhfZ3B1LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/math_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/ndarray.js":
/*!*********************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/ndarray.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar environment_1 = __webpack_require__(/*! ../environment */ \"./node_modules/deeplearn/dist/src/environment.js\");\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar webgl_util = __webpack_require__(/*! ./webgl/webgl_util */ \"./node_modules/deeplearn/dist/src/math/webgl/webgl_util.js\");\nexports.GPGPU = null;\nexports.TEXTURE_MANAGER = null;\nfunction initializeGPU(gpgpu, textureManager) {\n    exports.GPGPU = gpgpu;\n    exports.TEXTURE_MANAGER = textureManager;\n}\nexports.initializeGPU = initializeGPU;\nfunction throwIfGPUNotInitialized() {\n    if (exports.GPGPU == null || exports.TEXTURE_MANAGER == null) {\n        throw new Error('GPU not intialized.');\n    }\n}\nvar NDArray = (function () {\n    function NDArray(shape, data) {\n        util.assert(data.values != null || data.texture != null, 'Either `values` or `texture` must be defined');\n        util.assert(data.texture == null || (data.textureShapeRC != null), '`textureShape` must be defined when `texture` is defined');\n        this.size = util.sizeFromShape(shape);\n        if (data.values != null) {\n            util.assert(this.size === data.values.length, 'Constructing ndarray of shape (' + this.size + ') should match the' +\n                ' length of values (' + data.values.length + ')');\n        }\n        this.shape = shape;\n        this.data = data;\n        var dim = this.shape.length;\n        if (dim < 2) {\n            this.strides = [];\n        }\n        else {\n            this.strides = new Array(dim - 1);\n            this.strides[dim - 2] = this.shape[dim - 1];\n            for (var i = dim - 3; i >= 0; --i) {\n                this.strides[i] = this.strides[i + 1] * this.shape[i + 1];\n            }\n        }\n    }\n    NDArray.zeros = function (shape) {\n        var values = new Float32Array(util.sizeFromShape(shape));\n        return NDArray.make(shape, { values: values });\n    };\n    NDArray.zerosLike = function (another) {\n        return NDArray.zeros(another.shape);\n    };\n    NDArray.like = function (another) {\n        var values = another.getValues();\n        return NDArray.make(another.shape, { values: new Float32Array(values) });\n    };\n    NDArray.make = function (shape, data) {\n        switch (shape.length) {\n            case 0:\n                return new Scalar(data);\n            case 1:\n                return new Array1D(data);\n            case 2:\n                return new Array2D(shape, data);\n            case 3:\n                return new Array3D(shape, data);\n            case 4:\n                return new Array4D(shape, data);\n            default:\n                return new NDArray(shape, data);\n        }\n    };\n    NDArray.prototype.reshape = function (newShape) {\n        newShape = util.inferFromImplicitShape(newShape, this.size);\n        if (util.arraysEqual(this.shape, newShape)) {\n            return this;\n        }\n        util.assert(this.size === util.sizeFromShape(newShape), 'new shape and old shape must have the same number of elements.');\n        return NDArray.make(newShape, this.data);\n    };\n    NDArray.prototype.asScalar = function () {\n        util.assert(this.size === 1, 'The array must have only 1 element.');\n        return this.reshape([]);\n    };\n    NDArray.prototype.as1D = function () {\n        return this.reshape([this.size]);\n    };\n    NDArray.prototype.as2D = function (rows, columns) {\n        return this.reshape([rows, columns]);\n    };\n    NDArray.prototype.as3D = function (rows, columns, depth) {\n        return this.reshape([rows, columns, depth]);\n    };\n    NDArray.prototype.as4D = function (rows, columns, depth, depth2) {\n        return this.reshape([rows, columns, depth, depth2]);\n    };\n    Object.defineProperty(NDArray.prototype, \"rank\", {\n        get: function () {\n            return this.shape.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    NDArray.prototype.get = function () {\n        var locs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            locs[_i] = arguments[_i];\n        }\n        var index = locs[locs.length - 1];\n        for (var i = 0; i < locs.length - 1; ++i) {\n            index += this.strides[i] * locs[i];\n        }\n        return this.getValues()[index];\n    };\n    NDArray.prototype.add = function (value) {\n        var locs = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            locs[_i - 1] = arguments[_i];\n        }\n        this.set.apply(this, [this.get.apply(this, locs) + value].concat(locs));\n    };\n    NDArray.prototype.set = function (value) {\n        var locs = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            locs[_i - 1] = arguments[_i];\n        }\n        var index = locs[locs.length - 1];\n        for (var i = 0; i < locs.length - 1; ++i) {\n            index += this.strides[i] * locs[i];\n        }\n        this.getValues()[index] = value;\n    };\n    NDArray.prototype.locToIndex = function (locs) {\n        var index = locs[locs.length - 1];\n        for (var i = 0; i < locs.length - 1; ++i) {\n            index += this.strides[i] * locs[i];\n        }\n        return index;\n    };\n    NDArray.prototype.indexToLoc = function (index) {\n        var locs = new Array(this.shape.length);\n        for (var i = 0; i < locs.length - 1; ++i) {\n            locs[i] = Math.floor(index / this.strides[i]);\n            index -= locs[i] * this.strides[i];\n        }\n        locs[locs.length - 1] = index;\n        return locs;\n    };\n    NDArray.prototype.fill = function (value) {\n        this.getValues().fill(value);\n    };\n    NDArray.prototype.getData = function () {\n        return this.data;\n    };\n    NDArray.prototype.getValues = function () {\n        if (this.data.values == null) {\n            throwIfGPUNotInitialized();\n            this.data.values = exports.GPGPU.downloadMatrixFromTexture(this.data.texture, this.data.textureShapeRC[0], this.data.textureShapeRC[1]);\n            this.disposeTexture();\n        }\n        return this.data.values;\n    };\n    NDArray.prototype.getValuesAsync = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            if (_this.data.values != null) {\n                resolve(_this.data.values);\n                return;\n            }\n            if (!environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED')) {\n                resolve(_this.getValues());\n                return;\n            }\n            var queryFn = function () { };\n            exports.GPGPU.runQuery(queryFn).then(function () {\n                resolve(_this.getValues());\n            });\n        });\n    };\n    NDArray.prototype.uploadToGPU = function (preferredTexShape) {\n        throwIfGPUNotInitialized();\n        this.data.textureShapeRC = webgl_util.getTextureShapeFromLogicalShape(exports.GPGPU.gl, this.shape, preferredTexShape);\n        this.data.texture =\n            exports.TEXTURE_MANAGER.acquireTexture(this.data.textureShapeRC);\n        exports.GPGPU.uploadMatrixToTexture(this.data.texture, this.data.textureShapeRC[0], this.data.textureShapeRC[1], this.data.values);\n        this.data.values = null;\n    };\n    NDArray.prototype.getTexture = function (preferredShapeRC) {\n        if (this.data.texture == null) {\n            this.uploadToGPU(preferredShapeRC);\n        }\n        return this.data.texture;\n    };\n    NDArray.prototype.getTextureShapeRC = function (preferredShapeRC) {\n        if (this.data.textureShapeRC == null) {\n            this.uploadToGPU(preferredShapeRC);\n        }\n        return this.data.textureShapeRC;\n    };\n    NDArray.prototype.dispose = function () {\n        this.data.values = null;\n        this.shape = null;\n        if (this.data.texture != null) {\n            this.disposeTexture();\n        }\n    };\n    NDArray.prototype.disposeTexture = function () {\n        throwIfGPUNotInitialized();\n        exports.TEXTURE_MANAGER.releaseTexture(this.data.texture, this.data.textureShapeRC);\n        this.data.texture = null;\n        this.data.textureShapeRC = null;\n    };\n    NDArray.prototype.inGPU = function () {\n        return this.data.texture != null;\n    };\n    NDArray.prototype.equals = function (t) {\n        return util.arraysEqual(this.shape, t.shape) &&\n            util.arraysEqual(this.getValues(), t.getValues());\n    };\n    NDArray.rand = function (shape, randFunction) {\n        var size = util.sizeFromShape(shape);\n        var values = new Float32Array(size);\n        for (var i = 0; i < size; i++) {\n            values[i] = randFunction();\n        }\n        return NDArray.make(shape, { values: values });\n    };\n    NDArray.randNormal = function (shape, mean, stdDev) {\n        if (mean === void 0) { mean = 0; }\n        if (stdDev === void 0) { stdDev = 1; }\n        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });\n    };\n    NDArray.randTruncatedNormal = function (shape, mean, stdDev) {\n        if (mean === void 0) { mean = 0; }\n        if (stdDev === void 0) { stdDev = 1; }\n        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });\n    };\n    NDArray.randUniform = function (shape, a, b) {\n        return NDArray.rand(shape, function () { return util.randUniform(a, b); });\n    };\n    return NDArray;\n}());\nexports.NDArray = NDArray;\nvar Scalar = (function (_super) {\n    __extends(Scalar, _super);\n    function Scalar(data) {\n        var _this = this;\n        if (data.texture != null) {\n            data.textureShapeRC = [1, 1];\n        }\n        _this = _super.call(this, [], data) || this;\n        return _this;\n    }\n    Scalar.new = function (value) {\n        return new Scalar({ values: new Float32Array([value]) });\n    };\n    Scalar.prototype.get = function () {\n        return this.getValues()[0];\n    };\n    Scalar.prototype.set = function (value) {\n        this.getValues()[0] = value;\n    };\n    Scalar.prototype.add = function (value) {\n        this.getValues()[0] += value;\n    };\n    Scalar.ZERO = Scalar.new(0);\n    Scalar.ONE = Scalar.new(1);\n    Scalar.TWO = Scalar.new(2);\n    Scalar.NEG_ONE = Scalar.new(-1);\n    return Scalar;\n}(NDArray));\nexports.Scalar = Scalar;\nvar Array1D = (function (_super) {\n    __extends(Array1D, _super);\n    function Array1D(data) {\n        var _this = this;\n        var shape = (data.values != null) ?\n            [data.values.length] :\n            [util.sizeFromShape(data.textureShapeRC)];\n        _this = _super.call(this, shape, data) || this;\n        return _this;\n    }\n    Array1D.new = function (values) {\n        if (!(values instanceof Float32Array)) {\n            var inferredShape = util.inferShape(values);\n            util.assert(inferredShape.length === 1, \"Error constructing Array1D. Shape of values \" + inferredShape + \" is \" +\n                \"not 1 dimensional.\");\n        }\n        return new Array1D({ values: toTypedArray(values) });\n    };\n    Array1D.prototype.get = function (i) {\n        return this.getValues()[i];\n    };\n    Array1D.prototype.set = function (value, i) {\n        this.getValues()[i] = value;\n    };\n    Array1D.prototype.add = function (value, i) {\n        this.getValues()[i] += value;\n    };\n    Array1D.prototype.locToIndex = function (loc) {\n        return loc[0];\n    };\n    Array1D.prototype.indexToLoc = function (index) {\n        return [index];\n    };\n    Array1D.zeros = function (shape) {\n        return NDArray.zeros(shape);\n    };\n    Array1D.randNormal = function (shape, mean, stdDev) {\n        if (mean === void 0) { mean = 0; }\n        if (stdDev === void 0) { stdDev = 1; }\n        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });\n    };\n    Array1D.randTruncatedNormal = function (shape, mean, stdDev) {\n        if (mean === void 0) { mean = 0; }\n        if (stdDev === void 0) { stdDev = 1; }\n        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });\n    };\n    Array1D.randUniform = function (shape, a, b) {\n        return NDArray.rand(shape, function () { return util.randUniform(a, b); });\n    };\n    Array1D.make = function (shape, data) {\n        return new Array1D(data);\n    };\n    return Array1D;\n}(NDArray));\nexports.Array1D = Array1D;\nvar Array2D = (function (_super) {\n    __extends(Array2D, _super);\n    function Array2D(shape, data) {\n        var _this = this;\n        util.assert(shape.length === 2, 'Shape should be of length 2');\n        _this = _super.call(this, shape, data) || this;\n        _this.stride0 = _this.strides[0];\n        return _this;\n    }\n    Array2D.new = function (shape, values) {\n        if (!(values instanceof Float32Array)) {\n            var inferredShape = util.inferShape(values);\n            if (inferredShape.length > 1) {\n                util.assertShapesMatch(shape, inferredShape, \"Error when constructing Array2D. Shape of values \" +\n                    (inferredShape + \" does not match the provided shape \") +\n                    (shape + \". \"));\n            }\n        }\n        return new Array2D(shape, { values: toTypedArray(values) });\n    };\n    Array2D.prototype.get = function (i, j) {\n        return this.getValues()[this.stride0 * i + j];\n    };\n    Array2D.prototype.set = function (value, i, j) {\n        this.getValues()[this.stride0 * i + j] = value;\n    };\n    Array2D.prototype.add = function (value, i, j) {\n        this.getValues()[this.stride0 * i + j] += value;\n    };\n    Array2D.prototype.locToIndex = function (locs) {\n        return this.stride0 * locs[0] + locs[1];\n    };\n    Array2D.prototype.indexToLoc = function (index) {\n        return [Math.floor(index / this.stride0), index % this.stride0];\n    };\n    Array2D.zeros = function (shape) {\n        return NDArray.zeros(shape);\n    };\n    Array2D.randNormal = function (shape, mean, stdDev) {\n        if (mean === void 0) { mean = 0; }\n        if (stdDev === void 0) { stdDev = 1; }\n        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });\n    };\n    Array2D.randTruncatedNormal = function (shape, mean, stdDev) {\n        if (mean === void 0) { mean = 0; }\n        if (stdDev === void 0) { stdDev = 1; }\n        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });\n    };\n    Array2D.randUniform = function (shape, a, b) {\n        return NDArray.rand(shape, function () { return util.randUniform(a, b); });\n    };\n    Array2D.make = function (shape, data) {\n        return new Array2D(shape, data);\n    };\n    return Array2D;\n}(NDArray));\nexports.Array2D = Array2D;\nvar Array3D = (function (_super) {\n    __extends(Array3D, _super);\n    function Array3D(shape, data) {\n        var _this = this;\n        util.assert(shape.length === 3, 'Shape should be of length 3');\n        _this = _super.call(this, shape, data) || this;\n        _this.stride0 = _this.strides[0];\n        _this.stride1 = _this.strides[1];\n        return _this;\n    }\n    Array3D.new = function (shape, values) {\n        if (!(values instanceof Float32Array)) {\n            var inferredShape = util.inferShape(values);\n            if (inferredShape.length > 1) {\n                util.assertShapesMatch(shape, inferredShape, \"Error when constructing Array3D. Shape of values \" +\n                    (inferredShape + \" does not match the provided shape \") +\n                    (shape + \". \"));\n            }\n        }\n        return new Array3D(shape, { values: toTypedArray(values) });\n    };\n    Array3D.prototype.get = function (i, j, k) {\n        return this.getValues()[this.stride0 * i + this.stride1 * j + k];\n    };\n    Array3D.prototype.set = function (value, i, j, k) {\n        this.getValues()[this.stride0 * i + this.stride1 * j + k] = value;\n    };\n    Array3D.prototype.add = function (value, i, j, k) {\n        this.getValues()[this.stride0 * i + this.stride1 * j + k] += value;\n    };\n    Array3D.prototype.locToIndex = function (locs) {\n        return this.stride0 * locs[0] + this.stride1 * locs[1] + locs[2];\n    };\n    Array3D.prototype.indexToLoc = function (index) {\n        var i = Math.floor(index / this.stride0);\n        index -= i * this.stride0;\n        return [i, Math.floor(index / this.stride1), index % this.stride1];\n    };\n    Array3D.zeros = function (shape) {\n        return NDArray.zeros(shape);\n    };\n    Array3D.randNormal = function (shape, mean, stdDev) {\n        if (mean === void 0) { mean = 0; }\n        if (stdDev === void 0) { stdDev = 1; }\n        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });\n    };\n    Array3D.randTruncatedNormal = function (shape, mean, stdDev) {\n        if (mean === void 0) { mean = 0; }\n        if (stdDev === void 0) { stdDev = 1; }\n        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });\n    };\n    Array3D.randUniform = function (shape, a, b) {\n        return NDArray.rand(shape, function () { return util.randUniform(a, b); });\n    };\n    Array3D.make = function (shape, data) {\n        return new Array3D(shape, data);\n    };\n    return Array3D;\n}(NDArray));\nexports.Array3D = Array3D;\nvar Array4D = (function (_super) {\n    __extends(Array4D, _super);\n    function Array4D(shape, data) {\n        var _this = this;\n        util.assert(shape.length === 4, 'Shape should be of length 4');\n        _this = _super.call(this, shape, data) || this;\n        _this.stride0 = _this.strides[0];\n        _this.stride1 = _this.strides[1];\n        _this.stride2 = _this.strides[2];\n        return _this;\n    }\n    Array4D.new = function (shape, values) {\n        if (!(values instanceof Float32Array)) {\n            var inferredShape = util.inferShape(values);\n            if (inferredShape.length > 1) {\n                util.assertShapesMatch(shape, inferredShape, \"Error when constructing Array4D. Shape of values \" +\n                    (inferredShape + \" does not match the provided shape \") +\n                    (shape + \". \"));\n            }\n        }\n        return new Array4D(shape, { values: toTypedArray(values) });\n    };\n    Array4D.prototype.get = function (i, j, k, l) {\n        return this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l];\n    };\n    Array4D.prototype.set = function (value, i, j, k, l) {\n        this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l] = value;\n    };\n    Array4D.prototype.add = function (value, i, j, k, l) {\n        this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l] += value;\n    };\n    Array4D.prototype.locToIndex = function (locs) {\n        return this.stride0 * locs[0] + this.stride1 * locs[1] +\n            this.stride2 * locs[2] + locs[3];\n    };\n    Array4D.prototype.indexToLoc = function (index) {\n        var i = Math.floor(index / this.stride0);\n        index -= i * this.stride0;\n        var j = Math.floor(index / this.stride1);\n        index -= j * this.stride1;\n        return [i, j, Math.floor(index / this.stride2), index % this.stride2];\n    };\n    Array4D.zeros = function (shape) {\n        return NDArray.zeros(shape);\n    };\n    Array4D.randNormal = function (shape, mean, stdDev) {\n        if (mean === void 0) { mean = 0; }\n        if (stdDev === void 0) { stdDev = 1; }\n        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });\n    };\n    Array4D.randTruncatedNormal = function (shape, mean, stdDev) {\n        if (mean === void 0) { mean = 0; }\n        if (stdDev === void 0) { stdDev = 1; }\n        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });\n    };\n    Array4D.randUniform = function (shape, a, b) {\n        return NDArray.rand(shape, function () { return util.randUniform(a, b); });\n    };\n    Array4D.make = function (shape, data) {\n        return new Array4D(shape, data);\n    };\n    return Array4D;\n}(NDArray));\nexports.Array4D = Array4D;\nfunction toTypedArray(a) {\n    return (a instanceof Float32Array) ?\n        a : new Float32Array(util.flatten(a));\n}\n//# sourceMappingURL=ndarray.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvbmRhcnJheS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC9uZGFycmF5LmpzPzI1OGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciB3ZWJnbF91dGlsID0gcmVxdWlyZShcIi4vd2ViZ2wvd2ViZ2xfdXRpbFwiKTtcbmV4cG9ydHMuR1BHUFUgPSBudWxsO1xuZXhwb3J0cy5URVhUVVJFX01BTkFHRVIgPSBudWxsO1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUdQVShncGdwdSwgdGV4dHVyZU1hbmFnZXIpIHtcbiAgICBleHBvcnRzLkdQR1BVID0gZ3BncHU7XG4gICAgZXhwb3J0cy5URVhUVVJFX01BTkFHRVIgPSB0ZXh0dXJlTWFuYWdlcjtcbn1cbmV4cG9ydHMuaW5pdGlhbGl6ZUdQVSA9IGluaXRpYWxpemVHUFU7XG5mdW5jdGlvbiB0aHJvd0lmR1BVTm90SW5pdGlhbGl6ZWQoKSB7XG4gICAgaWYgKGV4cG9ydHMuR1BHUFUgPT0gbnVsbCB8fCBleHBvcnRzLlRFWFRVUkVfTUFOQUdFUiA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR1BVIG5vdCBpbnRpYWxpemVkLicpO1xuICAgIH1cbn1cbnZhciBOREFycmF5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOREFycmF5KHNoYXBlLCBkYXRhKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGRhdGEudmFsdWVzICE9IG51bGwgfHwgZGF0YS50ZXh0dXJlICE9IG51bGwsICdFaXRoZXIgYHZhbHVlc2Agb3IgYHRleHR1cmVgIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgICAgICB1dGlsLmFzc2VydChkYXRhLnRleHR1cmUgPT0gbnVsbCB8fCAoZGF0YS50ZXh0dXJlU2hhcGVSQyAhPSBudWxsKSwgJ2B0ZXh0dXJlU2hhcGVgIG11c3QgYmUgZGVmaW5lZCB3aGVuIGB0ZXh0dXJlYCBpcyBkZWZpbmVkJyk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSk7XG4gICAgICAgIGlmIChkYXRhLnZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh0aGlzLnNpemUgPT09IGRhdGEudmFsdWVzLmxlbmd0aCwgJ0NvbnN0cnVjdGluZyBuZGFycmF5IG9mIHNoYXBlICgnICsgdGhpcy5zaXplICsgJykgc2hvdWxkIG1hdGNoIHRoZScgK1xuICAgICAgICAgICAgICAgICcgbGVuZ3RoIG9mIHZhbHVlcyAoJyArIGRhdGEudmFsdWVzLmxlbmd0aCArICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaGFwZSA9IHNoYXBlO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB2YXIgZGltID0gdGhpcy5zaGFwZS5sZW5ndGg7XG4gICAgICAgIGlmIChkaW0gPCAyKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmlkZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RyaWRlcyA9IG5ldyBBcnJheShkaW0gLSAxKTtcbiAgICAgICAgICAgIHRoaXMuc3RyaWRlc1tkaW0gLSAyXSA9IHRoaXMuc2hhcGVbZGltIC0gMV07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGltIC0gMzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmlkZXNbaV0gPSB0aGlzLnN0cmlkZXNbaSArIDFdICogdGhpcy5zaGFwZVtpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgTkRBcnJheS56ZXJvcyA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpKTtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkubWFrZShzaGFwZSwgeyB2YWx1ZXM6IHZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXkuemVyb3NMaWtlID0gZnVuY3Rpb24gKGFub3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkuemVyb3MoYW5vdGhlci5zaGFwZSk7XG4gICAgfTtcbiAgICBOREFycmF5Lmxpa2UgPSBmdW5jdGlvbiAoYW5vdGhlcikge1xuICAgICAgICB2YXIgdmFsdWVzID0gYW5vdGhlci5nZXRWYWx1ZXMoKTtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkubWFrZShhbm90aGVyLnNoYXBlLCB7IHZhbHVlczogbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMpIH0pO1xuICAgIH07XG4gICAgTkRBcnJheS5tYWtlID0gZnVuY3Rpb24gKHNoYXBlLCBkYXRhKSB7XG4gICAgICAgIHN3aXRjaCAoc2hhcGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXIoZGF0YSk7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheTFEKGRhdGEpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXkyRChzaGFwZSwgZGF0YSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheTNEKHNoYXBlLCBkYXRhKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5NEQoc2hhcGUsIGRhdGEpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5EQXJyYXkoc2hhcGUsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24gKG5ld1NoYXBlKSB7XG4gICAgICAgIG5ld1NoYXBlID0gdXRpbC5pbmZlckZyb21JbXBsaWNpdFNoYXBlKG5ld1NoYXBlLCB0aGlzLnNpemUpO1xuICAgICAgICBpZiAodXRpbC5hcnJheXNFcXVhbCh0aGlzLnNoYXBlLCBuZXdTaGFwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMuc2l6ZSA9PT0gdXRpbC5zaXplRnJvbVNoYXBlKG5ld1NoYXBlKSwgJ25ldyBzaGFwZSBhbmQgb2xkIHNoYXBlIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuJyk7XG4gICAgICAgIHJldHVybiBOREFycmF5Lm1ha2UobmV3U2hhcGUsIHRoaXMuZGF0YSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hc1NjYWxhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy5zaXplID09PSAxLCAnVGhlIGFycmF5IG11c3QgaGF2ZSBvbmx5IDEgZWxlbWVudC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaGFwZShbXSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hczFEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNoYXBlKFt0aGlzLnNpemVdKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmFzMkQgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNoYXBlKFtyb3dzLCBjb2x1bW5zXSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hczNEID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMsIGRlcHRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2hhcGUoW3Jvd3MsIGNvbHVtbnMsIGRlcHRoXSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hczREID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMsIGRlcHRoLCBkZXB0aDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaGFwZShbcm93cywgY29sdW1ucywgZGVwdGgsIGRlcHRoMl0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5EQXJyYXkucHJvdG90eXBlLCBcInJhbmtcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNoYXBlLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9jcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbG9jc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IGxvY3NbbG9jcy5sZW5ndGggLSAxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgaW5kZXggKz0gdGhpcy5zdHJpZGVzW2ldICogbG9jc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoKVtpbmRleF07XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGxvY3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGxvY3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXQuYXBwbHkodGhpcywgW3RoaXMuZ2V0LmFwcGx5KHRoaXMsIGxvY3MpICsgdmFsdWVdLmNvbmNhdChsb2NzKSk7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGxvY3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGxvY3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gbG9jc1tsb2NzLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBpbmRleCArPSB0aGlzLnN0cmlkZXNbaV0gKiBsb2NzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0VmFsdWVzKClbaW5kZXhdID0gdmFsdWU7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5sb2NUb0luZGV4ID0gZnVuY3Rpb24gKGxvY3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbG9jc1tsb2NzLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBpbmRleCArPSB0aGlzLnN0cmlkZXNbaV0gKiBsb2NzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmluZGV4VG9Mb2MgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGxvY3MgPSBuZXcgQXJyYXkodGhpcy5zaGFwZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBsb2NzW2ldID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlc1tpXSk7XG4gICAgICAgICAgICBpbmRleCAtPSBsb2NzW2ldICogdGhpcy5zdHJpZGVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGxvY3NbbG9jcy5sZW5ndGggLSAxXSA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbG9jcztcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKS5maWxsKHZhbHVlKTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEudmFsdWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93SWZHUFVOb3RJbml0aWFsaXplZCgpO1xuICAgICAgICAgICAgdGhpcy5kYXRhLnZhbHVlcyA9IGV4cG9ydHMuR1BHUFUuZG93bmxvYWRNYXRyaXhGcm9tVGV4dHVyZSh0aGlzLmRhdGEudGV4dHVyZSwgdGhpcy5kYXRhLnRleHR1cmVTaGFwZVJDWzBdLCB0aGlzLmRhdGEudGV4dHVyZVNoYXBlUkNbMV0pO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlVGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudmFsdWVzO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZ2V0VmFsdWVzQXN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuZGF0YS52YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMuZGF0YS52YWx1ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fRU5BQkxFRCcpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcy5nZXRWYWx1ZXMoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHF1ZXJ5Rm4gPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICBleHBvcnRzLkdQR1BVLnJ1blF1ZXJ5KHF1ZXJ5Rm4pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMuZ2V0VmFsdWVzKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUudXBsb2FkVG9HUFUgPSBmdW5jdGlvbiAocHJlZmVycmVkVGV4U2hhcGUpIHtcbiAgICAgICAgdGhyb3dJZkdQVU5vdEluaXRpYWxpemVkKCk7XG4gICAgICAgIHRoaXMuZGF0YS50ZXh0dXJlU2hhcGVSQyA9IHdlYmdsX3V0aWwuZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZShleHBvcnRzLkdQR1BVLmdsLCB0aGlzLnNoYXBlLCBwcmVmZXJyZWRUZXhTaGFwZSk7XG4gICAgICAgIHRoaXMuZGF0YS50ZXh0dXJlID1cbiAgICAgICAgICAgIGV4cG9ydHMuVEVYVFVSRV9NQU5BR0VSLmFjcXVpcmVUZXh0dXJlKHRoaXMuZGF0YS50ZXh0dXJlU2hhcGVSQyk7XG4gICAgICAgIGV4cG9ydHMuR1BHUFUudXBsb2FkTWF0cml4VG9UZXh0dXJlKHRoaXMuZGF0YS50ZXh0dXJlLCB0aGlzLmRhdGEudGV4dHVyZVNoYXBlUkNbMF0sIHRoaXMuZGF0YS50ZXh0dXJlU2hhcGVSQ1sxXSwgdGhpcy5kYXRhLnZhbHVlcyk7XG4gICAgICAgIHRoaXMuZGF0YS52YWx1ZXMgPSBudWxsO1xuICAgIH07XG4gICAgTkRBcnJheS5wcm90b3R5cGUuZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uIChwcmVmZXJyZWRTaGFwZVJDKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEudGV4dHVyZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnVwbG9hZFRvR1BVKHByZWZlcnJlZFNoYXBlUkMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudGV4dHVyZTtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmdldFRleHR1cmVTaGFwZVJDID0gZnVuY3Rpb24gKHByZWZlcnJlZFNoYXBlUkMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS50ZXh0dXJlU2hhcGVSQyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnVwbG9hZFRvR1BVKHByZWZlcnJlZFNoYXBlUkMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEudGV4dHVyZVNoYXBlUkM7XG4gICAgfTtcbiAgICBOREFycmF5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEudmFsdWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaGFwZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmRhdGEudGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VUZXh0dXJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmRpc3Bvc2VUZXh0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvd0lmR1BVTm90SW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgZXhwb3J0cy5URVhUVVJFX01BTkFHRVIucmVsZWFzZVRleHR1cmUodGhpcy5kYXRhLnRleHR1cmUsIHRoaXMuZGF0YS50ZXh0dXJlU2hhcGVSQyk7XG4gICAgICAgIHRoaXMuZGF0YS50ZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhLnRleHR1cmVTaGFwZVJDID0gbnVsbDtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmluR1BVID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnRleHR1cmUgIT0gbnVsbDtcbiAgICB9O1xuICAgIE5EQXJyYXkucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB1dGlsLmFycmF5c0VxdWFsKHRoaXMuc2hhcGUsIHQuc2hhcGUpICYmXG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHRoaXMuZ2V0VmFsdWVzKCksIHQuZ2V0VmFsdWVzKCkpO1xuICAgIH07XG4gICAgTkRBcnJheS5yYW5kID0gZnVuY3Rpb24gKHNoYXBlLCByYW5kRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IHJhbmRGdW5jdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOREFycmF5Lm1ha2Uoc2hhcGUsIHsgdmFsdWVzOiB2YWx1ZXMgfSk7XG4gICAgfTtcbiAgICBOREFycmF5LnJhbmROb3JtYWwgPSBmdW5jdGlvbiAoc2hhcGUsIG1lYW4sIHN0ZERldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZEdhdXNzKG1lYW4sIHN0ZERldik7IH0pO1xuICAgIH07XG4gICAgTkRBcnJheS5yYW5kVHJ1bmNhdGVkTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkRGV2ID09PSB2b2lkIDApIHsgc3RkRGV2ID0gMTsgfVxuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRHYXVzcyhtZWFuLCBzdGREZXYsIHRydWUpOyB9KTtcbiAgICB9O1xuICAgIE5EQXJyYXkucmFuZFVuaWZvcm0gPSBmdW5jdGlvbiAoc2hhcGUsIGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kVW5pZm9ybShhLCBiKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTkRBcnJheTtcbn0oKSk7XG5leHBvcnRzLk5EQXJyYXkgPSBOREFycmF5O1xudmFyIFNjYWxhciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjYWxhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTY2FsYXIoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGF0YS50ZXh0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRhdGEudGV4dHVyZVNoYXBlUkMgPSBbMSwgMV07XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBbXSwgZGF0YSkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTY2FsYXIubmV3ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NhbGFyKHsgdmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KFt2YWx1ZV0pIH0pO1xuICAgIH07XG4gICAgU2NhbGFyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlcygpWzBdO1xuICAgIH07XG4gICAgU2NhbGFyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKVswXSA9IHZhbHVlO1xuICAgIH07XG4gICAgU2NhbGFyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKVswXSArPSB2YWx1ZTtcbiAgICB9O1xuICAgIFNjYWxhci5aRVJPID0gU2NhbGFyLm5ldygwKTtcbiAgICBTY2FsYXIuT05FID0gU2NhbGFyLm5ldygxKTtcbiAgICBTY2FsYXIuVFdPID0gU2NhbGFyLm5ldygyKTtcbiAgICBTY2FsYXIuTkVHX09ORSA9IFNjYWxhci5uZXcoLTEpO1xuICAgIHJldHVybiBTY2FsYXI7XG59KE5EQXJyYXkpKTtcbmV4cG9ydHMuU2NhbGFyID0gU2NhbGFyO1xudmFyIEFycmF5MUQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcnJheTFELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5MUQoZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2hhcGUgPSAoZGF0YS52YWx1ZXMgIT0gbnVsbCkgP1xuICAgICAgICAgICAgW2RhdGEudmFsdWVzLmxlbmd0aF0gOlxuICAgICAgICAgICAgW3V0aWwuc2l6ZUZyb21TaGFwZShkYXRhLnRleHR1cmVTaGFwZVJDKV07XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2hhcGUsIGRhdGEpIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXJyYXkxRC5uZXcgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIGlmICghKHZhbHVlcyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpIHtcbiAgICAgICAgICAgIHZhciBpbmZlcnJlZFNoYXBlID0gdXRpbC5pbmZlclNoYXBlKHZhbHVlcyk7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChpbmZlcnJlZFNoYXBlLmxlbmd0aCA9PT0gMSwgXCJFcnJvciBjb25zdHJ1Y3RpbmcgQXJyYXkxRC4gU2hhcGUgb2YgdmFsdWVzIFwiICsgaW5mZXJyZWRTaGFwZSArIFwiIGlzIFwiICtcbiAgICAgICAgICAgICAgICBcIm5vdCAxIGRpbWVuc2lvbmFsLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFycmF5MUQoeyB2YWx1ZXM6IHRvVHlwZWRBcnJheSh2YWx1ZXMpIH0pO1xuICAgIH07XG4gICAgQXJyYXkxRC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKClbaV07XG4gICAgfTtcbiAgICBBcnJheTFELnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKVtpXSA9IHZhbHVlO1xuICAgIH07XG4gICAgQXJyYXkxRC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgIHRoaXMuZ2V0VmFsdWVzKClbaV0gKz0gdmFsdWU7XG4gICAgfTtcbiAgICBBcnJheTFELnByb3RvdHlwZS5sb2NUb0luZGV4ID0gZnVuY3Rpb24gKGxvYykge1xuICAgICAgICByZXR1cm4gbG9jWzBdO1xuICAgIH07XG4gICAgQXJyYXkxRC5wcm90b3R5cGUuaW5kZXhUb0xvYyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gW2luZGV4XTtcbiAgICB9O1xuICAgIEFycmF5MUQuemVyb3MgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkuemVyb3Moc2hhcGUpO1xuICAgIH07XG4gICAgQXJyYXkxRC5yYW5kTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkRGV2ID09PSB2b2lkIDApIHsgc3RkRGV2ID0gMTsgfVxuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRHYXVzcyhtZWFuLCBzdGREZXYpOyB9KTtcbiAgICB9O1xuICAgIEFycmF5MUQucmFuZFRydW5jYXRlZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2KSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kR2F1c3MobWVhbiwgc3RkRGV2LCB0cnVlKTsgfSk7XG4gICAgfTtcbiAgICBBcnJheTFELnJhbmRVbmlmb3JtID0gZnVuY3Rpb24gKHNoYXBlLCBhLCBiKSB7XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZFVuaWZvcm0oYSwgYik7IH0pO1xuICAgIH07XG4gICAgQXJyYXkxRC5tYWtlID0gZnVuY3Rpb24gKHNoYXBlLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXkxRChkYXRhKTtcbiAgICB9O1xuICAgIHJldHVybiBBcnJheTFEO1xufShOREFycmF5KSk7XG5leHBvcnRzLkFycmF5MUQgPSBBcnJheTFEO1xudmFyIEFycmF5MkQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcnJheTJELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5MkQoc2hhcGUsIGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoc2hhcGUubGVuZ3RoID09PSAyLCAnU2hhcGUgc2hvdWxkIGJlIG9mIGxlbmd0aCAyJyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2hhcGUsIGRhdGEpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0cmlkZTAgPSBfdGhpcy5zdHJpZGVzWzBdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFycmF5MkQubmV3ID0gZnVuY3Rpb24gKHNoYXBlLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKCEodmFsdWVzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkge1xuICAgICAgICAgICAgdmFyIGluZmVycmVkU2hhcGUgPSB1dGlsLmluZmVyU2hhcGUodmFsdWVzKTtcbiAgICAgICAgICAgIGlmIChpbmZlcnJlZFNoYXBlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKHNoYXBlLCBpbmZlcnJlZFNoYXBlLCBcIkVycm9yIHdoZW4gY29uc3RydWN0aW5nIEFycmF5MkQuIFNoYXBlIG9mIHZhbHVlcyBcIiArXG4gICAgICAgICAgICAgICAgICAgIChpbmZlcnJlZFNoYXBlICsgXCIgZG9lcyBub3QgbWF0Y2ggdGhlIHByb3ZpZGVkIHNoYXBlIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIChzaGFwZSArIFwiLiBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXkyRChzaGFwZSwgeyB2YWx1ZXM6IHRvVHlwZWRBcnJheSh2YWx1ZXMpIH0pO1xuICAgIH07XG4gICAgQXJyYXkyRC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGksIGopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKClbdGhpcy5zdHJpZGUwICogaSArIGpdO1xuICAgIH07XG4gICAgQXJyYXkyRC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlLCBpLCBqKSB7XG4gICAgICAgIHRoaXMuZ2V0VmFsdWVzKClbdGhpcy5zdHJpZGUwICogaSArIGpdID0gdmFsdWU7XG4gICAgfTtcbiAgICBBcnJheTJELnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUsIGksIGopIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgal0gKz0gdmFsdWU7XG4gICAgfTtcbiAgICBBcnJheTJELnByb3RvdHlwZS5sb2NUb0luZGV4ID0gZnVuY3Rpb24gKGxvY3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaWRlMCAqIGxvY3NbMF0gKyBsb2NzWzFdO1xuICAgIH07XG4gICAgQXJyYXkyRC5wcm90b3R5cGUuaW5kZXhUb0xvYyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gW01hdGguZmxvb3IoaW5kZXggLyB0aGlzLnN0cmlkZTApLCBpbmRleCAlIHRoaXMuc3RyaWRlMF07XG4gICAgfTtcbiAgICBBcnJheTJELnplcm9zID0gZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgIHJldHVybiBOREFycmF5Lnplcm9zKHNoYXBlKTtcbiAgICB9O1xuICAgIEFycmF5MkQucmFuZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2KSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kR2F1c3MobWVhbiwgc3RkRGV2KTsgfSk7XG4gICAgfTtcbiAgICBBcnJheTJELnJhbmRUcnVuY2F0ZWROb3JtYWwgPSBmdW5jdGlvbiAoc2hhcGUsIG1lYW4sIHN0ZERldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZEdhdXNzKG1lYW4sIHN0ZERldiwgdHJ1ZSk7IH0pO1xuICAgIH07XG4gICAgQXJyYXkyRC5yYW5kVW5pZm9ybSA9IGZ1bmN0aW9uIChzaGFwZSwgYSwgYikge1xuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRVbmlmb3JtKGEsIGIpOyB9KTtcbiAgICB9O1xuICAgIEFycmF5MkQubWFrZSA9IGZ1bmN0aW9uIChzaGFwZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5MkQoc2hhcGUsIGRhdGEpO1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5MkQ7XG59KE5EQXJyYXkpKTtcbmV4cG9ydHMuQXJyYXkyRCA9IEFycmF5MkQ7XG52YXIgQXJyYXkzRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5M0QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJyYXkzRChzaGFwZSwgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsLmFzc2VydChzaGFwZS5sZW5ndGggPT09IDMsICdTaGFwZSBzaG91bGQgYmUgb2YgbGVuZ3RoIDMnKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzaGFwZSwgZGF0YSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RyaWRlMCA9IF90aGlzLnN0cmlkZXNbMF07XG4gICAgICAgIF90aGlzLnN0cmlkZTEgPSBfdGhpcy5zdHJpZGVzWzFdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFycmF5M0QubmV3ID0gZnVuY3Rpb24gKHNoYXBlLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKCEodmFsdWVzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkge1xuICAgICAgICAgICAgdmFyIGluZmVycmVkU2hhcGUgPSB1dGlsLmluZmVyU2hhcGUodmFsdWVzKTtcbiAgICAgICAgICAgIGlmIChpbmZlcnJlZFNoYXBlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKHNoYXBlLCBpbmZlcnJlZFNoYXBlLCBcIkVycm9yIHdoZW4gY29uc3RydWN0aW5nIEFycmF5M0QuIFNoYXBlIG9mIHZhbHVlcyBcIiArXG4gICAgICAgICAgICAgICAgICAgIChpbmZlcnJlZFNoYXBlICsgXCIgZG9lcyBub3QgbWF0Y2ggdGhlIHByb3ZpZGVkIHNoYXBlIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIChzaGFwZSArIFwiLiBcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXkzRChzaGFwZSwgeyB2YWx1ZXM6IHRvVHlwZWRBcnJheSh2YWx1ZXMpIH0pO1xuICAgIH07XG4gICAgQXJyYXkzRC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGksIGosIGspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKClbdGhpcy5zdHJpZGUwICogaSArIHRoaXMuc3RyaWRlMSAqIGogKyBrXTtcbiAgICB9O1xuICAgIEFycmF5M0QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSwgaSwgaiwgaykge1xuICAgICAgICB0aGlzLmdldFZhbHVlcygpW3RoaXMuc3RyaWRlMCAqIGkgKyB0aGlzLnN0cmlkZTEgKiBqICsga10gPSB2YWx1ZTtcbiAgICB9O1xuICAgIEFycmF5M0QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaSwgaiwgaykge1xuICAgICAgICB0aGlzLmdldFZhbHVlcygpW3RoaXMuc3RyaWRlMCAqIGkgKyB0aGlzLnN0cmlkZTEgKiBqICsga10gKz0gdmFsdWU7XG4gICAgfTtcbiAgICBBcnJheTNELnByb3RvdHlwZS5sb2NUb0luZGV4ID0gZnVuY3Rpb24gKGxvY3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaWRlMCAqIGxvY3NbMF0gKyB0aGlzLnN0cmlkZTEgKiBsb2NzWzFdICsgbG9jc1syXTtcbiAgICB9O1xuICAgIEFycmF5M0QucHJvdG90eXBlLmluZGV4VG9Mb2MgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5zdHJpZGUwKTtcbiAgICAgICAgaW5kZXggLT0gaSAqIHRoaXMuc3RyaWRlMDtcbiAgICAgICAgcmV0dXJuIFtpLCBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5zdHJpZGUxKSwgaW5kZXggJSB0aGlzLnN0cmlkZTFdO1xuICAgIH07XG4gICAgQXJyYXkzRC56ZXJvcyA9IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICByZXR1cm4gTkRBcnJheS56ZXJvcyhzaGFwZSk7XG4gICAgfTtcbiAgICBBcnJheTNELnJhbmROb3JtYWwgPSBmdW5jdGlvbiAoc2hhcGUsIG1lYW4sIHN0ZERldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZEdhdXNzKG1lYW4sIHN0ZERldik7IH0pO1xuICAgIH07XG4gICAgQXJyYXkzRC5yYW5kVHJ1bmNhdGVkTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkRGV2ID09PSB2b2lkIDApIHsgc3RkRGV2ID0gMTsgfVxuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRHYXVzcyhtZWFuLCBzdGREZXYsIHRydWUpOyB9KTtcbiAgICB9O1xuICAgIEFycmF5M0QucmFuZFVuaWZvcm0gPSBmdW5jdGlvbiAoc2hhcGUsIGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kVW5pZm9ybShhLCBiKTsgfSk7XG4gICAgfTtcbiAgICBBcnJheTNELm1ha2UgPSBmdW5jdGlvbiAoc2hhcGUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheTNEKHNoYXBlLCBkYXRhKTtcbiAgICB9O1xuICAgIHJldHVybiBBcnJheTNEO1xufShOREFycmF5KSk7XG5leHBvcnRzLkFycmF5M0QgPSBBcnJheTNEO1xudmFyIEFycmF5NEQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcnJheTRELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5NEQoc2hhcGUsIGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbC5hc3NlcnQoc2hhcGUubGVuZ3RoID09PSA0LCAnU2hhcGUgc2hvdWxkIGJlIG9mIGxlbmd0aCA0Jyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2hhcGUsIGRhdGEpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0cmlkZTAgPSBfdGhpcy5zdHJpZGVzWzBdO1xuICAgICAgICBfdGhpcy5zdHJpZGUxID0gX3RoaXMuc3RyaWRlc1sxXTtcbiAgICAgICAgX3RoaXMuc3RyaWRlMiA9IF90aGlzLnN0cmlkZXNbMl07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXJyYXk0RC5uZXcgPSBmdW5jdGlvbiAoc2hhcGUsIHZhbHVlcykge1xuICAgICAgICBpZiAoISh2YWx1ZXMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICAgICAgICB2YXIgaW5mZXJyZWRTaGFwZSA9IHV0aWwuaW5mZXJTaGFwZSh2YWx1ZXMpO1xuICAgICAgICAgICAgaWYgKGluZmVycmVkU2hhcGUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goc2hhcGUsIGluZmVycmVkU2hhcGUsIFwiRXJyb3Igd2hlbiBjb25zdHJ1Y3RpbmcgQXJyYXk0RC4gU2hhcGUgb2YgdmFsdWVzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKGluZmVycmVkU2hhcGUgKyBcIiBkb2VzIG5vdCBtYXRjaCB0aGUgcHJvdmlkZWQgc2hhcGUgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgKHNoYXBlICsgXCIuIFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheTREKHNoYXBlLCB7IHZhbHVlczogdG9UeXBlZEFycmF5KHZhbHVlcykgfSk7XG4gICAgfTtcbiAgICBBcnJheTRELnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaSwgaiwgaywgbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgdGhpcy5zdHJpZGUxICogaiArIHRoaXMuc3RyaWRlMiAqIGsgKyBsXTtcbiAgICB9O1xuICAgIEFycmF5NEQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSwgaSwgaiwgaywgbCkge1xuICAgICAgICB0aGlzLmdldFZhbHVlcygpW3RoaXMuc3RyaWRlMCAqIGkgKyB0aGlzLnN0cmlkZTEgKiBqICsgdGhpcy5zdHJpZGUyICogayArIGxdID0gdmFsdWU7XG4gICAgfTtcbiAgICBBcnJheTRELnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsdWUsIGksIGosIGssIGwpIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgdGhpcy5zdHJpZGUxICogaiArIHRoaXMuc3RyaWRlMiAqIGsgKyBsXSArPSB2YWx1ZTtcbiAgICB9O1xuICAgIEFycmF5NEQucHJvdG90eXBlLmxvY1RvSW5kZXggPSBmdW5jdGlvbiAobG9jcykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpZGUwICogbG9jc1swXSArIHRoaXMuc3RyaWRlMSAqIGxvY3NbMV0gK1xuICAgICAgICAgICAgdGhpcy5zdHJpZGUyICogbG9jc1syXSArIGxvY3NbM107XG4gICAgfTtcbiAgICBBcnJheTRELnByb3RvdHlwZS5pbmRleFRvTG9jID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBpID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlMCk7XG4gICAgICAgIGluZGV4IC09IGkgKiB0aGlzLnN0cmlkZTA7XG4gICAgICAgIHZhciBqID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlMSk7XG4gICAgICAgIGluZGV4IC09IGogKiB0aGlzLnN0cmlkZTE7XG4gICAgICAgIHJldHVybiBbaSwgaiwgTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlMiksIGluZGV4ICUgdGhpcy5zdHJpZGUyXTtcbiAgICB9O1xuICAgIEFycmF5NEQuemVyb3MgPSBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIE5EQXJyYXkuemVyb3Moc2hhcGUpO1xuICAgIH07XG4gICAgQXJyYXk0RC5yYW5kTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYpIHtcbiAgICAgICAgaWYgKG1lYW4gPT09IHZvaWQgMCkgeyBtZWFuID0gMDsgfVxuICAgICAgICBpZiAoc3RkRGV2ID09PSB2b2lkIDApIHsgc3RkRGV2ID0gMTsgfVxuICAgICAgICByZXR1cm4gTkRBcnJheS5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLnJhbmRHYXVzcyhtZWFuLCBzdGREZXYpOyB9KTtcbiAgICB9O1xuICAgIEFycmF5NEQucmFuZFRydW5jYXRlZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2KSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZChzaGFwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbC5yYW5kR2F1c3MobWVhbiwgc3RkRGV2LCB0cnVlKTsgfSk7XG4gICAgfTtcbiAgICBBcnJheTRELnJhbmRVbmlmb3JtID0gZnVuY3Rpb24gKHNoYXBlLCBhLCBiKSB7XG4gICAgICAgIHJldHVybiBOREFycmF5LnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZFVuaWZvcm0oYSwgYik7IH0pO1xuICAgIH07XG4gICAgQXJyYXk0RC5tYWtlID0gZnVuY3Rpb24gKHNoYXBlLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXk0RChzaGFwZSwgZGF0YSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXk0RDtcbn0oTkRBcnJheSkpO1xuZXhwb3J0cy5BcnJheTREID0gQXJyYXk0RDtcbmZ1bmN0aW9uIHRvVHlwZWRBcnJheShhKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSA/XG4gICAgICAgIGEgOiBuZXcgRmxvYXQzMkFycmF5KHV0aWwuZmxhdHRlbihhKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZGFycmF5LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/ndarray.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/slice_util.js":
/*!************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/slice_util.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nfunction assertParamsValid(input, begin, size) {\n    util.assert(input.rank === begin.length, \"Error in slice\" + input.rank + \"D: Length of begin \" + begin + \" must \" +\n        (\"match the rank of the array (\" + input.rank + \").\"));\n    util.assert(input.rank === size.length, \"Error in slice\" + input.rank + \"D: Length of size \" + size + \" must \" +\n        (\"match the rank of the array (\" + input.rank + \").\"));\n    for (var i = 0; i < input.rank; ++i) {\n        util.assert(begin[i] + size[i] <= input.shape[i], \"Error in slice\" + input.rank + \"D: begin[\" + i + \"] + size[\" + i + \"] \" +\n            (\"(\" + (begin[i] + size[i]) + \") would overflow input.shape[\" + i + \"] (\" + input.shape[i] + \")\"));\n    }\n}\nexports.assertParamsValid = assertParamsValid;\n//# sourceMappingURL=slice_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvc2xpY2VfdXRpbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC9zbGljZV91dGlsLmpzP2ZhMmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gYXNzZXJ0UGFyYW1zVmFsaWQoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgdXRpbC5hc3NlcnQoaW5wdXQucmFuayA9PT0gYmVnaW4ubGVuZ3RoLCBcIkVycm9yIGluIHNsaWNlXCIgKyBpbnB1dC5yYW5rICsgXCJEOiBMZW5ndGggb2YgYmVnaW4gXCIgKyBiZWdpbiArIFwiIG11c3QgXCIgK1xuICAgICAgICAoXCJtYXRjaCB0aGUgcmFuayBvZiB0aGUgYXJyYXkgKFwiICsgaW5wdXQucmFuayArIFwiKS5cIikpO1xuICAgIHV0aWwuYXNzZXJ0KGlucHV0LnJhbmsgPT09IHNpemUubGVuZ3RoLCBcIkVycm9yIGluIHNsaWNlXCIgKyBpbnB1dC5yYW5rICsgXCJEOiBMZW5ndGggb2Ygc2l6ZSBcIiArIHNpemUgKyBcIiBtdXN0IFwiICtcbiAgICAgICAgKFwibWF0Y2ggdGhlIHJhbmsgb2YgdGhlIGFycmF5IChcIiArIGlucHV0LnJhbmsgKyBcIikuXCIpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0LnJhbms7ICsraSkge1xuICAgICAgICB1dGlsLmFzc2VydChiZWdpbltpXSArIHNpemVbaV0gPD0gaW5wdXQuc2hhcGVbaV0sIFwiRXJyb3IgaW4gc2xpY2VcIiArIGlucHV0LnJhbmsgKyBcIkQ6IGJlZ2luW1wiICsgaSArIFwiXSArIHNpemVbXCIgKyBpICsgXCJdIFwiICtcbiAgICAgICAgICAgIChcIihcIiArIChiZWdpbltpXSArIHNpemVbaV0pICsgXCIpIHdvdWxkIG92ZXJmbG93IGlucHV0LnNoYXBlW1wiICsgaSArIFwiXSAoXCIgKyBpbnB1dC5zaGFwZVtpXSArIFwiKVwiKSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRQYXJhbXNWYWxpZCA9IGFzc2VydFBhcmFtc1ZhbGlkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2xpY2VfdXRpbC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/slice_util.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/addscaledmat_gpu.js":
/*!************************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/addscaledmat_gpu.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar AddScaledMatProgram = (function () {\n    function AddScaledMatProgram(aShape, bShape) {\n        this.variableNames = ['A', 'B', 'c1', 'c2'];\n        this.params = [];\n        this.supportsBroadcasting = true;\n        this.outputShape = util.assertAndGetBroadcastedShape(aShape, bShape);\n        this.userCode = \"\\n      void main() {\\n        float a = getAAtOutCoords();\\n        float b = getBAtOutCoords();\\n        float c1 = getC1();\\n        float c2 = getC2();\\n        setOutput(dot(vec2(c1, c2), vec2(a, b)));\\n      }\\n    \";\n    }\n    return AddScaledMatProgram;\n}());\nexports.AddScaledMatProgram = AddScaledMatProgram;\n//# sourceMappingURL=addscaledmat_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvYWRkc2NhbGVkbWF0X2dwdS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9hZGRzY2FsZWRtYXRfZ3B1LmpzPzE2MWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIEFkZFNjYWxlZE1hdFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFkZFNjYWxlZE1hdFByb2dyYW0oYVNoYXBlLCBiU2hhcGUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJywgJ0InLCAnYzEnLCAnYzInXTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdXBwb3J0c0Jyb2FkY2FzdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSB1dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdGVkU2hhcGUoYVNoYXBlLCBiU2hhcGUpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCBhID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBiID0gZ2V0QkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBjMSA9IGdldEMxKCk7XFxuICAgICAgICBmbG9hdCBjMiA9IGdldEMyKCk7XFxuICAgICAgICBzZXRPdXRwdXQoZG90KHZlYzIoYzEsIGMyKSwgdmVjMihhLCBiKSkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBBZGRTY2FsZWRNYXRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQWRkU2NhbGVkTWF0UHJvZ3JhbSA9IEFkZFNjYWxlZE1hdFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRzY2FsZWRtYXRfZ3B1LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/addscaledmat_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/argmaxequals_gpu.js":
/*!************************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/argmaxequals_gpu.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar argminmax_gpu = __webpack_require__(/*! ./argminmax_gpu */ \"./node_modules/deeplearn/dist/src/math/webgl/argminmax_gpu.js\");\nvar ArgMaxEqualsProgram = (function () {\n    function ArgMaxEqualsProgram(aSize, bSize) {\n        this.variableNames = ['A', 'B'];\n        this.outputShape = [];\n        this.params = [];\n        var aSnippet = argminmax_gpu.getArgMinMaxSnippet('max', 'A', aSize);\n        var bSnippet = argminmax_gpu.getArgMinMaxSnippet('max', 'B', bSize);\n        this.userCode = \"\\n      \" + aSnippet + \"\\n      \" + bSnippet + \"\\n\\n      void main() {\\n        float argMaxA = getArgMinMaxA();\\n        float argMaxB = getArgMinMaxB();\\n\\n        float value;\\n        if (isNaN(argMaxA)) {\\n          value = argMaxA;\\n        } else if (isNaN(argMaxB)) {\\n          value = argMaxB;\\n        } else {\\n          value = float(argMaxA == argMaxB);\\n        }\\n\\n        setOutput(value);\\n      }\\n    \";\n    }\n    return ArgMaxEqualsProgram;\n}());\nexports.ArgMaxEqualsProgram = ArgMaxEqualsProgram;\n//# sourceMappingURL=argmaxequals_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvYXJnbWF4ZXF1YWxzX2dwdS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9hcmdtYXhlcXVhbHNfZ3B1LmpzP2YxZjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXJnbWlubWF4X2dwdSA9IHJlcXVpcmUoXCIuL2FyZ21pbm1heF9ncHVcIik7XG52YXIgQXJnTWF4RXF1YWxzUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJnTWF4RXF1YWxzUHJvZ3JhbShhU2l6ZSwgYlNpemUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJywgJ0InXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtdO1xuICAgICAgICB2YXIgYVNuaXBwZXQgPSBhcmdtaW5tYXhfZ3B1LmdldEFyZ01pbk1heFNuaXBwZXQoJ21heCcsICdBJywgYVNpemUpO1xuICAgICAgICB2YXIgYlNuaXBwZXQgPSBhcmdtaW5tYXhfZ3B1LmdldEFyZ01pbk1heFNuaXBwZXQoJ21heCcsICdCJywgYlNpemUpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBcIiArIGFTbmlwcGV0ICsgXCJcXG4gICAgICBcIiArIGJTbmlwcGV0ICsgXCJcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCBhcmdNYXhBID0gZ2V0QXJnTWluTWF4QSgpO1xcbiAgICAgICAgZmxvYXQgYXJnTWF4QiA9IGdldEFyZ01pbk1heEIoKTtcXG5cXG4gICAgICAgIGZsb2F0IHZhbHVlO1xcbiAgICAgICAgaWYgKGlzTmFOKGFyZ01heEEpKSB7XFxuICAgICAgICAgIHZhbHVlID0gYXJnTWF4QTtcXG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYU4oYXJnTWF4QikpIHtcXG4gICAgICAgICAgdmFsdWUgPSBhcmdNYXhCO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdmFsdWUgPSBmbG9hdChhcmdNYXhBID09IGFyZ01heEIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQXJnTWF4RXF1YWxzUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkFyZ01heEVxdWFsc1Byb2dyYW0gPSBBcmdNYXhFcXVhbHNQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJnbWF4ZXF1YWxzX2dwdS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/argmaxequals_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/argminmax_gpu.js":
/*!*********************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/argminmax_gpu.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getArgMinMaxSnippet(op, texName, size) {\n    var compOp = (op === 'min') ? '<' : '>';\n    return \"\\n    float getArgMinMax\" + texName + \"() {\\n      int bestIndex = 0;\\n      float bestValue = get\" + texName + \"Flat(0);\\n\\n      for (int i = 0; i < \" + size + \"; i++) {\\n        float candidate = get\" + texName + \"Flat(i);\\n        if (isNaN(candidate)) {\\n          return candidate;\\n        }\\n        if (candidate \" + compOp + \" bestValue) {\\n          bestValue = candidate;\\n          bestIndex = i;\\n        }\\n      }\\n      return float(bestIndex);\\n    }\\n  \";\n}\nexports.getArgMinMaxSnippet = getArgMinMaxSnippet;\nvar ArgMinMaxProgram = (function () {\n    function ArgMinMaxProgram(aSize, opType) {\n        this.variableNames = ['A'];\n        this.outputShape = [];\n        this.params = [opType];\n        var aSnippet = getArgMinMaxSnippet(opType, 'A', aSize);\n        this.userCode = \"\\n      \" + aSnippet + \"\\n\\n      void main() {\\n        setOutput(getArgMinMaxA());\\n      }\\n    \";\n    }\n    return ArgMinMaxProgram;\n}());\nexports.ArgMinMaxProgram = ArgMinMaxProgram;\n//# sourceMappingURL=argminmax_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvYXJnbWlubWF4X2dwdS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9hcmdtaW5tYXhfZ3B1LmpzPzk0ODQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBnZXRBcmdNaW5NYXhTbmlwcGV0KG9wLCB0ZXhOYW1lLCBzaXplKSB7XG4gICAgdmFyIGNvbXBPcCA9IChvcCA9PT0gJ21pbicpID8gJzwnIDogJz4nO1xuICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBnZXRBcmdNaW5NYXhcIiArIHRleE5hbWUgKyBcIigpIHtcXG4gICAgICBpbnQgYmVzdEluZGV4ID0gMDtcXG4gICAgICBmbG9hdCBiZXN0VmFsdWUgPSBnZXRcIiArIHRleE5hbWUgKyBcIkZsYXQoMCk7XFxuXFxuICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIiArIHNpemUgKyBcIjsgaSsrKSB7XFxuICAgICAgICBmbG9hdCBjYW5kaWRhdGUgPSBnZXRcIiArIHRleE5hbWUgKyBcIkZsYXQoaSk7XFxuICAgICAgICBpZiAoaXNOYU4oY2FuZGlkYXRlKSkge1xcbiAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGNhbmRpZGF0ZSBcIiArIGNvbXBPcCArIFwiIGJlc3RWYWx1ZSkge1xcbiAgICAgICAgICBiZXN0VmFsdWUgPSBjYW5kaWRhdGU7XFxuICAgICAgICAgIGJlc3RJbmRleCA9IGk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBmbG9hdChiZXN0SW5kZXgpO1xcbiAgICB9XFxuICBcIjtcbn1cbmV4cG9ydHMuZ2V0QXJnTWluTWF4U25pcHBldCA9IGdldEFyZ01pbk1heFNuaXBwZXQ7XG52YXIgQXJnTWluTWF4UHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJnTWluTWF4UHJvZ3JhbShhU2l6ZSwgb3BUeXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHRoaXMucGFyYW1zID0gW29wVHlwZV07XG4gICAgICAgIHZhciBhU25pcHBldCA9IGdldEFyZ01pbk1heFNuaXBwZXQob3BUeXBlLCAnQScsIGFTaXplKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgXCIgKyBhU25pcHBldCArIFwiXFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgc2V0T3V0cHV0KGdldEFyZ01pbk1heEEoKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEFyZ01pbk1heFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5BcmdNaW5NYXhQcm9ncmFtID0gQXJnTWluTWF4UHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyZ21pbm1heF9ncHUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/argminmax_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/batchnorm_gpu.js":
/*!*********************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/batchnorm_gpu.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar BatchNormProgram = (function () {\n    function BatchNormProgram(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {\n        this.params = [];\n        this.outputShape = [];\n        this.supportsBroadcasting = true;\n        this.variableNames = ['x', 'mean', 'variance'];\n        util.assertAndGetBroadcastedShape(xShape, meanShape);\n        util.assertAndGetBroadcastedShape(xShape, varianceShape);\n        var offsetSnippet = '0.0';\n        if (offsetShape != null) {\n            util.assertAndGetBroadcastedShape(xShape, offsetShape);\n            this.variableNames.push('offset');\n            offsetSnippet = 'getOffsetAtOutCoords()';\n        }\n        var scaleSnippet = '1.0';\n        if (scaleShape != null) {\n            util.assertAndGetBroadcastedShape(xShape, scaleShape);\n            this.variableNames.push('scale');\n            scaleSnippet = 'getScaleAtOutCoords()';\n        }\n        this.params = [varianceEpsilon];\n        this.outputShape = xShape;\n        this.userCode = \"\\n      void main() {\\n        float x = getXAtOutCoords();\\n        float mean = getMeanAtOutCoords();\\n        float variance = getVarianceAtOutCoords();\\n        float offset = \" + offsetSnippet + \";\\n        float scale = \" + scaleSnippet + \";\\n        float inv = scale / sqrt(variance + float(\" + varianceEpsilon + \"));\\n        setOutput((x - mean) * inv + offset);\\n      }\\n    \";\n    }\n    return BatchNormProgram;\n}());\nexports.BatchNormProgram = BatchNormProgram;\n//# sourceMappingURL=batchnorm_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvYmF0Y2hub3JtX2dwdS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9iYXRjaG5vcm1fZ3B1LmpzP2Q1NWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIEJhdGNoTm9ybVByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhdGNoTm9ybVByb2dyYW0oeFNoYXBlLCBtZWFuU2hhcGUsIHZhcmlhbmNlU2hhcGUsIG9mZnNldFNoYXBlLCBzY2FsZVNoYXBlLCB2YXJpYW5jZUVwc2lsb24pIHtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBbXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB0aGlzLnN1cHBvcnRzQnJvYWRjYXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4JywgJ21lYW4nLCAndmFyaWFuY2UnXTtcbiAgICAgICAgdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RlZFNoYXBlKHhTaGFwZSwgbWVhblNoYXBlKTtcbiAgICAgICAgdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RlZFNoYXBlKHhTaGFwZSwgdmFyaWFuY2VTaGFwZSk7XG4gICAgICAgIHZhciBvZmZzZXRTbmlwcGV0ID0gJzAuMCc7XG4gICAgICAgIGlmIChvZmZzZXRTaGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdGVkU2hhcGUoeFNoYXBlLCBvZmZzZXRTaGFwZSk7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnb2Zmc2V0Jyk7XG4gICAgICAgICAgICBvZmZzZXRTbmlwcGV0ID0gJ2dldE9mZnNldEF0T3V0Q29vcmRzKCknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2FsZVNuaXBwZXQgPSAnMS4wJztcbiAgICAgICAgaWYgKHNjYWxlU2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RlZFNoYXBlKHhTaGFwZSwgc2NhbGVTaGFwZSk7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnc2NhbGUnKTtcbiAgICAgICAgICAgIHNjYWxlU25pcHBldCA9ICdnZXRTY2FsZUF0T3V0Q29vcmRzKCknO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyYW1zID0gW3ZhcmlhbmNlRXBzaWxvbl07XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSB4U2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRYQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IG1lYW4gPSBnZXRNZWFuQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IHZhcmlhbmNlID0gZ2V0VmFyaWFuY2VBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgb2Zmc2V0ID0gXCIgKyBvZmZzZXRTbmlwcGV0ICsgXCI7XFxuICAgICAgICBmbG9hdCBzY2FsZSA9IFwiICsgc2NhbGVTbmlwcGV0ICsgXCI7XFxuICAgICAgICBmbG9hdCBpbnYgPSBzY2FsZSAvIHNxcnQodmFyaWFuY2UgKyBmbG9hdChcIiArIHZhcmlhbmNlRXBzaWxvbiArIFwiKSk7XFxuICAgICAgICBzZXRPdXRwdXQoKHggLSBtZWFuKSAqIGludiArIG9mZnNldCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEJhdGNoTm9ybVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5CYXRjaE5vcm1Qcm9ncmFtID0gQmF0Y2hOb3JtUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhdGNobm9ybV9ncHUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/batchnorm_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/binaryop_gpu.js":
/*!********************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/binaryop_gpu.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nexports.ADD = 'return a + b;';\nexports.SUB = 'return a - b;';\nexports.MUL = 'return a * b;';\nexports.DIV = 'return a / b;';\nvar BinaryOpProgram = (function () {\n    function BinaryOpProgram(op, aShape, bShape) {\n        this.variableNames = ['A', 'B'];\n        this.supportsBroadcasting = true;\n        this.params = [op];\n        this.outputShape = util.assertAndGetBroadcastedShape(aShape, bShape);\n        this.userCode = \"\\n      float binaryOperation(float a, float b) {\\n        \" + op + \"\\n      }\\n\\n      void main() {\\n        float a = getAAtOutCoords();\\n        float b = getBAtOutCoords();\\n        setOutput(binaryOperation(a, b));\\n      }\\n    \";\n    }\n    return BinaryOpProgram;\n}());\nexports.BinaryOpProgram = BinaryOpProgram;\n//# sourceMappingURL=binaryop_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvYmluYXJ5b3BfZ3B1LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL2JpbmFyeW9wX2dwdS5qcz80ZDU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmV4cG9ydHMuQUREID0gJ3JldHVybiBhICsgYjsnO1xuZXhwb3J0cy5TVUIgPSAncmV0dXJuIGEgLSBiOyc7XG5leHBvcnRzLk1VTCA9ICdyZXR1cm4gYSAqIGI7JztcbmV4cG9ydHMuRElWID0gJ3JldHVybiBhIC8gYjsnO1xudmFyIEJpbmFyeU9wUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmluYXJ5T3BQcm9ncmFtKG9wLCBhU2hhcGUsIGJTaGFwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnLCAnQiddO1xuICAgICAgICB0aGlzLnN1cHBvcnRzQnJvYWRjYXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBbb3BdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RlZFNoYXBlKGFTaGFwZSwgYlNoYXBlKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgZmxvYXQgYmluYXJ5T3BlcmF0aW9uKGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgICAgIFwiICsgb3AgKyBcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCBhID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBiID0gZ2V0QkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoYmluYXJ5T3BlcmF0aW9uKGEsIGIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQmluYXJ5T3BQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQmluYXJ5T3BQcm9ncmFtID0gQmluYXJ5T3BQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluYXJ5b3BfZ3B1LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/binaryop_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/concat_gpu.js":
/*!******************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/concat_gpu.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar concat_util = __webpack_require__(/*! ../concat_util */ \"./node_modules/deeplearn/dist/src/math/concat_util.js\");\nvar ConcatProgram = (function () {\n    function ConcatProgram(aShape, bShape, axis) {\n        this.variableNames = ['A', 'B'];\n        this.params = [];\n        this.outputShape = [];\n        var yAxes = ['yR', 'yC', 'yD', 'yW'];\n        var concatAxis = yAxes[axis];\n        this.params = [axis];\n        this.outputShape = concat_util.computeOutShape(aShape, bShape, axis);\n        var dType = getDataType(aShape.length);\n        var unpackSnippet = getUnpack(aShape.length);\n        var sampleCoords = getSampleCoords(aShape.length);\n        this.userCode = \"\\n      void main() {\\n        \" + dType + \" coords = getOutputCoords();\\n        \" + unpackSnippet + \"\\n\\n        float value = 0.0;\\n        if (\" + concatAxis + \" < \" + aShape[axis] + \") {\\n          value = getA(\" + sampleCoords + \");\\n        } else {\\n          \" + concatAxis + \" -= \" + aShape[axis] + \";\\n          value = getB(\" + sampleCoords + \");\\n        }\\n\\n        setOutput(value);\\n      }\\n    \";\n    }\n    return ConcatProgram;\n}());\nexports.ConcatProgram = ConcatProgram;\nfunction getSampleCoords(rank) {\n    if (rank === 1) {\n        return 'yR';\n    }\n    else if (rank === 2) {\n        return 'yR, yC';\n    }\n    else if (rank === 3) {\n        return 'yR, yC, yD';\n    }\n    else if (rank === 4) {\n        return 'yR, yC, yD, yW';\n    }\n    else {\n        throw Error(\"Concat for rank \" + rank + \" is not yet supported\");\n    }\n}\nfunction getUnpack(rank) {\n    var res = rank === 1 ? 'int yR = coords;' : 'int yR = coords.x;';\n    if (rank > 1) {\n        res += '\\nint yC = coords.y;';\n    }\n    if (rank > 2) {\n        res += '\\nint yD = coords.z;';\n    }\n    if (rank > 3) {\n        res += '\\nint yW = coords.w;';\n    }\n    if (rank > 4) {\n        throw Error(\"Concat for rank \" + rank + \" is not yet supported\");\n    }\n    return res;\n}\nfunction getDataType(rank) {\n    if (rank === 1) {\n        return 'int';\n    }\n    else if (rank === 2) {\n        return 'ivec2';\n    }\n    else if (rank === 3) {\n        return 'ivec3';\n    }\n    else if (rank === 4) {\n        return 'ivec4';\n    }\n    else {\n        throw Error(\"Concat for rank \" + rank + \" is not yet supported\");\n    }\n}\n//# sourceMappingURL=concat_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvY29uY2F0X2dwdS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9jb25jYXRfZ3B1LmpzPzE5MDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29uY2F0X3V0aWwgPSByZXF1aXJlKFwiLi4vY29uY2F0X3V0aWxcIik7XG52YXIgQ29uY2F0UHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uY2F0UHJvZ3JhbShhU2hhcGUsIGJTaGFwZSwgYXhpcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnLCAnQiddO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHZhciB5QXhlcyA9IFsneVInLCAneUMnLCAneUQnLCAneVcnXTtcbiAgICAgICAgdmFyIGNvbmNhdEF4aXMgPSB5QXhlc1theGlzXTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBbYXhpc107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoYVNoYXBlLCBiU2hhcGUsIGF4aXMpO1xuICAgICAgICB2YXIgZFR5cGUgPSBnZXREYXRhVHlwZShhU2hhcGUubGVuZ3RoKTtcbiAgICAgICAgdmFyIHVucGFja1NuaXBwZXQgPSBnZXRVbnBhY2soYVNoYXBlLmxlbmd0aCk7XG4gICAgICAgIHZhciBzYW1wbGVDb29yZHMgPSBnZXRTYW1wbGVDb29yZHMoYVNoYXBlLmxlbmd0aCk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgZFR5cGUgKyBcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIFwiICsgdW5wYWNrU25pcHBldCArIFwiXFxuXFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IDAuMDtcXG4gICAgICAgIGlmIChcIiArIGNvbmNhdEF4aXMgKyBcIiA8IFwiICsgYVNoYXBlW2F4aXNdICsgXCIpIHtcXG4gICAgICAgICAgdmFsdWUgPSBnZXRBKFwiICsgc2FtcGxlQ29vcmRzICsgXCIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgXCIgKyBjb25jYXRBeGlzICsgXCIgLT0gXCIgKyBhU2hhcGVbYXhpc10gKyBcIjtcXG4gICAgICAgICAgdmFsdWUgPSBnZXRCKFwiICsgc2FtcGxlQ29vcmRzICsgXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29uY2F0UHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNvbmNhdFByb2dyYW0gPSBDb25jYXRQcm9ncmFtO1xuZnVuY3Rpb24gZ2V0U2FtcGxlQ29vcmRzKHJhbmspIHtcbiAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ3lSJztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMikge1xuICAgICAgICByZXR1cm4gJ3lSLCB5Qyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICd5UiwgeUMsIHlEJztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gNCkge1xuICAgICAgICByZXR1cm4gJ3lSLCB5QywgeUQsIHlXJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiQ29uY2F0IGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFVucGFjayhyYW5rKSB7XG4gICAgdmFyIHJlcyA9IHJhbmsgPT09IDEgPyAnaW50IHlSID0gY29vcmRzOycgOiAnaW50IHlSID0gY29vcmRzLng7JztcbiAgICBpZiAocmFuayA+IDEpIHtcbiAgICAgICAgcmVzICs9ICdcXG5pbnQgeUMgPSBjb29yZHMueTsnO1xuICAgIH1cbiAgICBpZiAocmFuayA+IDIpIHtcbiAgICAgICAgcmVzICs9ICdcXG5pbnQgeUQgPSBjb29yZHMuejsnO1xuICAgIH1cbiAgICBpZiAocmFuayA+IDMpIHtcbiAgICAgICAgcmVzICs9ICdcXG5pbnQgeVcgPSBjb29yZHMudzsnO1xuICAgIH1cbiAgICBpZiAocmFuayA+IDQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJDb25jYXQgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBnZXREYXRhVHlwZShyYW5rKSB7XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdpbnQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAyKSB7XG4gICAgICAgIHJldHVybiAnaXZlYzInO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAzKSB7XG4gICAgICAgIHJldHVybiAnaXZlYzMnO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSA0KSB7XG4gICAgICAgIHJldHVybiAnaXZlYzQnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJDb25jYXQgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0X2dwdS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/concat_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/conv_backprop_gpu.js":
/*!*************************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/conv_backprop_gpu.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar conv_util = __webpack_require__(/*! ../conv_util */ \"./node_modules/deeplearn/dist/src/math/conv_util.js\");\nvar Conv2DDerWeightsProgram = (function () {\n    function Conv2DDerWeightsProgram(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        var _a = convInfo.outShape, yNumRows = _a[0], yNumCols = _a[1], outDepth = _a[2];\n        var _b = convInfo.inShape, xNumRows = _b[0], xNumCols = _b[1], inDepth = _b[2];\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        this.outputShape = conv_util.computeWeightsShape4D(inDepth, outDepth, convInfo.filterHeight, convInfo.filterWidth);\n        var padTop = convInfo.padInfo.top;\n        var padLeft = convInfo.padInfo.left;\n        this.params = [strideHeight, strideWidth, padLeft, padTop];\n        this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int wR = coords.x;\\n        int wC = coords.y;\\n        int d1 = coords.z;\\n        int d2 = coords.w;\\n\\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int yR = 0; yR < \" + yNumRows + \"; yR++) {\\n          int xR = wR + yR * \" + strideHeight + \" - \" + padTop + \";\\n\\n          if (xR < 0 || xR >= \" + xNumRows + \") {\\n            continue;\\n          }\\n\\n          for (int yC = 0; yC < \" + yNumCols + \"; yC++) {\\n            int xC = wC + yC * \" + strideWidth + \" - \" + padLeft + \";\\n\\n            if (xC < 0 || xC >= \" + xNumCols + \") {\\n              continue;\\n            }\\n\\n            float dyValue = getDy(yR, yC, d2);\\n            float xValue = getX(xR, xC, d1);\\n            dotProd += (xValue * dyValue);\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n    }\n    return Conv2DDerWeightsProgram;\n}());\nexports.Conv2DDerWeightsProgram = Conv2DDerWeightsProgram;\nvar Conv2DDerInputProgram = (function () {\n    function Conv2DDerInputProgram(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        var _a = convInfo.outShape, yRows = _a[0], yCols = _a[1], outDepth = _a[2];\n        this.outputShape = convInfo.inShape;\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var padTop = filterHeight - 1 - convInfo.padInfo.top;\n        var padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        this.params = [strideHeight, strideWidth, padLeft, padTop];\n        this.userCode = \"\\n      const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        int d1 = coords.z;\\n\\n        ivec2 dyCorner = coords.xy - pads;\\n        int dyRCorner = dyCorner.x;\\n        int dyCCorner = dyCorner.y;\\n\\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \" + strideHeight + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + yRows + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          int wRPerm = \" + filterHeight + \" - 1 - wR;\\n\\n          for (int wC = 0; wC < \" + filterWidth + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + strideWidth + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + yCols + \".0 || fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            int wCPerm = \" + filterWidth + \" - 1 - wC;\\n\\n            for (int d2 = 0; d2 < \" + outDepth + \"; d2++) {\\n              float xValue = getDy(idyR, idyC, d2);\\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\\n              dotProd += xValue * wValue;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n    }\n    return Conv2DDerInputProgram;\n}());\nexports.Conv2DDerInputProgram = Conv2DDerInputProgram;\nvar Conv2DDerBiasProgram = (function () {\n    function Conv2DDerBiasProgram(yShape) {\n        this.variableNames = ['dy'];\n        this.params = [];\n        var yNumRows = yShape[0], yNumCols = yShape[1], outputDepth = yShape[2];\n        this.outputShape = [outputDepth];\n        this.userCode = \"\\n      void main() {\\n        int d2 = getOutputCoords();\\n\\n        float derBias = 0.0;\\n        for (int yR = 0; yR < \" + yNumRows + \"; yR++) {\\n          for (int yC = 0; yC < \" + yNumCols + \"; yC++) {\\n            derBias += getDy(yR, yC, d2);\\n          }\\n        }\\n        setOutput(derBias);\\n      }\\n    \";\n    }\n    return Conv2DDerBiasProgram;\n}());\nexports.Conv2DDerBiasProgram = Conv2DDerBiasProgram;\n//# sourceMappingURL=conv_backprop_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvY29udl9iYWNrcHJvcF9ncHUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvY29udl9iYWNrcHJvcF9ncHUuanM/ZGM5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb252X3V0aWwgPSByZXF1aXJlKFwiLi4vY29udl91dGlsXCIpO1xudmFyIENvbnYyRERlcldlaWdodHNQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb252MkREZXJXZWlnaHRzUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnZHknXTtcbiAgICAgICAgdmFyIF9hID0gY29udkluZm8ub3V0U2hhcGUsIHlOdW1Sb3dzID0gX2FbMF0sIHlOdW1Db2xzID0gX2FbMV0sIG91dERlcHRoID0gX2FbMl07XG4gICAgICAgIHZhciBfYiA9IGNvbnZJbmZvLmluU2hhcGUsIHhOdW1Sb3dzID0gX2JbMF0sIHhOdW1Db2xzID0gX2JbMV0sIGluRGVwdGggPSBfYlsyXTtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZVdlaWdodHNTaGFwZTREKGluRGVwdGgsIG91dERlcHRoLCBjb252SW5mby5maWx0ZXJIZWlnaHQsIGNvbnZJbmZvLmZpbHRlcldpZHRoKTtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBbc3RyaWRlSGVpZ2h0LCBzdHJpZGVXaWR0aCwgcGFkTGVmdCwgcGFkVG9wXTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggZHkoOiwgOiwgZDIpIHRvIGdldCBkdyh3Uiwgd0MsIGQxLCBkMikuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgXCIgKyB5TnVtUm93cyArIFwiOyB5UisrKSB7XFxuICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIiArIHN0cmlkZUhlaWdodCArIFwiIC0gXCIgKyBwYWRUb3AgKyBcIjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIiArIHhOdW1Sb3dzICsgXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCB5QyA9IDA7IHlDIDwgXCIgKyB5TnVtQ29scyArIFwiOyB5QysrKSB7XFxuICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqIFwiICsgc3RyaWRlV2lkdGggKyBcIiAtIFwiICsgcGFkTGVmdCArIFwiO1xcblxcbiAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyB4TnVtQ29scyArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KHlSLCB5QywgZDIpO1xcbiAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29udjJERGVyV2VpZ2h0c1Byb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Db252MkREZXJXZWlnaHRzUHJvZ3JhbSA9IENvbnYyRERlcldlaWdodHNQcm9ncmFtO1xudmFyIENvbnYyRERlcklucHV0UHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udjJERGVySW5wdXRQcm9ncmFtKGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnZHknLCAnVyddO1xuICAgICAgICB2YXIgX2EgPSBjb252SW5mby5vdXRTaGFwZSwgeVJvd3MgPSBfYVswXSwgeUNvbHMgPSBfYVsxXSwgb3V0RGVwdGggPSBfYVsyXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmluU2hhcGU7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBmaWx0ZXJXaWR0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHRoaXMucGFyYW1zID0gW3N0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIHBhZExlZnQsIHBhZFRvcF07XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHMuejtcXG5cXG4gICAgICAgIGl2ZWMyIGR5Q29ybmVyID0gY29vcmRzLnh5IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGZpbHRlckhlaWdodCArIFwiOyB3UisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIgKyB5Um93cyArIFwiLjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XFxuXFxuICAgICAgICAgIGludCB3UlBlcm0gPSBcIiArIGZpbHRlckhlaWdodCArIFwiIC0gMSAtIHdSO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIgKyBmaWx0ZXJXaWR0aCArIFwiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIgKyBzdHJpZGVXaWR0aCArIFwiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIgKyB5Q29scyArIFwiLjAgfHwgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgaW50IHdDUGVybSA9IFwiICsgZmlsdGVyV2lkdGggKyBcIiAtIDEgLSB3QztcXG5cXG4gICAgICAgICAgICBmb3IgKGludCBkMiA9IDA7IGQyIDwgXCIgKyBvdXREZXB0aCArIFwiOyBkMisrKSB7XFxuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShpZHlSLCBpZHlDLCBkMik7XFxuICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbnYyRERlcklucHV0UHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNvbnYyRERlcklucHV0UHJvZ3JhbSA9IENvbnYyRERlcklucHV0UHJvZ3JhbTtcbnZhciBDb252MkREZXJCaWFzUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udjJERGVyQmlhc1Byb2dyYW0oeVNoYXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnZHknXTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBbXTtcbiAgICAgICAgdmFyIHlOdW1Sb3dzID0geVNoYXBlWzBdLCB5TnVtQ29scyA9IHlTaGFwZVsxXSwgb3V0cHV0RGVwdGggPSB5U2hhcGVbMl07XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbb3V0cHV0RGVwdGhdO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpbnQgZDIgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgIGZsb2F0IGRlckJpYXMgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgXCIgKyB5TnVtUm93cyArIFwiOyB5UisrKSB7XFxuICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCBcIiArIHlOdW1Db2xzICsgXCI7IHlDKyspIHtcXG4gICAgICAgICAgICBkZXJCaWFzICs9IGdldER5KHlSLCB5QywgZDIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZGVyQmlhcyk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbnYyRERlckJpYXNQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQ29udjJERGVyQmlhc1Byb2dyYW0gPSBDb252MkREZXJCaWFzUHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnZfYmFja3Byb3BfZ3B1LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/conv_backprop_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/conv_gpu.js":
/*!****************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/conv_gpu.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Conv2DProgram = (function () {\n    function Conv2DProgram(convInfo, hasBias) {\n        this.variableNames = ['x', 'W'];\n        if (hasBias) {\n            this.variableNames.push('bias');\n        }\n        this.outputShape = convInfo.outShape;\n        var biasSnippet = hasBias ? 'dotProd += getBias(d2);' : '';\n        var _a = convInfo.inShape, xNumRows = _a[0], xNumCols = _a[1], inputDepth = _a[2];\n        var padTop = convInfo.padInfo.top;\n        var padLeft = convInfo.padInfo.left;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        this.params = [strideHeight, strideWidth, hasBias, padLeft, padTop];\n        var inputDepthNearestVec4 = Math.floor(inputDepth / 4) * 4;\n        var inputDepthVec4Remainder = inputDepth % 4;\n        this.userCode = \"\\n      const ivec2 strides = ivec2(\" + strideHeight + \", \" + strideWidth + \");\\n      const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        int d2 = coords.z;\\n\\n        ivec2 xRCCorner = coords.xy * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n          int xR = xRCorner + wR;\\n\\n          if (xR < 0 || xR >= \" + xNumRows + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + filterWidth + \"; wC++) {\\n            int xC = xCCorner + wC;\\n\\n            if (xC < 0 || xC >= \" + xNumCols + \") {\\n              continue;\\n            }\\n\\n            for (int d1 = 0; d1 < \" + inputDepthNearestVec4 + \"; d1 += 4) {\\n              vec4 xValues = vec4(\\n                getX(xR, xC, d1),\\n                getX(xR, xC, d1 + 1),\\n                getX(xR, xC, d1 + 2),\\n                getX(xR, xC, d1 + 3)\\n              );\\n              vec4 wValues = vec4(\\n                getW(wR, wC, d1, d2),\\n                getW(wR, wC, d1 + 1, d2),\\n                getW(wR, wC, d1 + 2, d2),\\n                getW(wR, wC, d1 + 3, d2)\\n              );\\n\\n              dotProd += dot(xValues, wValues);\\n            }\\n\\n            if (\" + (inputDepthVec4Remainder === 1) + \") {\\n              dotProd +=\\n                getX(xR, xC, \" + inputDepthNearestVec4 + \") *\\n                getW(wR, wC, \" + inputDepthNearestVec4 + \", d2);\\n            } else if (\" + (inputDepthVec4Remainder === 2) + \") {\\n              vec2 xValues = vec2(\\n                getX(xR, xC, \" + inputDepthNearestVec4 + \"),\\n                getX(xR, xC, \" + inputDepthNearestVec4 + \" + 1)\\n              );\\n              vec2 wValues = vec2(\\n                getW(wR, wC, \" + inputDepthNearestVec4 + \", d2),\\n                getW(wR, wC, \" + inputDepthNearestVec4 + \" + 1, d2)\\n              );\\n              dotProd += dot(xValues, wValues);\\n            } else if (\" + (inputDepthVec4Remainder === 3) + \") {\\n              vec3 xValues = vec3(\\n                getX(xR, xC, \" + inputDepthNearestVec4 + \"),\\n                getX(xR, xC, \" + inputDepthNearestVec4 + \" + 1),\\n                getX(xR, xC, \" + inputDepthNearestVec4 + \" + 2)\\n              );\\n              vec3 wValues = vec3(\\n                getW(wR, wC, \" + inputDepthNearestVec4 + \", d2),\\n                getW(wR, wC, \" + inputDepthNearestVec4 + \" + 1, d2),\\n                getW(wR, wC, \" + inputDepthNearestVec4 + \" + 2, d2)\\n              );\\n              dotProd += dot(xValues, wValues);\\n            }\\n          }\\n        }\\n        \" + biasSnippet + \"\\n        setOutput(dotProd);\\n      }\\n    \";\n    }\n    return Conv2DProgram;\n}());\nexports.Conv2DProgram = Conv2DProgram;\n//# sourceMappingURL=conv_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvY29udl9ncHUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvY29udl9ncHUuanM/N2VhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDb252MkRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb252MkRQcm9ncmFtKGNvbnZJbmZvLCBoYXNCaWFzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCcsICdXJ107XG4gICAgICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnYmlhcycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICAgICAgdmFyIGJpYXNTbmlwcGV0ID0gaGFzQmlhcyA/ICdkb3RQcm9kICs9IGdldEJpYXMoZDIpOycgOiAnJztcbiAgICAgICAgdmFyIF9hID0gY29udkluZm8uaW5TaGFwZSwgeE51bVJvd3MgPSBfYVswXSwgeE51bUNvbHMgPSBfYVsxXSwgaW5wdXREZXB0aCA9IF9hWzJdO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHRoaXMucGFyYW1zID0gW3N0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIGhhc0JpYXMsIHBhZExlZnQsIHBhZFRvcF07XG4gICAgICAgIHZhciBpbnB1dERlcHRoTmVhcmVzdFZlYzQgPSBNYXRoLmZsb29yKGlucHV0RGVwdGggLyA0KSAqIDQ7XG4gICAgICAgIHZhciBpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9IGlucHV0RGVwdGggJSA0O1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIgKyBzdHJpZGVIZWlnaHQgKyBcIiwgXCIgKyBzdHJpZGVXaWR0aCArIFwiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGQyID0gY29vcmRzLno7XFxuXFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueHkgKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBnZXQgeSh5UiwgeUMsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGZpbHRlckhlaWdodCArIFwiOyB3UisrKSB7XFxuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XFxuXFxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIgKyB4TnVtUm93cyArIFwiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0M7XFxuXFxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIHhOdW1Db2xzICsgXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCBkMSA9IDA7IGQxIDwgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIjsgZDEgKz0gNCkge1xcbiAgICAgICAgICAgICAgdmVjNCB4VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0WCh4UiwgeEMsIGQxKSxcXG4gICAgICAgICAgICAgICAgZ2V0WCh4UiwgeEMsIGQxICsgMSksXFxuICAgICAgICAgICAgICAgIGdldFgoeFIsIHhDLCBkMSArIDIpLFxcbiAgICAgICAgICAgICAgICBnZXRYKHhSLCB4QywgZDEgKyAzKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIHZlYzQgd1ZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMywgZDIpXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChcIiArIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPVxcbiAgICAgICAgICAgICAgICBnZXRYKHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIikgKlxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiwgZDIpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDIpICsgXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzIgeFZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgIGdldFgoeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiKSxcXG4gICAgICAgICAgICAgICAgZ2V0WCh4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAxKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIHZlYzIgd1ZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMSwgZDIpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIiArIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PT0gMykgKyBcIikge1xcbiAgICAgICAgICAgICAgdmVjMyB4VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgZ2V0WCh4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIpLFxcbiAgICAgICAgICAgICAgICBnZXRYKHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDEpLFxcbiAgICAgICAgICAgICAgICBnZXRYKHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDIpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgdmVjMyB3VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMiwgZDIpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBcIiArIGJpYXNTbmlwcGV0ICsgXCJcXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29udjJEUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNvbnYyRFByb2dyYW0gPSBDb252MkRQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udl9ncHUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/conv_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/copy_gpu.js":
/*!****************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/copy_gpu.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Copy2DProgram = (function () {\n    function Copy2DProgram(srcNumCols, destNumCols) {\n        this.variableNames = ['source'];\n        this.outputShape = null;\n        this.params = [srcNumCols, destNumCols];\n        this.userCode = \"\\n      uniform ivec2 sourceStart;\\n      uniform ivec2 destStart;\\n\\n      void main() {\\n        ivec2 destCoords = getOutputCoords() - destStart;\\n        int index = destCoords.x * \" + destNumCols + \" + destCoords.y;\\n        int r = index / \" + srcNumCols + \";\\n        ivec2 sourceCoords = sourceStart + ivec2(r, index - r * \" + srcNumCols + \");\\n        setOutput(getSource(sourceCoords.x, sourceCoords.y));\\n      }\\n    \";\n    }\n    Copy2DProgram.prototype.getCustomSetupFunc = function (sourceStart, destStart, destSize) {\n        return function (gpgpu, webGLProgram) {\n            gpgpu.setOutputMatrixWriteRegion(destStart[0], destSize[0], destStart[1], destSize[1]);\n            var sourceStartCRLoc = gpgpu.getUniformLocation(webGLProgram, 'sourceStart');\n            gpgpu.gl.uniform2i(sourceStartCRLoc, sourceStart[0], sourceStart[1]);\n            var destStartCRLoc = gpgpu.getUniformLocation(webGLProgram, 'destStart');\n            gpgpu.gl.uniform2i(destStartCRLoc, destStart[0], destStart[1]);\n        };\n    };\n    return Copy2DProgram;\n}());\nexports.Copy2DProgram = Copy2DProgram;\n//# sourceMappingURL=copy_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvY29weV9ncHUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvY29weV9ncHUuanM/NDZiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDb3B5MkRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb3B5MkRQcm9ncmFtKHNyY051bUNvbHMsIGRlc3ROdW1Db2xzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnc291cmNlJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtzcmNOdW1Db2xzLCBkZXN0TnVtQ29sc107XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHVuaWZvcm0gaXZlYzIgc291cmNlU3RhcnQ7XFxuICAgICAgdW5pZm9ybSBpdmVjMiBkZXN0U3RhcnQ7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgZGVzdENvb3JkcyA9IGdldE91dHB1dENvb3JkcygpIC0gZGVzdFN0YXJ0O1xcbiAgICAgICAgaW50IGluZGV4ID0gZGVzdENvb3Jkcy54ICogXCIgKyBkZXN0TnVtQ29scyArIFwiICsgZGVzdENvb3Jkcy55O1xcbiAgICAgICAgaW50IHIgPSBpbmRleCAvIFwiICsgc3JjTnVtQ29scyArIFwiO1xcbiAgICAgICAgaXZlYzIgc291cmNlQ29vcmRzID0gc291cmNlU3RhcnQgKyBpdmVjMihyLCBpbmRleCAtIHIgKiBcIiArIHNyY051bUNvbHMgKyBcIik7XFxuICAgICAgICBzZXRPdXRwdXQoZ2V0U291cmNlKHNvdXJjZUNvb3Jkcy54LCBzb3VyY2VDb29yZHMueSkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIENvcHkyRFByb2dyYW0ucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYyA9IGZ1bmN0aW9uIChzb3VyY2VTdGFydCwgZGVzdFN0YXJ0LCBkZXN0U2l6ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdwZ3B1LCB3ZWJHTFByb2dyYW0pIHtcbiAgICAgICAgICAgIGdwZ3B1LnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uKGRlc3RTdGFydFswXSwgZGVzdFNpemVbMF0sIGRlc3RTdGFydFsxXSwgZGVzdFNpemVbMV0pO1xuICAgICAgICAgICAgdmFyIHNvdXJjZVN0YXJ0Q1JMb2MgPSBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCAnc291cmNlU3RhcnQnKTtcbiAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0yaShzb3VyY2VTdGFydENSTG9jLCBzb3VyY2VTdGFydFswXSwgc291cmNlU3RhcnRbMV0pO1xuICAgICAgICAgICAgdmFyIGRlc3RTdGFydENSTG9jID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgJ2Rlc3RTdGFydCcpO1xuICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTJpKGRlc3RTdGFydENSTG9jLCBkZXN0U3RhcnRbMF0sIGRlc3RTdGFydFsxXSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29weTJEUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNvcHkyRFByb2dyYW0gPSBDb3B5MkRQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29weV9ncHUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/copy_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/gpgpu_context.js":
/*!*********************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/gpgpu_context.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar environment_1 = __webpack_require__(/*! ../../environment */ \"./node_modules/deeplearn/dist/src/environment.js\");\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar gpgpu_util = __webpack_require__(/*! ./gpgpu_util */ \"./node_modules/deeplearn/dist/src/math/webgl/gpgpu_util.js\");\nvar tex_util = __webpack_require__(/*! ./tex_util */ \"./node_modules/deeplearn/dist/src/math/webgl/tex_util.js\");\nvar webgl_util = __webpack_require__(/*! ./webgl_util */ \"./node_modules/deeplearn/dist/src/math/webgl/webgl_util.js\");\nvar GPGPUContext = (function () {\n    function GPGPUContext(gl) {\n        this.outputTexture = null;\n        this.program = null;\n        this.disposed = false;\n        this.autoDebugValidate = false;\n        if (gl != null) {\n            this.gl = gl;\n        }\n        else {\n            this.gl = gpgpu_util.createWebGLContext();\n        }\n        if (environment_1.ENV.get('WEBGL_VERSION') === 1) {\n            this.textureFloatExtension =\n                webgl_util.getExtensionOrThrow(this.gl, 'OES_texture_float');\n            this.colorBufferFloatExtension =\n                this.gl.getExtension('WEBGL_color_buffer_float');\n        }\n        else {\n            this.colorBufferFloatExtension =\n                webgl_util.getExtensionOrThrow(this.gl, 'EXT_color_buffer_float');\n        }\n        this.loseContextExtension =\n            webgl_util.getExtensionOrThrow(this.gl, 'WEBGL_lose_context');\n        this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n        this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n        this.framebuffer = webgl_util.createFramebuffer(this.gl);\n    }\n    GPGPUContext.prototype.dispose = function () {\n        var _this = this;\n        this.throwIfDisposed();\n        if (this.program != null) {\n            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +\n                ' This is probably a resource leak, delete the program with ' +\n                'GPGPUContext.deleteProgram before disposing.');\n        }\n        if (this.outputTexture != null) {\n            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +\n                'texture.  This is probably a resource leak, delete the output ' +\n                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +\n                'disposing.');\n        }\n        var gl = this.gl;\n        webgl_util.callAndCheck(gl, function () { return gl.finish(); });\n        webgl_util.callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });\n        webgl_util.callAndCheck(gl, function () { return gl.deleteFramebuffer(_this.framebuffer); });\n        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, null); });\n        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.vertexBuffer); });\n        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); });\n        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.indexBuffer); });\n        this.loseContextExtension.loseContext();\n        this.disposed = true;\n    };\n    GPGPUContext.prototype.enableAutomaticDebugValidation = function (enabled) {\n        this.autoDebugValidate = enabled;\n        webgl_util.enableDebugWebGLErrorChecking(enabled);\n    };\n    GPGPUContext.prototype.createMatrixTexture = function (rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createMatrixTexture(this.gl, rows, columns);\n    };\n    GPGPUContext.prototype.uploadPixelDataToTexture = function (texture, pixels) {\n        this.throwIfDisposed();\n        gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n    };\n    GPGPUContext.prototype.createPackedMatrixTexture = function (rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns);\n    };\n    GPGPUContext.prototype.deleteMatrixTexture = function (texture) {\n        var _this = this;\n        this.throwIfDisposed();\n        if (this.outputTexture === texture) {\n            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n            this.outputTexture = null;\n        }\n        webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteTexture(texture); });\n    };\n    GPGPUContext.prototype.uploadMatrixToTexture = function (texture, rows, columns, matrix) {\n        this.throwIfDisposed();\n        var numChannels = 1;\n        return gpgpu_util.uploadMatrixToTexture(this.gl, texture, rows, columns, matrix, numChannels);\n    };\n    GPGPUContext.prototype.uploadMatrixToPackedTexture = function (texture, rows, columns, matrix) {\n        this.throwIfDisposed();\n        return gpgpu_util.uploadMatrixToPackedTexture(this.gl, texture, rows, columns, matrix);\n    };\n    GPGPUContext.prototype.downloadMatrixFromTexture = function (texture, rows, columns) {\n        var _this = this;\n        return this.downloadMatrixDriver(texture, function () {\n            return gpgpu_util.downloadMatrixFromOutputTexture(_this.gl, rows, columns);\n        });\n    };\n    GPGPUContext.prototype.downloadMatrixFromPackedTexture = function (texture, rows, columns) {\n        var _this = this;\n        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this.gl, rows, columns); });\n    };\n    GPGPUContext.prototype.createProgram = function (fragmentShaderSource) {\n        this.throwIfDisposed();\n        var gl = this.gl;\n        var fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);\n        var vertexShader = gpgpu_util.createVertexShader(gl);\n        var program = webgl_util.createProgram(gl);\n        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, vertexShader); });\n        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, fragmentShader); });\n        webgl_util.linkProgram(gl, program);\n        if (this.autoDebugValidate) {\n            webgl_util.validateProgram(gl, program);\n        }\n        return program;\n    };\n    GPGPUContext.prototype.deleteProgram = function (program) {\n        var _this = this;\n        this.throwIfDisposed();\n        if (program === this.program) {\n            this.program = null;\n        }\n        if (program != null) {\n            webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteProgram(program); });\n        }\n    };\n    GPGPUContext.prototype.setProgram = function (program) {\n        var _this = this;\n        this.throwIfDisposed();\n        this.program = program;\n        if ((this.program != null) && this.autoDebugValidate) {\n            webgl_util.validateProgram(this.gl, this.program);\n        }\n        webgl_util.callAndCheck(this.gl, function () { return _this.gl.useProgram(program); });\n    };\n    GPGPUContext.prototype.getUniformLocation = function (program, uniformName) {\n        this.throwIfDisposed();\n        return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);\n    };\n    GPGPUContext.prototype.getAttributeLocation = function (program, attribute) {\n        var _this = this;\n        this.throwIfDisposed();\n        return webgl_util.callAndCheck(this.gl, function () { return _this.gl.getAttribLocation(program, attribute); });\n    };\n    GPGPUContext.prototype.getUniformLocationNoThrow = function (program, uniformName) {\n        this.throwIfDisposed();\n        return this.gl.getUniformLocation(program, uniformName);\n    };\n    GPGPUContext.prototype.setInputMatrixTexture = function (inputMatrixTexture, uniformLocation, textureUnit) {\n        this.throwIfDisposed();\n        this.throwIfNoProgram();\n        webgl_util.bindTextureToProgramUniformSampler(this.gl, this.program, inputMatrixTexture, uniformLocation, textureUnit);\n    };\n    GPGPUContext.prototype.setOutputMatrixTexture = function (outputMatrixTexture, rows, columns) {\n        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n    };\n    GPGPUContext.prototype.setOutputPackedMatrixTexture = function (outputPackedMatrixTexture, rows, columns) {\n        this.throwIfDisposed();\n        var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];\n        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n    };\n    GPGPUContext.prototype.setOutputMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {\n        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);\n    };\n    GPGPUContext.prototype.setOutputPackedMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {\n        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n    };\n    GPGPUContext.prototype.debugValidate = function () {\n        if (this.program != null) {\n            webgl_util.validateProgram(this.gl, this.program);\n        }\n        webgl_util.validateFramebuffer(this.gl);\n    };\n    GPGPUContext.prototype.executeProgram = function (attribLocations) {\n        this.throwIfDisposed();\n        this.throwIfNoProgram();\n        var gl = this.gl;\n        gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer, attribLocations);\n        if (this.autoDebugValidate) {\n            this.debugValidate();\n        }\n        webgl_util.callAndCheck(gl, function () { return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); });\n    };\n    GPGPUContext.prototype.blockUntilAllProgramsCompleted = function () {\n        var _this = this;\n        this.throwIfDisposed();\n        webgl_util.callAndCheck(this.gl, function () { return _this.gl.finish(); });\n    };\n    GPGPUContext.prototype.runQuery = function (queryFn) {\n        if (environment_1.ENV.get('WEBGL_VERSION') === 2) {\n            return this.runQueryWebGL2(queryFn);\n        }\n        return this.runQueryWebGL1(queryFn);\n    };\n    GPGPUContext.prototype.runQueryWebGL2 = function (benchmark) {\n        var _this = this;\n        var ext = webgl_util.getExtensionOrThrow(this.gl, 'EXT_disjoint_timer_query_webgl2');\n        var query = this.gl.createQuery();\n        this.gl.beginQuery(ext.TIME_ELAPSED_EXT, query);\n        benchmark();\n        this.gl.endQuery(ext.TIME_ELAPSED_EXT);\n        return new Promise(function (resolve, reject) {\n            var queryGPU = function () {\n                var available = _this.gl\n                    .getQueryParameter(query, _this.gl.QUERY_RESULT_AVAILABLE);\n                var disjoint = _this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n                return available && !disjoint;\n            };\n            var getTimeElapsed = function () {\n                var timeElapsedNanos = _this.gl\n                    .getQueryParameter(query, _this.gl.QUERY_RESULT);\n                resolve(timeElapsedNanos / 1000000);\n            };\n            var resolveWithWarning = function () {\n                console.warn('Disjoint query timer never available.');\n                resolve(-1);\n            };\n            util.repeatedTry(queryGPU).then(getTimeElapsed).catch(resolveWithWarning);\n        });\n    };\n    GPGPUContext.prototype.runQueryWebGL1 = function (benchmark) {\n        var _this = this;\n        var ext = webgl_util.getExtensionOrThrow(this.gl, 'EXT_disjoint_timer_query');\n        var query = ext.createQueryEXT();\n        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n        benchmark();\n        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n        return new Promise(function (resolve, reject) {\n            var queryGPU = function () {\n                var available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n                var disjoint = _this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n                return available && !disjoint;\n            };\n            var getTimeElapsed = function () {\n                var timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);\n                resolve(timeElapsedNanos / 1000000);\n            };\n            var resolveWithWarning = function () {\n                console.warn('Disjoint query timer never available.');\n                resolve(-1);\n            };\n            util.repeatedTry(queryGPU).then(getTimeElapsed).catch(resolveWithWarning);\n        });\n    };\n    GPGPUContext.prototype.downloadMatrixDriver = function (texture, downloadAndDecode) {\n        this.throwIfDisposed();\n        webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);\n        if (this.autoDebugValidate) {\n            webgl_util.validateFramebuffer(this.gl);\n        }\n        var result = downloadAndDecode();\n        if (this.outputTexture != null) {\n            webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);\n            if (this.autoDebugValidate) {\n                webgl_util.validateFramebuffer(this.gl);\n            }\n        }\n        else {\n            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n        }\n        return result;\n    };\n    GPGPUContext.prototype.setOutputMatrixTextureDriver = function (outputMatrixTextureMaybePacked, width, height) {\n        this.throwIfDisposed();\n        var gl = this.gl;\n        webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);\n        if (this.autoDebugValidate) {\n            webgl_util.validateFramebuffer(gl);\n        }\n        this.outputTexture = outputMatrixTextureMaybePacked;\n        webgl_util.callAndCheck(gl, function () { return gl.viewport(0, 0, width, height); });\n        webgl_util.callAndCheck(gl, function () { return gl.scissor(0, 0, width, height); });\n    };\n    GPGPUContext.prototype.setOutputMatrixWriteRegionDriver = function (x, y, width, height) {\n        var _this = this;\n        this.throwIfDisposed();\n        webgl_util.callAndCheck(this.gl, function () { return _this.gl.scissor(x, y, width, height); });\n    };\n    GPGPUContext.prototype.throwIfDisposed = function () {\n        if (this.disposed) {\n            throw new Error('Attempted to use disposed GPGPUContext.');\n        }\n    };\n    GPGPUContext.prototype.throwIfNoProgram = function () {\n        if (this.program == null) {\n            throw new Error('No GPU program is currently set.');\n        }\n    };\n    return GPGPUContext;\n}());\nexports.GPGPUContext = GPGPUContext;\n//# sourceMappingURL=gpgpu_context.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvZ3BncHVfY29udGV4dC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9ncGdwdV9jb250ZXh0LmpzPzY1NWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3BncHVfdXRpbCA9IHJlcXVpcmUoXCIuL2dwZ3B1X3V0aWxcIik7XG52YXIgdGV4X3V0aWwgPSByZXF1aXJlKFwiLi90ZXhfdXRpbFwiKTtcbnZhciB3ZWJnbF91dGlsID0gcmVxdWlyZShcIi4vd2ViZ2xfdXRpbFwiKTtcbnZhciBHUEdQVUNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdQR1BVQ29udGV4dChnbCkge1xuICAgICAgICB0aGlzLm91dHB1dFRleHR1cmUgPSBudWxsO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGdsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2wgPSBncGdwdV91dGlsLmNyZWF0ZVdlYkdMQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24gPVxuICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwuZ2V0RXh0ZW5zaW9uT3JUaHJvdyh0aGlzLmdsLCAnT0VTX3RleHR1cmVfZmxvYXQnKTtcbiAgICAgICAgICAgIHRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbiA9XG4gICAgICAgICAgICAgICAgdGhpcy5nbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uID1cbiAgICAgICAgICAgICAgICB3ZWJnbF91dGlsLmdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvc2VDb250ZXh0RXh0ZW5zaW9uID1cbiAgICAgICAgICAgIHdlYmdsX3V0aWwuZ2V0RXh0ZW5zaW9uT3JUaHJvdyh0aGlzLmdsLCAnV0VCR0xfbG9zZV9jb250ZXh0Jyk7XG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyID0gZ3BncHVfdXRpbC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5nbCk7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBncGdwdV91dGlsLmNyZWF0ZUluZGV4QnVmZmVyKHRoaXMuZ2wpO1xuICAgICAgICB0aGlzLmZyYW1lYnVmZmVyID0gd2ViZ2xfdXRpbC5jcmVhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgICB9XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBpZiAodGhpcy5wcm9ncmFtICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGlzcG9zaW5nIGEgR1BHUFVDb250ZXh0IHRoYXQgc3RpbGwgaGFzIGEgYm91bmQgV2ViR0xQcm9ncmFtLicgK1xuICAgICAgICAgICAgICAgICcgVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgcHJvZ3JhbSB3aXRoICcgK1xuICAgICAgICAgICAgICAgICdHUEdQVUNvbnRleHQuZGVsZXRlUHJvZ3JhbSBiZWZvcmUgZGlzcG9zaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm91dHB1dFRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEaXNwb3NpbmcgYSBHUEdQVUNvbnRleHQgdGhhdCBzdGlsbCBoYXMgYSBib3VuZCBvdXRwdXQgbWF0cml4ICcgK1xuICAgICAgICAgICAgICAgICd0ZXh0dXJlLiAgVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgb3V0cHV0ICcgK1xuICAgICAgICAgICAgICAgICdtYXRyaXggdGV4dHVyZSB3aXRoIEdQR1BVQ29udGV4dC5kZWxldGVNYXRyaXhUZXh0dXJlIGJlZm9yZSAnICtcbiAgICAgICAgICAgICAgICAnZGlzcG9zaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5maW5pc2goKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKF90aGlzLmZyYW1lYnVmZmVyKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGVsZXRlQnVmZmVyKF90aGlzLnZlcnRleEJ1ZmZlcik7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGVsZXRlQnVmZmVyKF90aGlzLmluZGV4QnVmZmVyKTsgfSk7XG4gICAgICAgIHRoaXMubG9zZUNvbnRleHRFeHRlbnNpb24ubG9zZUNvbnRleHQoKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmVuYWJsZUF1dG9tYXRpY0RlYnVnVmFsaWRhdGlvbiA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgIHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUgPSBlbmFibGVkO1xuICAgICAgICB3ZWJnbF91dGlsLmVuYWJsZURlYnVnV2ViR0xFcnJvckNoZWNraW5nKGVuYWJsZWQpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5jcmVhdGVNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIGdwZ3B1X3V0aWwuY3JlYXRlTWF0cml4VGV4dHVyZSh0aGlzLmdsLCByb3dzLCBjb2x1bW5zKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUudXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHBpeGVscykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBncGdwdV91dGlsLnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSh0aGlzLmdsLCB0ZXh0dXJlLCBwaXhlbHMpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIGdwZ3B1X3V0aWwuY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZSh0aGlzLmdsLCByb3dzLCBjb2x1bW5zKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZGVsZXRlTWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dFRleHR1cmUgPT09IHRleHR1cmUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyKHRoaXMuZ2wsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRleHR1cmUpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUudXBsb2FkTWF0cml4VG9UZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB2YXIgbnVtQ2hhbm5lbHMgPSAxO1xuICAgICAgICByZXR1cm4gZ3BncHVfdXRpbC51cGxvYWRNYXRyaXhUb1RleHR1cmUodGhpcy5nbCwgdGV4dHVyZSwgcm93cywgY29sdW1ucywgbWF0cml4LCBudW1DaGFubmVscyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIGdwZ3B1X3V0aWwudXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlKHRoaXMuZ2wsIHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RnJvbVRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcm93cywgY29sdW1ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcih0ZXh0dXJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3BncHVfdXRpbC5kb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlKF90aGlzLmdsLCByb3dzLCBjb2x1bW5zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZFRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcm93cywgY29sdW1ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcih0ZXh0dXJlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBncGdwdV91dGlsLmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmUoX3RoaXMuZ2wsIHJvd3MsIGNvbHVtbnMpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlUHJvZ3JhbSA9IGZ1bmN0aW9uIChmcmFnbWVudFNoYWRlclNvdXJjZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSB3ZWJnbF91dGlsLmNyZWF0ZUZyYWdtZW50U2hhZGVyKGdsLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBncGdwdV91dGlsLmNyZWF0ZVZlcnRleFNoYWRlcihnbCk7XG4gICAgICAgIHZhciBwcm9ncmFtID0gd2ViZ2xfdXRpbC5jcmVhdGVQcm9ncmFtKGdsKTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmxpbmtQcm9ncmFtKGdsLCBwcm9ncmFtKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVQcm9ncmFtKGdsLCBwcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZGVsZXRlUHJvZ3JhbSA9IGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmIChwcm9ncmFtID09PSB0aGlzLnByb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0UHJvZ3JhbSA9IGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIGlmICgodGhpcy5wcm9ncmFtICE9IG51bGwpICYmIHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVQcm9ncmFtKHRoaXMuZ2wsIHRoaXMucHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmdldFVuaWZvcm1Mb2NhdGlvbiA9IGZ1bmN0aW9uIChwcm9ncmFtLCB1bmlmb3JtTmFtZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gd2ViZ2xfdXRpbC5nZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdyh0aGlzLmdsLCBwcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmdldEF0dHJpYnV0ZUxvY2F0aW9uID0gZnVuY3Rpb24gKHByb2dyYW0sIGF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmlidXRlKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cgPSBmdW5jdGlvbiAocHJvZ3JhbSwgdW5pZm9ybU5hbWUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKGlucHV0TWF0cml4VGV4dHVyZSwgdW5pZm9ybUxvY2F0aW9uLCB0ZXh0dXJlVW5pdCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLnRocm93SWZOb1Byb2dyYW0oKTtcbiAgICAgICAgd2ViZ2xfdXRpbC5iaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyKHRoaXMuZ2wsIHRoaXMucHJvZ3JhbSwgaW5wdXRNYXRyaXhUZXh0dXJlLCB1bmlmb3JtTG9jYXRpb24sIHRleHR1cmVVbml0KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uIChvdXRwdXRNYXRyaXhUZXh0dXJlLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcihvdXRwdXRNYXRyaXhUZXh0dXJlLCBjb2x1bW5zLCByb3dzKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uIChvdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHZhciBfYSA9IHRleF91dGlsLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3aWR0aCA9IF9hWzBdLCBoZWlnaHQgPSBfYVsxXTtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyKG91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmUsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbiA9IGZ1bmN0aW9uIChzdGFydFJvdywgbnVtUm93cywgc3RhcnRDb2x1bW4sIG51bUNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbkRyaXZlcihzdGFydENvbHVtbiwgc3RhcnRSb3csIG51bUNvbHVtbnMsIG51bVJvd3MpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbiA9IGZ1bmN0aW9uIChzdGFydFJvdywgbnVtUm93cywgc3RhcnRDb2x1bW4sIG51bUNvbHVtbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbiBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRlYnVnVmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb2dyYW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZVByb2dyYW0odGhpcy5nbCwgdGhpcy5wcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlRnJhbWVidWZmZXIodGhpcy5nbCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmV4ZWN1dGVQcm9ncmFtID0gZnVuY3Rpb24gKGF0dHJpYkxvY2F0aW9ucykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLnRocm93SWZOb1Byb2dyYW0oKTtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ3BncHVfdXRpbC5iaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXMoZ2wsIHRoaXMucHJvZ3JhbSwgdGhpcy52ZXJ0ZXhCdWZmZXIsIGF0dHJpYkxvY2F0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnVmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDApOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuYmxvY2tVbnRpbEFsbFByb2dyYW1zQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC5maW5pc2goKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnJ1blF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5Rm4pIHtcbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5RdWVyeVdlYkdMMihxdWVyeUZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ydW5RdWVyeVdlYkdMMShxdWVyeUZuKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUucnVuUXVlcnlXZWJHTDIgPSBmdW5jdGlvbiAoYmVuY2htYXJrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBleHQgPSB3ZWJnbF91dGlsLmdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInKTtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5nbC5jcmVhdGVRdWVyeSgpO1xuICAgICAgICB0aGlzLmdsLmJlZ2luUXVlcnkoZXh0LlRJTUVfRUxBUFNFRF9FWFQsIHF1ZXJ5KTtcbiAgICAgICAgYmVuY2htYXJrKCk7XG4gICAgICAgIHRoaXMuZ2wuZW5kUXVlcnkoZXh0LlRJTUVfRUxBUFNFRF9FWFQpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5R1BVID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhdmFpbGFibGUgPSBfdGhpcy5nbFxuICAgICAgICAgICAgICAgICAgICAuZ2V0UXVlcnlQYXJhbWV0ZXIocXVlcnksIF90aGlzLmdsLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEUpO1xuICAgICAgICAgICAgICAgIHZhciBkaXNqb2ludCA9IF90aGlzLmdsLmdldFBhcmFtZXRlcihleHQuR1BVX0RJU0pPSU5UX0VYVCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZSAmJiAhZGlzam9pbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGdldFRpbWVFbGFwc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lRWxhcHNlZE5hbm9zID0gX3RoaXMuZ2xcbiAgICAgICAgICAgICAgICAgICAgLmdldFF1ZXJ5UGFyYW1ldGVyKHF1ZXJ5LCBfdGhpcy5nbC5RVUVSWV9SRVNVTFQpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGltZUVsYXBzZWROYW5vcyAvIDEwMDAwMDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZXNvbHZlV2l0aFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEaXNqb2ludCBxdWVyeSB0aW1lciBuZXZlciBhdmFpbGFibGUuJyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgtMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdXRpbC5yZXBlYXRlZFRyeShxdWVyeUdQVSkudGhlbihnZXRUaW1lRWxhcHNlZCkuY2F0Y2gocmVzb2x2ZVdpdGhXYXJuaW5nKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnJ1blF1ZXJ5V2ViR0wxID0gZnVuY3Rpb24gKGJlbmNobWFyaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZXh0ID0gd2ViZ2xfdXRpbC5nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsICdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnknKTtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gZXh0LmNyZWF0ZVF1ZXJ5RVhUKCk7XG4gICAgICAgIGV4dC5iZWdpblF1ZXJ5RVhUKGV4dC5USU1FX0VMQVBTRURfRVhULCBxdWVyeSk7XG4gICAgICAgIGJlbmNobWFyaygpO1xuICAgICAgICBleHQuZW5kUXVlcnlFWFQoZXh0LlRJTUVfRUxBUFNFRF9FWFQpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5R1BVID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhdmFpbGFibGUgPSBleHQuZ2V0UXVlcnlPYmplY3RFWFQocXVlcnksIGV4dC5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFX0VYVCk7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2pvaW50ID0gX3RoaXMuZ2wuZ2V0UGFyYW1ldGVyKGV4dC5HUFVfRElTSk9JTlRfRVhUKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlICYmICFkaXNqb2ludDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZ2V0VGltZUVsYXBzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVFbGFwc2VkTmFub3MgPSBleHQuZ2V0UXVlcnlPYmplY3RFWFQocXVlcnksIGV4dC5RVUVSWV9SRVNVTFRfRVhUKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRpbWVFbGFwc2VkTmFub3MgLyAxMDAwMDAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZVdpdGhXYXJuaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGlzam9pbnQgcXVlcnkgdGltZXIgbmV2ZXIgYXZhaWxhYmxlLicpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoLTEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHV0aWwucmVwZWF0ZWRUcnkocXVlcnlHUFUpLnRoZW4oZ2V0VGltZUVsYXBzZWQpLmNhdGNoKHJlc29sdmVXaXRoV2FybmluZyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeERyaXZlciA9IGZ1bmN0aW9uICh0ZXh0dXJlLCBkb3dubG9hZEFuZERlY29kZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB3ZWJnbF91dGlsLmJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKHRoaXMuZ2wsIHRleHR1cmUsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgICBpZiAodGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZUZyYW1lYnVmZmVyKHRoaXMuZ2wpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBkb3dubG9hZEFuZERlY29kZSgpO1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRUZXh0dXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwuYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIodGhpcy5nbCwgdGhpcy5vdXRwdXRUZXh0dXJlLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZUZyYW1lYnVmZmVyKHRoaXMuZ2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC51bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIodGhpcy5nbCwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlciA9IGZ1bmN0aW9uIChvdXRwdXRNYXRyaXhUZXh0dXJlTWF5YmVQYWNrZWQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgd2ViZ2xfdXRpbC5iaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcihnbCwgb3V0cHV0TWF0cml4VGV4dHVyZU1heWJlUGFja2VkLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVGcmFtZWJ1ZmZlcihnbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRwdXRUZXh0dXJlID0gb3V0cHV0TWF0cml4VGV4dHVyZU1heWJlUGFja2VkO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudmlld3BvcnQoMCwgMCwgd2lkdGgsIGhlaWdodCk7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuc2Npc3NvcigwLCAwLCB3aWR0aCwgaGVpZ2h0KTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uRHJpdmVyID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuc2Npc3Nvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnRocm93SWZEaXNwb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHVzZSBkaXNwb3NlZCBHUEdQVUNvbnRleHQuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUudGhyb3dJZk5vUHJvZ3JhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEdQVSBwcm9ncmFtIGlzIGN1cnJlbnRseSBzZXQuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBHUEdQVUNvbnRleHQ7XG59KCkpO1xuZXhwb3J0cy5HUEdQVUNvbnRleHQgPSBHUEdQVUNvbnRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncGdwdV9jb250ZXh0LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/gpgpu_context.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/gpgpu_math.js":
/*!******************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/gpgpu_math.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar environment_1 = __webpack_require__(/*! ../../environment */ \"./node_modules/deeplearn/dist/src/environment.js\");\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar shader_compiler = __webpack_require__(/*! ./shader_compiler */ \"./node_modules/deeplearn/dist/src/math/webgl/shader_compiler.js\");\nvar ATTRIBUTE_NAMES = ['uv', 'clipSpacePos'];\nvar NAN_UNIFORM_NAME = 'NaN';\nfunction shouldUploadNaNUniform() {\n    return !environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');\n}\nfunction compileProgram(gpgpu, program, inputs, output) {\n    var userCode = program.userCode;\n    var inputInfos = inputs.map(function (input, i) {\n        var shapeInfo = {\n            logicalShape: input.shape,\n            texShape: input.getTextureShapeRC()\n        };\n        return { name: program.variableNames[i], shapeInfo: shapeInfo };\n    });\n    var inShapeInfos = inputInfos.map(function (x) { return x.shapeInfo; });\n    var outShapeInfo = {\n        logicalShape: output.shape,\n        texShape: output.getTextureShapeRC()\n    };\n    var source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.supportsBroadcasting === true);\n    var webGLProgram = gpgpu.createProgram(source);\n    var uniformLocations = {};\n    for (var i = 0; i < program.variableNames.length; i++) {\n        var uniformName = program.variableNames[i];\n        uniformLocations[uniformName] =\n            gpgpu.getUniformLocation(webGLProgram, uniformName);\n    }\n    var attributeLocations = {};\n    ATTRIBUTE_NAMES.forEach(function (attribute) {\n        attributeLocations[attribute] =\n            gpgpu.getAttributeLocation(webGLProgram, attribute);\n    });\n    if (shouldUploadNaNUniform()) {\n        uniformLocations[NAN_UNIFORM_NAME] =\n            gpgpu.getUniformLocation(webGLProgram, NAN_UNIFORM_NAME);\n    }\n    return {\n        program: program,\n        source: source,\n        webGLProgram: webGLProgram,\n        uniformLocations: uniformLocations,\n        attributeLocations: attributeLocations,\n        gpgpu: gpgpu,\n        inShapeInfos: inShapeInfos,\n        outShapeInfo: outShapeInfo\n    };\n}\nexports.compileProgram = compileProgram;\nfunction validateBinaryAndProgram(shapeInfos, inputs) {\n    if (shapeInfos.length !== inputs.length) {\n        throw Error(\"Binary was compiled with \" + shapeInfos.length + \" inputs, but \" +\n            (\"was executed with \" + inputs.length + \" inputs\"));\n    }\n    shapeInfos.forEach(function (s, i) {\n        var shapeA = s.logicalShape;\n        var texShapeA = s.texShape;\n        var shapeB = inputs[i].shape;\n        var texShapeB = inputs[i].getTextureShapeRC();\n        if (!util.arraysEqual(shapeA, shapeB)) {\n            throw Error(\"Binary was compiled with different shapes than \" +\n                (\"the current args. Shapes \" + shapeA + \" and \" + shapeB + \" must match\"));\n        }\n        if (!util.arraysEqual(texShapeA, texShapeB)) {\n            throw Error(\"Binary was compiled with different texture shapes than the\" +\n                (\" current args. Shape \" + texShapeA + \" and \" + texShapeB + \" must match\"));\n        }\n    });\n}\nfunction runProgram(binary, inputs, output, customSetup) {\n    validateBinaryAndProgram(binary.inShapeInfos, inputs);\n    validateBinaryAndProgram([binary.outShapeInfo], [output]);\n    var outTex = output.getTexture();\n    var outTexShape = output.getTextureShapeRC();\n    var gpgpu = binary.gpgpu;\n    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n    gpgpu.setProgram(binary.webGLProgram);\n    inputs.forEach(function (input, i) {\n        var tex = input.getTexture();\n        var variableName = binary.program.variableNames[i];\n        var variableUniformLocation = binary.uniformLocations[variableName];\n        gpgpu.setInputMatrixTexture(tex, variableUniformLocation, i);\n    });\n    if (shouldUploadNaNUniform()) {\n        gpgpu.gl.uniform1f(binary.uniformLocations[NAN_UNIFORM_NAME], NaN);\n    }\n    if (customSetup != null) {\n        customSetup(gpgpu, binary.webGLProgram);\n    }\n    gpgpu.executeProgram(binary.attributeLocations);\n}\nexports.runProgram = runProgram;\nfunction makeShaderKey(program, inputs, output) {\n    var params = program.params;\n    var keyStart = inputs.concat(output).map(function (x) { return x.shape + '_' + x.getTextureShapeRC(); });\n    var keyEnd = params.map(String);\n    var key = [program.constructor.name];\n    key.push((program.supportsBroadcasting === true).toString());\n    key = key.concat(keyStart, keyEnd);\n    return key.join('_');\n}\nexports.makeShaderKey = makeShaderKey;\n//# sourceMappingURL=gpgpu_math.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvZ3BncHVfbWF0aC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9ncGdwdV9tYXRoLmpzPzYyZmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgc2hhZGVyX2NvbXBpbGVyID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIEFUVFJJQlVURV9OQU1FUyA9IFsndXYnLCAnY2xpcFNwYWNlUG9zJ107XG52YXIgTkFOX1VOSUZPUk1fTkFNRSA9ICdOYU4nO1xuZnVuY3Rpb24gc2hvdWxkVXBsb2FkTmFOVW5pZm9ybSgpIHtcbiAgICByZXR1cm4gIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJyk7XG59XG5mdW5jdGlvbiBjb21waWxlUHJvZ3JhbShncGdwdSwgcHJvZ3JhbSwgaW5wdXRzLCBvdXRwdXQpIHtcbiAgICB2YXIgdXNlckNvZGUgPSBwcm9ncmFtLnVzZXJDb2RlO1xuICAgIHZhciBpbnB1dEluZm9zID0gaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQsIGkpIHtcbiAgICAgICAgdmFyIHNoYXBlSW5mbyA9IHtcbiAgICAgICAgICAgIGxvZ2ljYWxTaGFwZTogaW5wdXQuc2hhcGUsXG4gICAgICAgICAgICB0ZXhTaGFwZTogaW5wdXQuZ2V0VGV4dHVyZVNoYXBlUkMoKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBuYW1lOiBwcm9ncmFtLnZhcmlhYmxlTmFtZXNbaV0sIHNoYXBlSW5mbzogc2hhcGVJbmZvIH07XG4gICAgfSk7XG4gICAgdmFyIGluU2hhcGVJbmZvcyA9IGlucHV0SW5mb3MubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNoYXBlSW5mbzsgfSk7XG4gICAgdmFyIG91dFNoYXBlSW5mbyA9IHtcbiAgICAgICAgbG9naWNhbFNoYXBlOiBvdXRwdXQuc2hhcGUsXG4gICAgICAgIHRleFNoYXBlOiBvdXRwdXQuZ2V0VGV4dHVyZVNoYXBlUkMoKVxuICAgIH07XG4gICAgdmFyIHNvdXJjZSA9IHNoYWRlcl9jb21waWxlci5tYWtlU2hhZGVyKGlucHV0SW5mb3MsIG91dFNoYXBlSW5mbywgdXNlckNvZGUsIHByb2dyYW0uc3VwcG9ydHNCcm9hZGNhc3RpbmcgPT09IHRydWUpO1xuICAgIHZhciB3ZWJHTFByb2dyYW0gPSBncGdwdS5jcmVhdGVQcm9ncmFtKHNvdXJjZSk7XG4gICAgdmFyIHVuaWZvcm1Mb2NhdGlvbnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2dyYW0udmFyaWFibGVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdW5pZm9ybU5hbWUgPSBwcm9ncmFtLnZhcmlhYmxlTmFtZXNbaV07XG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnNbdW5pZm9ybU5hbWVdID1cbiAgICAgICAgICAgIGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgICB9XG4gICAgdmFyIGF0dHJpYnV0ZUxvY2F0aW9ucyA9IHt9O1xuICAgIEFUVFJJQlVURV9OQU1FUy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgYXR0cmlidXRlTG9jYXRpb25zW2F0dHJpYnV0ZV0gPVxuICAgICAgICAgICAgZ3BncHUuZ2V0QXR0cmlidXRlTG9jYXRpb24od2ViR0xQcm9ncmFtLCBhdHRyaWJ1dGUpO1xuICAgIH0pO1xuICAgIGlmIChzaG91bGRVcGxvYWROYU5Vbmlmb3JtKCkpIHtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9uc1tOQU5fVU5JRk9STV9OQU1FXSA9XG4gICAgICAgICAgICBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCBOQU5fVU5JRk9STV9OQU1FKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHdlYkdMUHJvZ3JhbTogd2ViR0xQcm9ncmFtLFxuICAgICAgICB1bmlmb3JtTG9jYXRpb25zOiB1bmlmb3JtTG9jYXRpb25zLFxuICAgICAgICBhdHRyaWJ1dGVMb2NhdGlvbnM6IGF0dHJpYnV0ZUxvY2F0aW9ucyxcbiAgICAgICAgZ3BncHU6IGdwZ3B1LFxuICAgICAgICBpblNoYXBlSW5mb3M6IGluU2hhcGVJbmZvcyxcbiAgICAgICAgb3V0U2hhcGVJbmZvOiBvdXRTaGFwZUluZm9cbiAgICB9O1xufVxuZXhwb3J0cy5jb21waWxlUHJvZ3JhbSA9IGNvbXBpbGVQcm9ncmFtO1xuZnVuY3Rpb24gdmFsaWRhdGVCaW5hcnlBbmRQcm9ncmFtKHNoYXBlSW5mb3MsIGlucHV0cykge1xuICAgIGlmIChzaGFwZUluZm9zLmxlbmd0aCAhPT0gaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBcIiArIHNoYXBlSW5mb3MubGVuZ3RoICsgXCIgaW5wdXRzLCBidXQgXCIgK1xuICAgICAgICAgICAgKFwid2FzIGV4ZWN1dGVkIHdpdGggXCIgKyBpbnB1dHMubGVuZ3RoICsgXCIgaW5wdXRzXCIpKTtcbiAgICB9XG4gICAgc2hhcGVJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgICAgIHZhciBzaGFwZUEgPSBzLmxvZ2ljYWxTaGFwZTtcbiAgICAgICAgdmFyIHRleFNoYXBlQSA9IHMudGV4U2hhcGU7XG4gICAgICAgIHZhciBzaGFwZUIgPSBpbnB1dHNbaV0uc2hhcGU7XG4gICAgICAgIHZhciB0ZXhTaGFwZUIgPSBpbnB1dHNbaV0uZ2V0VGV4dHVyZVNoYXBlUkMoKTtcbiAgICAgICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKHNoYXBlQSwgc2hhcGVCKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggZGlmZmVyZW50IHNoYXBlcyB0aGFuIFwiICtcbiAgICAgICAgICAgICAgICAoXCJ0aGUgY3VycmVudCBhcmdzLiBTaGFwZXMgXCIgKyBzaGFwZUEgKyBcIiBhbmQgXCIgKyBzaGFwZUIgKyBcIiBtdXN0IG1hdGNoXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwodGV4U2hhcGVBLCB0ZXhTaGFwZUIpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBkaWZmZXJlbnQgdGV4dHVyZSBzaGFwZXMgdGhhbiB0aGVcIiArXG4gICAgICAgICAgICAgICAgKFwiIGN1cnJlbnQgYXJncy4gU2hhcGUgXCIgKyB0ZXhTaGFwZUEgKyBcIiBhbmQgXCIgKyB0ZXhTaGFwZUIgKyBcIiBtdXN0IG1hdGNoXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcnVuUHJvZ3JhbShiaW5hcnksIGlucHV0cywgb3V0cHV0LCBjdXN0b21TZXR1cCkge1xuICAgIHZhbGlkYXRlQmluYXJ5QW5kUHJvZ3JhbShiaW5hcnkuaW5TaGFwZUluZm9zLCBpbnB1dHMpO1xuICAgIHZhbGlkYXRlQmluYXJ5QW5kUHJvZ3JhbShbYmluYXJ5Lm91dFNoYXBlSW5mb10sIFtvdXRwdXRdKTtcbiAgICB2YXIgb3V0VGV4ID0gb3V0cHV0LmdldFRleHR1cmUoKTtcbiAgICB2YXIgb3V0VGV4U2hhcGUgPSBvdXRwdXQuZ2V0VGV4dHVyZVNoYXBlUkMoKTtcbiAgICB2YXIgZ3BncHUgPSBiaW5hcnkuZ3BncHU7XG4gICAgZ3BncHUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShvdXRUZXgsIG91dFRleFNoYXBlWzBdLCBvdXRUZXhTaGFwZVsxXSk7XG4gICAgZ3BncHUuc2V0UHJvZ3JhbShiaW5hcnkud2ViR0xQcm9ncmFtKTtcbiAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQsIGkpIHtcbiAgICAgICAgdmFyIHRleCA9IGlucHV0LmdldFRleHR1cmUoKTtcbiAgICAgICAgdmFyIHZhcmlhYmxlTmFtZSA9IGJpbmFyeS5wcm9ncmFtLnZhcmlhYmxlTmFtZXNbaV07XG4gICAgICAgIHZhciB2YXJpYWJsZVVuaWZvcm1Mb2NhdGlvbiA9IGJpbmFyeS51bmlmb3JtTG9jYXRpb25zW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZSh0ZXgsIHZhcmlhYmxlVW5pZm9ybUxvY2F0aW9uLCBpKTtcbiAgICB9KTtcbiAgICBpZiAoc2hvdWxkVXBsb2FkTmFOVW5pZm9ybSgpKSB7XG4gICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xZihiaW5hcnkudW5pZm9ybUxvY2F0aW9uc1tOQU5fVU5JRk9STV9OQU1FXSwgTmFOKTtcbiAgICB9XG4gICAgaWYgKGN1c3RvbVNldHVwICE9IG51bGwpIHtcbiAgICAgICAgY3VzdG9tU2V0dXAoZ3BncHUsIGJpbmFyeS53ZWJHTFByb2dyYW0pO1xuICAgIH1cbiAgICBncGdwdS5leGVjdXRlUHJvZ3JhbShiaW5hcnkuYXR0cmlidXRlTG9jYXRpb25zKTtcbn1cbmV4cG9ydHMucnVuUHJvZ3JhbSA9IHJ1blByb2dyYW07XG5mdW5jdGlvbiBtYWtlU2hhZGVyS2V5KHByb2dyYW0sIGlucHV0cywgb3V0cHV0KSB7XG4gICAgdmFyIHBhcmFtcyA9IHByb2dyYW0ucGFyYW1zO1xuICAgIHZhciBrZXlTdGFydCA9IGlucHV0cy5jb25jYXQob3V0cHV0KS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2hhcGUgKyAnXycgKyB4LmdldFRleHR1cmVTaGFwZVJDKCk7IH0pO1xuICAgIHZhciBrZXlFbmQgPSBwYXJhbXMubWFwKFN0cmluZyk7XG4gICAgdmFyIGtleSA9IFtwcm9ncmFtLmNvbnN0cnVjdG9yLm5hbWVdO1xuICAgIGtleS5wdXNoKChwcm9ncmFtLnN1cHBvcnRzQnJvYWRjYXN0aW5nID09PSB0cnVlKS50b1N0cmluZygpKTtcbiAgICBrZXkgPSBrZXkuY29uY2F0KGtleVN0YXJ0LCBrZXlFbmQpO1xuICAgIHJldHVybiBrZXkuam9pbignXycpO1xufVxuZXhwb3J0cy5tYWtlU2hhZGVyS2V5ID0gbWFrZVNoYWRlcktleTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdwZ3B1X21hdGguanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/gpgpu_math.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/gpgpu_util.js":
/*!******************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/gpgpu_util.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar environment_1 = __webpack_require__(/*! ../../environment */ \"./node_modules/deeplearn/dist/src/environment.js\");\nvar tex_util = __webpack_require__(/*! ./tex_util */ \"./node_modules/deeplearn/dist/src/math/webgl/tex_util.js\");\nvar webgl_util = __webpack_require__(/*! ./webgl_util */ \"./node_modules/deeplearn/dist/src/math/webgl/webgl_util.js\");\nfunction getWebGLContextAttributes() {\n    return {\n        alpha: false,\n        antialias: false,\n        premultipliedAlpha: false,\n        preserveDrawingBuffer: false,\n        depth: false,\n        stencil: false,\n        failIfMajorPerformanceCaveat: true\n    };\n}\nexports.getWebGLContextAttributes = getWebGLContextAttributes;\nfunction createWebGLContext(canvas) {\n    var attributes = getWebGLContextAttributes();\n    var gl;\n    if (canvas != null) {\n        gl = webgl_util.createWebGLRenderingContextFromCanvas(canvas, attributes);\n    }\n    else {\n        gl = webgl_util.createWebGLRenderingContext(attributes);\n    }\n    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DEPTH_TEST); });\n    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.STENCIL_TEST); });\n    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.BLEND); });\n    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DITHER); });\n    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.POLYGON_OFFSET_FILL); });\n    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.SAMPLE_COVERAGE); });\n    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.SCISSOR_TEST); });\n    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.CULL_FACE); });\n    webgl_util.callAndCheck(gl, function () { return gl.cullFace(gl.BACK); });\n    return gl;\n}\nexports.createWebGLContext = createWebGLContext;\nfunction createVertexShader(gl) {\n    var vertexShaderSource = \"\\n    precision highp float;\\n    attribute vec3 clipSpacePos;\\n    attribute vec2 uv;\\n    varying vec2 resultUV;\\n\\n    void main() {\\n      gl_Position = vec4(clipSpacePos, 1);\\n      resultUV = uv;\\n    }\";\n    return webgl_util.createVertexShader(gl, vertexShaderSource);\n}\nexports.createVertexShader = createVertexShader;\nfunction createVertexBuffer(gl) {\n    var vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n    return webgl_util.createStaticVertexBuffer(gl, vertexArray);\n}\nexports.createVertexBuffer = createVertexBuffer;\nfunction createIndexBuffer(gl) {\n    var triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);\n    return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);\n}\nexports.createIndexBuffer = createIndexBuffer;\nfunction getTextureInternalFormat(gl, numChannels) {\n    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {\n        return gl.RGBA;\n    }\n    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {\n        if (numChannels === 4) {\n            return gl.RGBA32F;\n        }\n        return gl.R32F;\n    }\n    return gl.RGBA;\n}\nfunction getTextureFormat(gl, numChannels) {\n    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {\n        return gl.RGBA;\n    }\n    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {\n        if (numChannels === 4) {\n            return gl.RGBA;\n        }\n        return gl.RED;\n    }\n    return gl.RGBA;\n}\nfunction getTextureType(gl) {\n    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {\n        return gl.UNSIGNED_BYTE;\n    }\n    return gl.FLOAT;\n}\nfunction createAndConfigureTexture(gl, width, height, numChannels) {\n    webgl_util.validateTextureSize(gl, width, height);\n    var texture = webgl_util.createTexture(gl);\n    var tex2d = gl.TEXTURE_2D;\n    var internalFormat = getTextureInternalFormat(gl, numChannels);\n    var format = getTextureFormat(gl, numChannels);\n    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(tex2d, texture); });\n    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); });\n    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); });\n    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST); });\n    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST); });\n    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, format, getTextureType(gl), null); });\n    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });\n    return texture;\n}\nfunction createMatrixTexture(gl, rows, columns) {\n    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];\n    var numChannels = 1;\n    return createAndConfigureTexture(gl, width, height, numChannels);\n}\nexports.createMatrixTexture = createMatrixTexture;\nfunction createColorMatrixTexture(gl, rows, columns) {\n    var _a = tex_util.getColorMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];\n    var numChannels = 4;\n    return createAndConfigureTexture(gl, width, height, numChannels);\n}\nexports.createColorMatrixTexture = createColorMatrixTexture;\nfunction createPackedMatrixTexture(gl, rows, columns) {\n    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];\n    var numChannels = 4;\n    return createAndConfigureTexture(gl, width, height, numChannels);\n}\nexports.createPackedMatrixTexture = createPackedMatrixTexture;\nfunction bindVertexProgramAttributeStreams(gl, program, vertexBuffer, attribLocations) {\n    var posOffset = 0;\n    var uvOffset = 3 * 4;\n    var stride = (3 * 4) + (2 * 4);\n    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); });\n    webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset, attribLocations);\n    webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset, attribLocations);\n}\nexports.bindVertexProgramAttributeStreams = bindVertexProgramAttributeStreams;\nfunction uploadPixelDataToTexture(gl, texture, pixels) {\n    var numChannels = 4;\n    var internalFormat = getTextureInternalFormat(gl, numChannels);\n    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });\n    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, gl.RGBA, getTextureType(gl), pixels); });\n    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });\n}\nexports.uploadPixelDataToTexture = uploadPixelDataToTexture;\nfunction uploadDataToTexture(gl, texture, width, height, data, numChannels) {\n    var textureFormat = getTextureFormat(gl, numChannels);\n    webgl_util.validateTextureSize(gl, width, height);\n    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });\n    webgl_util.callAndCheck(gl, function () { return gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, textureFormat, getTextureType(gl), data); });\n    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });\n}\nfunction uploadMatrixToTexture(gl, texture, rows, columns, matrix, numChannels) {\n    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];\n    var unpackedArray;\n    if (environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {\n        var channelsPerTexture = numChannels === 1 ? webgl_util.getChannelsPerTexture() : numChannels;\n        if (channelsPerTexture === 1) {\n            unpackedArray = matrix;\n        }\n        else {\n            unpackedArray =\n                new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture));\n            tex_util.encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture);\n        }\n    }\n    else {\n        unpackedArray = tex_util.encodeFloatArray(matrix);\n    }\n    uploadDataToTexture(gl, texture, w, h, unpackedArray, numChannels);\n}\nexports.uploadMatrixToTexture = uploadMatrixToTexture;\nfunction uploadMatrixToPackedTexture(gl, texture, rows, columns, matrix) {\n    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];\n    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));\n    tex_util.encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA);\n    var numChannels = 4;\n    uploadDataToTexture(gl, texture, w, h, packedRGBA, numChannels);\n}\nexports.uploadMatrixToPackedTexture = uploadMatrixToPackedTexture;\nfunction downloadMatrixFromOutputTexture(gl, rows, columns) {\n    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];\n    var channelsPerTexture = 4;\n    var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');\n    var downloadTarget;\n    if (isFloatTexture) {\n        downloadTarget =\n            new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, channelsPerTexture));\n    }\n    else {\n        downloadTarget = new Uint8Array(rows * columns * channelsPerTexture);\n    }\n    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), downloadTarget); });\n    if (isFloatTexture) {\n        var matrix = new Float32Array(rows * columns);\n        tex_util.decodeMatrixFromUnpackedArray(downloadTarget, matrix, channelsPerTexture);\n        return matrix;\n    }\n    else {\n        return tex_util.decodeToFloatArray(downloadTarget);\n    }\n}\nexports.downloadMatrixFromOutputTexture = downloadMatrixFromOutputTexture;\nfunction downloadMatrixFromPackedOutputTexture(gl, rows, columns) {\n    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];\n    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));\n    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), packedRGBA); });\n    var matrix = new Float32Array(rows * columns);\n    return tex_util.decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix);\n}\nexports.downloadMatrixFromPackedOutputTexture = downloadMatrixFromPackedOutputTexture;\n//# sourceMappingURL=gpgpu_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvZ3BncHVfdXRpbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9ncGdwdV91dGlsLmpzPzFlYzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnZpcm9ubWVudFwiKTtcbnZhciB0ZXhfdXRpbCA9IHJlcXVpcmUoXCIuL3RleF91dGlsXCIpO1xudmFyIHdlYmdsX3V0aWwgPSByZXF1aXJlKFwiLi93ZWJnbF91dGlsXCIpO1xuZnVuY3Rpb24gZ2V0V2ViR0xDb250ZXh0QXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhbHBoYTogZmFsc2UsXG4gICAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UsXG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgICAgIGRlcHRoOiBmYWxzZSxcbiAgICAgICAgc3RlbmNpbDogZmFsc2UsXG4gICAgICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IHRydWVcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRXZWJHTENvbnRleHRBdHRyaWJ1dGVzID0gZ2V0V2ViR0xDb250ZXh0QXR0cmlidXRlcztcbmZ1bmN0aW9uIGNyZWF0ZVdlYkdMQ29udGV4dChjYW52YXMpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGdldFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMoKTtcbiAgICB2YXIgZ2w7XG4gICAgaWYgKGNhbnZhcyAhPSBudWxsKSB7XG4gICAgICAgIGdsID0gd2ViZ2xfdXRpbC5jcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzKGNhbnZhcywgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbCA9IHdlYmdsX3V0aWwuY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0KGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRpc2FibGUoZ2wuQkxFTkQpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5ESVRIRVIpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGlzYWJsZShnbC5QT0xZR09OX09GRlNFVF9GSUxMKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRpc2FibGUoZ2wuU0FNUExFX0NPVkVSQUdFKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jdWxsRmFjZShnbC5CQUNLKTsgfSk7XG4gICAgcmV0dXJuIGdsO1xufVxuZXhwb3J0cy5jcmVhdGVXZWJHTENvbnRleHQgPSBjcmVhdGVXZWJHTENvbnRleHQ7XG5mdW5jdGlvbiBjcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wpIHtcbiAgICB2YXIgdmVydGV4U2hhZGVyU291cmNlID0gXCJcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgICBhdHRyaWJ1dGUgdmVjMyBjbGlwU3BhY2VQb3M7XFxuICAgIGF0dHJpYnV0ZSB2ZWMyIHV2O1xcbiAgICB2YXJ5aW5nIHZlYzIgcmVzdWx0VVY7XFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcFNwYWNlUG9zLCAxKTtcXG4gICAgICByZXN1bHRVViA9IHV2O1xcbiAgICB9XCI7XG4gICAgcmV0dXJuIHdlYmdsX3V0aWwuY3JlYXRlVmVydGV4U2hhZGVyKGdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpO1xufVxuZXhwb3J0cy5jcmVhdGVWZXJ0ZXhTaGFkZXIgPSBjcmVhdGVWZXJ0ZXhTaGFkZXI7XG5mdW5jdGlvbiBjcmVhdGVWZXJ0ZXhCdWZmZXIoZ2wpIHtcbiAgICB2YXIgdmVydGV4QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFstMSwgMSwgMCwgMCwgMSwgLTEsIC0xLCAwLCAwLCAwLCAxLCAxLCAwLCAxLCAxLCAxLCAtMSwgMCwgMSwgMF0pO1xuICAgIHJldHVybiB3ZWJnbF91dGlsLmNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcihnbCwgdmVydGV4QXJyYXkpO1xufVxuZXhwb3J0cy5jcmVhdGVWZXJ0ZXhCdWZmZXIgPSBjcmVhdGVWZXJ0ZXhCdWZmZXI7XG5mdW5jdGlvbiBjcmVhdGVJbmRleEJ1ZmZlcihnbCkge1xuICAgIHZhciB0cmlhbmdsZVZlcnRleEluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDIsIDEsIDNdKTtcbiAgICByZXR1cm4gd2ViZ2xfdXRpbC5jcmVhdGVTdGF0aWNJbmRleEJ1ZmZlcihnbCwgdHJpYW5nbGVWZXJ0ZXhJbmRpY2VzKTtcbn1cbmV4cG9ydHMuY3JlYXRlSW5kZXhCdWZmZXIgPSBjcmVhdGVJbmRleEJ1ZmZlcjtcbmZ1bmN0aW9uIGdldFRleHR1cmVJbnRlcm5hbEZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpIHtcbiAgICBpZiAoIWVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykpIHtcbiAgICAgICAgcmV0dXJuIGdsLlJHQkE7XG4gICAgfVxuICAgIGlmIChlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKSA9PT0gMikge1xuICAgICAgICBpZiAobnVtQ2hhbm5lbHMgPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBnbC5SR0JBMzJGO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbC5SMzJGO1xuICAgIH1cbiAgICByZXR1cm4gZ2wuUkdCQTtcbn1cbmZ1bmN0aW9uIGdldFRleHR1cmVGb3JtYXQoZ2wsIG51bUNoYW5uZWxzKSB7XG4gICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpKSB7XG4gICAgICAgIHJldHVybiBnbC5SR0JBO1xuICAgIH1cbiAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9WRVJTSU9OJykgPT09IDIpIHtcbiAgICAgICAgaWYgKG51bUNoYW5uZWxzID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2wuUkdCQTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2wuUkVEO1xuICAgIH1cbiAgICByZXR1cm4gZ2wuUkdCQTtcbn1cbmZ1bmN0aW9uIGdldFRleHR1cmVUeXBlKGdsKSB7XG4gICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpKSB7XG4gICAgICAgIHJldHVybiBnbC5VTlNJR05FRF9CWVRFO1xuICAgIH1cbiAgICByZXR1cm4gZ2wuRkxPQVQ7XG59XG5mdW5jdGlvbiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBudW1DaGFubmVscykge1xuICAgIHdlYmdsX3V0aWwudmFsaWRhdGVUZXh0dXJlU2l6ZShnbCwgd2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIHRleHR1cmUgPSB3ZWJnbF91dGlsLmNyZWF0ZVRleHR1cmUoZ2wpO1xuICAgIHZhciB0ZXgyZCA9IGdsLlRFWFRVUkVfMkQ7XG4gICAgdmFyIGludGVybmFsRm9ybWF0ID0gZ2V0VGV4dHVyZUludGVybmFsRm9ybWF0KGdsLCBudW1DaGFubmVscyk7XG4gICAgdmFyIGZvcm1hdCA9IGdldFRleHR1cmVGb3JtYXQoZ2wsIG51bUNoYW5uZWxzKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUodGV4MmQsIHRleHR1cmUpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4UGFyYW1ldGVyaSh0ZXgyZCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhJbWFnZTJEKHRleDJkLCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCBnZXRUZXh0dXJlVHlwZShnbCksIG51bGwpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7IH0pO1xuICAgIHJldHVybiB0ZXh0dXJlO1xufVxuZnVuY3Rpb24gY3JlYXRlTWF0cml4VGV4dHVyZShnbCwgcm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgIHZhciBudW1DaGFubmVscyA9IDE7XG4gICAgcmV0dXJuIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsIG51bUNoYW5uZWxzKTtcbn1cbmV4cG9ydHMuY3JlYXRlTWF0cml4VGV4dHVyZSA9IGNyZWF0ZU1hdHJpeFRleHR1cmU7XG5mdW5jdGlvbiBjcmVhdGVDb2xvck1hdHJpeFRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRDb2xvck1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3aWR0aCA9IF9hWzBdLCBoZWlnaHQgPSBfYVsxXTtcbiAgICB2YXIgbnVtQ2hhbm5lbHMgPSA0O1xuICAgIHJldHVybiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBudW1DaGFubmVscyk7XG59XG5leHBvcnRzLmNyZWF0ZUNvbG9yTWF0cml4VGV4dHVyZSA9IGNyZWF0ZUNvbG9yTWF0cml4VGV4dHVyZTtcbmZ1bmN0aW9uIGNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgd2lkdGggPSBfYVswXSwgaGVpZ2h0ID0gX2FbMV07XG4gICAgdmFyIG51bUNoYW5uZWxzID0gNDtcbiAgICByZXR1cm4gY3JlYXRlQW5kQ29uZmlndXJlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgbnVtQ2hhbm5lbHMpO1xufVxuZXhwb3J0cy5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlID0gY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZTtcbmZ1bmN0aW9uIGJpbmRWZXJ0ZXhQcm9ncmFtQXR0cmlidXRlU3RyZWFtcyhnbCwgcHJvZ3JhbSwgdmVydGV4QnVmZmVyLCBhdHRyaWJMb2NhdGlvbnMpIHtcbiAgICB2YXIgcG9zT2Zmc2V0ID0gMDtcbiAgICB2YXIgdXZPZmZzZXQgPSAzICogNDtcbiAgICB2YXIgc3RyaWRlID0gKDMgKiA0KSArICgyICogNCk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGUoZ2wsIHByb2dyYW0sICdjbGlwU3BhY2VQb3MnLCB2ZXJ0ZXhCdWZmZXIsIDMsIHN0cmlkZSwgcG9zT2Zmc2V0LCBhdHRyaWJMb2NhdGlvbnMpO1xuICAgIHdlYmdsX3V0aWwuYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgJ3V2JywgdmVydGV4QnVmZmVyLCAyLCBzdHJpZGUsIHV2T2Zmc2V0LCBhdHRyaWJMb2NhdGlvbnMpO1xufVxuZXhwb3J0cy5iaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXMgPSBiaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXM7XG5mdW5jdGlvbiB1cGxvYWRQaXhlbERhdGFUb1RleHR1cmUoZ2wsIHRleHR1cmUsIHBpeGVscykge1xuICAgIHZhciBudW1DaGFubmVscyA9IDQ7XG4gICAgdmFyIGludGVybmFsRm9ybWF0ID0gZ2V0VGV4dHVyZUludGVybmFsRm9ybWF0KGdsLCBudW1DaGFubmVscyk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgZ2wuUkdCQSwgZ2V0VGV4dHVyZVR5cGUoZ2wpLCBwaXhlbHMpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7IH0pO1xufVxuZXhwb3J0cy51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUgPSB1cGxvYWRQaXhlbERhdGFUb1RleHR1cmU7XG5mdW5jdGlvbiB1cGxvYWREYXRhVG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCBkYXRhLCBudW1DaGFubmVscykge1xuICAgIHZhciB0ZXh0dXJlRm9ybWF0ID0gZ2V0VGV4dHVyZUZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpO1xuICAgIHdlYmdsX3V0aWwudmFsaWRhdGVUZXh0dXJlU2l6ZShnbCwgd2lkdGgsIGhlaWdodCk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCB0ZXh0dXJlRm9ybWF0LCBnZXRUZXh0dXJlVHlwZShnbCksIGRhdGEpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7IH0pO1xufVxuZnVuY3Rpb24gdXBsb2FkTWF0cml4VG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgsIG51bUNoYW5uZWxzKSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgdyA9IF9hWzBdLCBoID0gX2FbMV07XG4gICAgdmFyIHVucGFja2VkQXJyYXk7XG4gICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykpIHtcbiAgICAgICAgdmFyIGNoYW5uZWxzUGVyVGV4dHVyZSA9IG51bUNoYW5uZWxzID09PSAxID8gd2ViZ2xfdXRpbC5nZXRDaGFubmVsc1BlclRleHR1cmUoKSA6IG51bUNoYW5uZWxzO1xuICAgICAgICBpZiAoY2hhbm5lbHNQZXJUZXh0dXJlID09PSAxKSB7XG4gICAgICAgICAgICB1bnBhY2tlZEFycmF5ID0gbWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5wYWNrZWRBcnJheSA9XG4gICAgICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheSh0ZXhfdXRpbC5nZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKG1hdHJpeC5sZW5ndGgsIGNoYW5uZWxzUGVyVGV4dHVyZSkpO1xuICAgICAgICAgICAgdGV4X3V0aWwuZW5jb2RlTWF0cml4VG9VbnBhY2tlZEFycmF5KG1hdHJpeCwgdW5wYWNrZWRBcnJheSwgY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdW5wYWNrZWRBcnJheSA9IHRleF91dGlsLmVuY29kZUZsb2F0QXJyYXkobWF0cml4KTtcbiAgICB9XG4gICAgdXBsb2FkRGF0YVRvVGV4dHVyZShnbCwgdGV4dHVyZSwgdywgaCwgdW5wYWNrZWRBcnJheSwgbnVtQ2hhbm5lbHMpO1xufVxuZXhwb3J0cy51cGxvYWRNYXRyaXhUb1RleHR1cmUgPSB1cGxvYWRNYXRyaXhUb1RleHR1cmU7XG5mdW5jdGlvbiB1cGxvYWRNYXRyaXhUb1BhY2tlZFRleHR1cmUoZ2wsIHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCkge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICB2YXIgcGFja2VkUkdCQSA9IG5ldyBGbG9hdDMyQXJyYXkodGV4X3V0aWwuZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShyb3dzLCBjb2x1bW5zKSk7XG4gICAgdGV4X3V0aWwuZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBKG1hdHJpeCwgcm93cywgY29sdW1ucywgcGFja2VkUkdCQSk7XG4gICAgdmFyIG51bUNoYW5uZWxzID0gNDtcbiAgICB1cGxvYWREYXRhVG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCB3LCBoLCBwYWNrZWRSR0JBLCBudW1DaGFubmVscyk7XG59XG5leHBvcnRzLnVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZSA9IHVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZTtcbmZ1bmN0aW9uIGRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICB2YXIgY2hhbm5lbHNQZXJUZXh0dXJlID0gNDtcbiAgICB2YXIgaXNGbG9hdFRleHR1cmUgPSBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpO1xuICAgIHZhciBkb3dubG9hZFRhcmdldDtcbiAgICBpZiAoaXNGbG9hdFRleHR1cmUpIHtcbiAgICAgICAgZG93bmxvYWRUYXJnZXQgPVxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheSh0ZXhfdXRpbC5nZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKHJvd3MgKiBjb2x1bW5zLCBjaGFubmVsc1BlclRleHR1cmUpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRvd25sb2FkVGFyZ2V0ID0gbmV3IFVpbnQ4QXJyYXkocm93cyAqIGNvbHVtbnMgKiBjaGFubmVsc1BlclRleHR1cmUpO1xuICAgIH1cbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wucmVhZFBpeGVscygwLCAwLCB3LCBoLCBnbC5SR0JBLCBnZXRUZXh0dXJlVHlwZShnbCksIGRvd25sb2FkVGFyZ2V0KTsgfSk7XG4gICAgaWYgKGlzRmxvYXRUZXh0dXJlKSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KHJvd3MgKiBjb2x1bW5zKTtcbiAgICAgICAgdGV4X3V0aWwuZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXkoZG93bmxvYWRUYXJnZXQsIG1hdHJpeCwgY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0ZXhfdXRpbC5kZWNvZGVUb0Zsb2F0QXJyYXkoZG93bmxvYWRUYXJnZXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZSA9IGRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmU7XG5mdW5jdGlvbiBkb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlKGdsLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHcgPSBfYVswXSwgaCA9IF9hWzFdO1xuICAgIHZhciBwYWNrZWRSR0JBID0gbmV3IEZsb2F0MzJBcnJheSh0ZXhfdXRpbC5nZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlKHJvd3MsIGNvbHVtbnMpKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wucmVhZFBpeGVscygwLCAwLCB3LCBoLCBnbC5SR0JBLCBnZXRUZXh0dXJlVHlwZShnbCksIHBhY2tlZFJHQkEpOyB9KTtcbiAgICB2YXIgbWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheShyb3dzICogY29sdW1ucyk7XG4gICAgcmV0dXJuIHRleF91dGlsLmRlY29kZU1hdHJpeEZyb21QYWNrZWRSR0JBKHBhY2tlZFJHQkEsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCk7XG59XG5leHBvcnRzLmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmUgPSBkb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3BncHVfdXRpbC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/gpgpu_util.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/logsumexp_gpu.js":
/*!*********************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/logsumexp_gpu.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar LogSumExpProgram = (function () {\n    function LogSumExpProgram(size) {\n        this.variableNames = ['A'];\n        this.params = [];\n        this.outputShape = [];\n        var sizeNearestVec4 = Math.floor(size / 4) * 4;\n        var sizeVec4Remainder = size % 4;\n        var r1 = sizeNearestVec4;\n        var r2 = sizeNearestVec4 + 1;\n        var r3 = sizeNearestVec4 + 2;\n        this.userCode = \"\\n      const vec2 ones2 = vec2(1, 1);\\n      const vec3 ones3 = vec3(1, 1, 1);\\n      const vec4 ones4 = vec4(1, 1, 1, 1);\\n\\n      void main() {\\n        vec4 maxVec = vec4(getAFlat(0));\\n        for (int i = 0; i < \" + sizeNearestVec4 + \"; i += 4) {\\n          vec4 aVec = vec4(getAFlat(i), getAFlat(i+1),\\n                           getAFlat(i+2), getAFlat(i+3));\\n          maxVec = max(maxVec, aVec);\\n        }\\n        if (\" + (sizeVec4Remainder === 1) + \") {\\n          maxVec = max(maxVec, vec4(maxVec.xyz, getAFlat(\" + r1 + \")));\\n        } else if (\" + (sizeVec4Remainder === 2) + \") {\\n          vec2 aVec = vec2(getAFlat(\" + r1 + \"), getAFlat(\" + r2 + \"));\\n          maxVec = max(maxVec, vec4(maxVec.xy, aVec));\\n        } else if (\" + (sizeVec4Remainder === 3) + \") {\\n          vec3 aVec = vec3(getAFlat(\" + r1 + \"), getAFlat(\" + r2 + \"), getAFlat(\" + r3 + \"));\\n          maxVec = max(maxVec, vec4(maxVec.x, aVec));\\n        }\\n        float finalMax = max(maxVec.x, max(maxVec.y, max(maxVec.z, maxVec.w)));\\n\\n        float expSum = 0.0;\\n        for (int i = 0; i < \" + sizeNearestVec4 + \"; i += 4) {\\n          vec4 aVec = vec4(getAFlat(i), getAFlat(i+1),\\n                           getAFlat(i+2), getAFlat(i+3));\\n          expSum += dot(ones4, exp(aVec - finalMax));\\n        }\\n        if (\" + (sizeVec4Remainder === 1) + \") {\\n          expSum += exp(getAFlat(\" + r1 + \") - finalMax);\\n        } else if (\" + (sizeVec4Remainder === 2) + \") {\\n          vec2 aVec = vec2(getAFlat(\" + r1 + \"), getAFlat(\" + r2 + \"));\\n          expSum += dot(ones2, exp(aVec - finalMax));\\n        } else if (\" + (sizeVec4Remainder === 3) + \") {\\n          vec3 aVec = vec3(getAFlat(\" + r1 + \"), getAFlat(\" + r2 + \"), getAFlat(\" + r3 + \"));\\n          expSum += dot(ones3, exp(aVec - finalMax));\\n        }\\n\\n        setOutput(finalMax + log(expSum));\\n      }\\n    \";\n    }\n    return LogSumExpProgram;\n}());\nexports.LogSumExpProgram = LogSumExpProgram;\n//# sourceMappingURL=logsumexp_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvbG9nc3VtZXhwX2dwdS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9sb2dzdW1leHBfZ3B1LmpzPzNjM2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTG9nU3VtRXhwUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9nU3VtRXhwUHJvZ3JhbShzaXplKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHZhciBzaXplTmVhcmVzdFZlYzQgPSBNYXRoLmZsb29yKHNpemUgLyA0KSAqIDQ7XG4gICAgICAgIHZhciBzaXplVmVjNFJlbWFpbmRlciA9IHNpemUgJSA0O1xuICAgICAgICB2YXIgcjEgPSBzaXplTmVhcmVzdFZlYzQ7XG4gICAgICAgIHZhciByMiA9IHNpemVOZWFyZXN0VmVjNCArIDE7XG4gICAgICAgIHZhciByMyA9IHNpemVOZWFyZXN0VmVjNCArIDI7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IHZlYzIgb25lczIgPSB2ZWMyKDEsIDEpO1xcbiAgICAgIGNvbnN0IHZlYzMgb25lczMgPSB2ZWMzKDEsIDEsIDEpO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lczQgPSB2ZWM0KDEsIDEsIDEsIDEpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgbWF4VmVjID0gdmVjNChnZXRBRmxhdCgwKSk7XFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiICsgc2l6ZU5lYXJlc3RWZWM0ICsgXCI7IGkgKz0gNCkge1xcbiAgICAgICAgICB2ZWM0IGFWZWMgPSB2ZWM0KGdldEFGbGF0KGkpLCBnZXRBRmxhdChpKzEpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEFGbGF0KGkrMiksIGdldEFGbGF0KGkrMykpO1xcbiAgICAgICAgICBtYXhWZWMgPSBtYXgobWF4VmVjLCBhVmVjKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChcIiArIChzaXplVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgICBtYXhWZWMgPSBtYXgobWF4VmVjLCB2ZWM0KG1heFZlYy54eXosIGdldEFGbGF0KFwiICsgcjEgKyBcIikpKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoc2l6ZVZlYzRSZW1haW5kZXIgPT09IDIpICsgXCIpIHtcXG4gICAgICAgICAgdmVjMiBhVmVjID0gdmVjMihnZXRBRmxhdChcIiArIHIxICsgXCIpLCBnZXRBRmxhdChcIiArIHIyICsgXCIpKTtcXG4gICAgICAgICAgbWF4VmVjID0gbWF4KG1heFZlYywgdmVjNChtYXhWZWMueHksIGFWZWMpKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoc2l6ZVZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgICAgdmVjMyBhVmVjID0gdmVjMyhnZXRBRmxhdChcIiArIHIxICsgXCIpLCBnZXRBRmxhdChcIiArIHIyICsgXCIpLCBnZXRBRmxhdChcIiArIHIzICsgXCIpKTtcXG4gICAgICAgICAgbWF4VmVjID0gbWF4KG1heFZlYywgdmVjNChtYXhWZWMueCwgYVZlYykpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgZmluYWxNYXggPSBtYXgobWF4VmVjLngsIG1heChtYXhWZWMueSwgbWF4KG1heFZlYy56LCBtYXhWZWMudykpKTtcXG5cXG4gICAgICAgIGZsb2F0IGV4cFN1bSA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIgKyBzaXplTmVhcmVzdFZlYzQgKyBcIjsgaSArPSA0KSB7XFxuICAgICAgICAgIHZlYzQgYVZlYyA9IHZlYzQoZ2V0QUZsYXQoaSksIGdldEFGbGF0KGkrMSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QUZsYXQoaSsyKSwgZ2V0QUZsYXQoaSszKSk7XFxuICAgICAgICAgIGV4cFN1bSArPSBkb3Qob25lczQsIGV4cChhVmVjIC0gZmluYWxNYXgpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChcIiArIChzaXplVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgICBleHBTdW0gKz0gZXhwKGdldEFGbGF0KFwiICsgcjEgKyBcIikgLSBmaW5hbE1heCk7XFxuICAgICAgICB9IGVsc2UgaWYgKFwiICsgKHNpemVWZWM0UmVtYWluZGVyID09PSAyKSArIFwiKSB7XFxuICAgICAgICAgIHZlYzIgYVZlYyA9IHZlYzIoZ2V0QUZsYXQoXCIgKyByMSArIFwiKSwgZ2V0QUZsYXQoXCIgKyByMiArIFwiKSk7XFxuICAgICAgICAgIGV4cFN1bSArPSBkb3Qob25lczIsIGV4cChhVmVjIC0gZmluYWxNYXgpKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoc2l6ZVZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgICAgdmVjMyBhVmVjID0gdmVjMyhnZXRBRmxhdChcIiArIHIxICsgXCIpLCBnZXRBRmxhdChcIiArIHIyICsgXCIpLCBnZXRBRmxhdChcIiArIHIzICsgXCIpKTtcXG4gICAgICAgICAgZXhwU3VtICs9IGRvdChvbmVzMywgZXhwKGFWZWMgLSBmaW5hbE1heCkpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGZpbmFsTWF4ICsgbG9nKGV4cFN1bSkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBMb2dTdW1FeHBQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuTG9nU3VtRXhwUHJvZ3JhbSA9IExvZ1N1bUV4cFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dzdW1leHBfZ3B1LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/logsumexp_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/max_pool_backprop_gpu.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/max_pool_backprop_gpu.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MaxPool2DBackpropProgram = (function () {\n    function MaxPool2DBackpropProgram(convInfo) {\n        this.variableNames = ['dy', 'maxPos'];\n        this.outputShape = convInfo.inShape;\n        var dyRows = convInfo.outShape[0];\n        var dyCols = convInfo.outShape[1];\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var padTop = filterHeight - 1 - convInfo.padInfo.top;\n        var padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        this.params =\n            [filterHeight, filterWidth, strideHeight, strideWidth, padTop, padLeft];\n        var lastIndex = filterHeight * filterWidth - 1;\n        this.userCode = \"\\n      const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        int d = coords.z;\\n\\n        ivec2 dyRCCorner = coords.xy - pads;\\n        int dyRCorner = dyRCCorner.x;\\n        int dyCCorner = dyRCCorner.y;\\n\\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \" + strideHeight + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + dyRows + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          for (int wC = 0; wC < \" + filterWidth + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + strideWidth + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + dyCols + \".0 || fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            float dyValue = getDy(idyR, idyC, d);\\n            int maxPosValue = \" + lastIndex + \" - int(getMaxPos(idyR, idyC, d));\\n\\n            // Get the current value, check it against the value from the\\n            // position matrix.\\n            int curPosValue = wR * \" + filterWidth + \" + wC;\\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\\n\\n            dotProd += dyValue * mask;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n    }\n    return MaxPool2DBackpropProgram;\n}());\nexports.MaxPool2DBackpropProgram = MaxPool2DBackpropProgram;\n//# sourceMappingURL=max_pool_backprop_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvbWF4X3Bvb2xfYmFja3Byb3BfZ3B1LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL21heF9wb29sX2JhY2twcm9wX2dwdS5qcz8wNjhhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE1heFBvb2wyREJhY2twcm9wUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtKGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnZHknLCAnbWF4UG9zJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5pblNoYXBlO1xuICAgICAgICB2YXIgZHlSb3dzID0gY29udkluZm8ub3V0U2hhcGVbMF07XG4gICAgICAgIHZhciBkeUNvbHMgPSBjb252SW5mby5vdXRTaGFwZVsxXTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdGhpcy5wYXJhbXMgPVxuICAgICAgICAgICAgW2ZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIHBhZFRvcCwgcGFkTGVmdF07XG4gICAgICAgIHZhciBsYXN0SW5kZXggPSBmaWx0ZXJIZWlnaHQgKiBmaWx0ZXJXaWR0aCAtIDE7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkcy56O1xcblxcbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy54eSAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHhSLCB4QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIiArIHN0cmlkZUhlaWdodCArIFwiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiICsgZHlSb3dzICsgXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiICsgc3RyaWRlV2lkdGggKyBcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiICsgZHlDb2xzICsgXCIuMCB8fCBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoaWR5UiwgaWR5QywgZCk7XFxuICAgICAgICAgICAgaW50IG1heFBvc1ZhbHVlID0gXCIgKyBsYXN0SW5kZXggKyBcIiAtIGludChnZXRNYXhQb3MoaWR5UiwgaWR5QywgZCkpO1xcblxcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB2YWx1ZSwgY2hlY2sgaXQgYWdhaW5zdCB0aGUgdmFsdWUgZnJvbSB0aGVcXG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBtYXRyaXguXFxuICAgICAgICAgICAgaW50IGN1clBvc1ZhbHVlID0gd1IgKiBcIiArIGZpbHRlcldpZHRoICsgXCIgKyB3QztcXG4gICAgICAgICAgICBmbG9hdCBtYXNrID0gZmxvYXQobWF4UG9zVmFsdWUgPT0gY3VyUG9zVmFsdWUgPyAxLjAgOiAwLjApO1xcblxcbiAgICAgICAgICAgIGRvdFByb2QgKz0gZHlWYWx1ZSAqIG1hc2s7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtID0gTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF4X3Bvb2xfYmFja3Byb3BfZ3B1LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/max_pool_backprop_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/minmax_gpu.js":
/*!******************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/minmax_gpu.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MinMaxProgram = (function () {\n    function MinMaxProgram(size, op) {\n        this.variableNames = ['A'];\n        this.outputShape = [];\n        this.params = [op];\n        var sizeNearestVec4 = Math.floor(size / 4) * 4;\n        var sizeVec4Remainder = size % 4;\n        var r1 = sizeNearestVec4;\n        var r2 = sizeNearestVec4 + 1;\n        var r3 = sizeNearestVec4 + 2;\n        this.userCode = \"\\n      void main() {\\n        vec4 bestVec = vec4(getAFlat(0));\\n        for (int i = 0; i < \" + sizeNearestVec4 + \"; i += 4) {\\n          vec4 aVec = vec4(getAFlat(i), getAFlat(i+1),\\n                           getAFlat(i+2), getAFlat(i+3));\\n          if (hasNaN(aVec)) {\\n            setOutput(getNaN(aVec));\\n            return;\\n          }\\n          bestVec = \" + op + \"(bestVec, aVec);\\n        }\\n        vec4 aVec;\\n        if (\" + (sizeVec4Remainder === 1) + \") {\\n          aVec = vec4(bestVec.xyz, getAFlat(\" + r1 + \"));\\n        } else if (\" + (sizeVec4Remainder === 2) + \") {\\n          aVec = vec4(bestVec.xy, vec2(getAFlat(\" + r1 + \"), getAFlat(\" + r2 + \")));\\n        } else if (\" + (sizeVec4Remainder === 3) + \") {\\n          aVec = vec4(bestVec.x,\\n                      vec3(getAFlat(\" + r1 + \"), getAFlat(\" + r2 + \"), getAFlat(\" + r3 + \")));\\n        }\\n        if (\" + (sizeVec4Remainder > 0) + \") {\\n          if (hasNaN(aVec)) {\\n            setOutput(getNaN(aVec));\\n            return;\\n          }\\n          bestVec = \" + op + \"(bestVec, aVec);\\n        }\\n\\n        float final = \" + op + \"(bestVec.x, \" + op + \"(bestVec.y,\\n                      \" + op + \"(bestVec.z, bestVec.w)));\\n        setOutput(final);\\n      }\\n    \";\n    }\n    return MinMaxProgram;\n}());\nexports.MinMaxProgram = MinMaxProgram;\n//# sourceMappingURL=minmax_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvbWlubWF4X2dwdS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9taW5tYXhfZ3B1LmpzPzJiYjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTWluTWF4UHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWluTWF4UHJvZ3JhbShzaXplLCBvcCkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtvcF07XG4gICAgICAgIHZhciBzaXplTmVhcmVzdFZlYzQgPSBNYXRoLmZsb29yKHNpemUgLyA0KSAqIDQ7XG4gICAgICAgIHZhciBzaXplVmVjNFJlbWFpbmRlciA9IHNpemUgJSA0O1xuICAgICAgICB2YXIgcjEgPSBzaXplTmVhcmVzdFZlYzQ7XG4gICAgICAgIHZhciByMiA9IHNpemVOZWFyZXN0VmVjNCArIDE7XG4gICAgICAgIHZhciByMyA9IHNpemVOZWFyZXN0VmVjNCArIDI7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgYmVzdFZlYyA9IHZlYzQoZ2V0QUZsYXQoMCkpO1xcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIiArIHNpemVOZWFyZXN0VmVjNCArIFwiOyBpICs9IDQpIHtcXG4gICAgICAgICAgdmVjNCBhVmVjID0gdmVjNChnZXRBRmxhdChpKSwgZ2V0QUZsYXQoaSsxKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRBRmxhdChpKzIpLCBnZXRBRmxhdChpKzMpKTtcXG4gICAgICAgICAgaWYgKGhhc05hTihhVmVjKSkge1xcbiAgICAgICAgICAgIHNldE91dHB1dChnZXROYU4oYVZlYykpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBiZXN0VmVjID0gXCIgKyBvcCArIFwiKGJlc3RWZWMsIGFWZWMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmVjNCBhVmVjO1xcbiAgICAgICAgaWYgKFwiICsgKHNpemVWZWM0UmVtYWluZGVyID09PSAxKSArIFwiKSB7XFxuICAgICAgICAgIGFWZWMgPSB2ZWM0KGJlc3RWZWMueHl6LCBnZXRBRmxhdChcIiArIHIxICsgXCIpKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoc2l6ZVZlYzRSZW1haW5kZXIgPT09IDIpICsgXCIpIHtcXG4gICAgICAgICAgYVZlYyA9IHZlYzQoYmVzdFZlYy54eSwgdmVjMihnZXRBRmxhdChcIiArIHIxICsgXCIpLCBnZXRBRmxhdChcIiArIHIyICsgXCIpKSk7XFxuICAgICAgICB9IGVsc2UgaWYgKFwiICsgKHNpemVWZWM0UmVtYWluZGVyID09PSAzKSArIFwiKSB7XFxuICAgICAgICAgIGFWZWMgPSB2ZWM0KGJlc3RWZWMueCxcXG4gICAgICAgICAgICAgICAgICAgICAgdmVjMyhnZXRBRmxhdChcIiArIHIxICsgXCIpLCBnZXRBRmxhdChcIiArIHIyICsgXCIpLCBnZXRBRmxhdChcIiArIHIzICsgXCIpKSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoXCIgKyAoc2l6ZVZlYzRSZW1haW5kZXIgPiAwKSArIFwiKSB7XFxuICAgICAgICAgIGlmIChoYXNOYU4oYVZlYykpIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZ2V0TmFOKGFWZWMpKTtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYmVzdFZlYyA9IFwiICsgb3AgKyBcIihiZXN0VmVjLCBhVmVjKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZsb2F0IGZpbmFsID0gXCIgKyBvcCArIFwiKGJlc3RWZWMueCwgXCIgKyBvcCArIFwiKGJlc3RWZWMueSxcXG4gICAgICAgICAgICAgICAgICAgICAgXCIgKyBvcCArIFwiKGJlc3RWZWMueiwgYmVzdFZlYy53KSkpO1xcbiAgICAgICAgc2V0T3V0cHV0KGZpbmFsKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gTWluTWF4UHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLk1pbk1heFByb2dyYW0gPSBNaW5NYXhQcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWlubWF4X2dwdS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/minmax_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/mulmat_gpu.js":
/*!******************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/mulmat_gpu.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar math_1 = __webpack_require__(/*! ../math */ \"./node_modules/deeplearn/dist/src/math/math.js\");\nvar MatMulProgram = (function () {\n    function MatMulProgram(aShape, bShape, aOrient, bOrient) {\n        if (aOrient === void 0) { aOrient = math_1.MatrixOrientation.REGULAR; }\n        if (bOrient === void 0) { bOrient = math_1.MatrixOrientation.REGULAR; }\n        this.variableNames = ['matrixA', 'matrixB'];\n        this.params = [aOrient, bOrient];\n        var outerShapeA = (aOrient === math_1.MatrixOrientation.REGULAR) ? aShape[0] : aShape[1];\n        var outerShapeB = (bOrient === math_1.MatrixOrientation.REGULAR) ? bShape[1] : bShape[0];\n        this.outputShape = [outerShapeA, outerShapeB];\n        var sharedDim = (aOrient === math_1.MatrixOrientation.REGULAR ? aShape[1] : aShape[0]);\n        var aSnippetFromOffset = function (vec4Offset, indexVar) {\n            return (aOrient === math_1.MatrixOrientation.REGULAR) ?\n                \"aRow, \" + indexVar + \" + \" + vec4Offset :\n                indexVar + \" + \" + vec4Offset + \", aRow\";\n        };\n        var bSnippetFromOffset = function (vec4Offset, indexVar) {\n            return (bOrient === math_1.MatrixOrientation.REGULAR) ?\n                indexVar + \" + \" + vec4Offset + \", bCol\" :\n                \"bCol, \" + indexVar + \" + \" + vec4Offset;\n        };\n        var sharedDimNearestVec4 = Math.floor(sharedDim / 4) * 4;\n        var sharedDimVec4Remainder = sharedDim % 4;\n        this.userCode = \" float dotARowBCol(int aRow, int bCol) {\\n      float result = 0.0;\\n      for (int i = 0; i < \" + sharedDimNearestVec4 + \"; i += 4) {\\n        vec4 a = vec4(\\n          getMatrixA(\" + aSnippetFromOffset(0, 'i') + \"),\\n          getMatrixA(\" + aSnippetFromOffset(1, 'i') + \"),\\n          getMatrixA(\" + aSnippetFromOffset(2, 'i') + \"),\\n          getMatrixA(\" + aSnippetFromOffset(3, 'i') + \")\\n        );\\n        vec4 b = vec4(\\n          getMatrixB(\" + bSnippetFromOffset(0, 'i') + \"),\\n          getMatrixB(\" + bSnippetFromOffset(1, 'i') + \"),\\n          getMatrixB(\" + bSnippetFromOffset(2, 'i') + \"),\\n          getMatrixB(\" + bSnippetFromOffset(3, 'i') + \")\\n        );\\n\\n        result += dot(a, b);\\n      }\\n\\n      if (\" + (sharedDimVec4Remainder === 1) + \") {\\n        result += getMatrixA(\" + aSnippetFromOffset(0, sharedDimNearestVec4) + \") *\\n          getMatrixB(\" + bSnippetFromOffset(0, sharedDimNearestVec4) + \");\\n      } else if (\" + (sharedDimVec4Remainder === 2) + \") {\\n        vec2 a = vec2(\\n          getMatrixA(\" + aSnippetFromOffset(0, sharedDimNearestVec4) + \"),\\n          getMatrixA(\" + aSnippetFromOffset(1, sharedDimNearestVec4) + \")\\n        );\\n        vec2 b = vec2(\\n          getMatrixB(\" + bSnippetFromOffset(0, sharedDimNearestVec4) + \"),\\n          getMatrixB(\" + bSnippetFromOffset(1, sharedDimNearestVec4) + \")\\n        );\\n        result += dot(a, b);\\n      } else if (\" + (sharedDimVec4Remainder === 3) + \") {\\n        vec3 a = vec3(\\n          getMatrixA(\" + aSnippetFromOffset(0, sharedDimNearestVec4) + \"),\\n          getMatrixA(\" + aSnippetFromOffset(1, sharedDimNearestVec4) + \"),\\n          getMatrixA(\" + aSnippetFromOffset(2, sharedDimNearestVec4) + \")\\n        );\\n        vec3 b = vec3(\\n          getMatrixB(\" + bSnippetFromOffset(0, sharedDimNearestVec4) + \"),\\n          getMatrixB(\" + bSnippetFromOffset(1, sharedDimNearestVec4) + \"),\\n          getMatrixB(\" + bSnippetFromOffset(2, sharedDimNearestVec4) + \")\\n        );\\n        result += dot(a, b);\\n      }\\n\\n      return result;\\n    }\\n\\n    void main() {\\n      ivec2 resRC = getOutputCoords();\\n      setOutput(dotARowBCol(resRC.x, resRC.y));\\n    }\\n    \";\n    }\n    return MatMulProgram;\n}());\nexports.MatMulProgram = MatMulProgram;\n//# sourceMappingURL=mulmat_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvbXVsbWF0X2dwdS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9tdWxtYXRfZ3B1LmpzPzBkNDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbWF0aF8xID0gcmVxdWlyZShcIi4uL21hdGhcIik7XG52YXIgTWF0TXVsUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF0TXVsUHJvZ3JhbShhU2hhcGUsIGJTaGFwZSwgYU9yaWVudCwgYk9yaWVudCkge1xuICAgICAgICBpZiAoYU9yaWVudCA9PT0gdm9pZCAwKSB7IGFPcmllbnQgPSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUjsgfVxuICAgICAgICBpZiAoYk9yaWVudCA9PT0gdm9pZCAwKSB7IGJPcmllbnQgPSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUjsgfVxuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ21hdHJpeEEnLCAnbWF0cml4QiddO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFthT3JpZW50LCBiT3JpZW50XTtcbiAgICAgICAgdmFyIG91dGVyU2hhcGVBID0gKGFPcmllbnQgPT09IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGFTaGFwZVswXSA6IGFTaGFwZVsxXTtcbiAgICAgICAgdmFyIG91dGVyU2hhcGVCID0gKGJPcmllbnQgPT09IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGJTaGFwZVsxXSA6IGJTaGFwZVswXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtvdXRlclNoYXBlQSwgb3V0ZXJTaGFwZUJdO1xuICAgICAgICB2YXIgc2hhcmVkRGltID0gKGFPcmllbnQgPT09IG1hdGhfMS5NYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSID8gYVNoYXBlWzFdIDogYVNoYXBlWzBdKTtcbiAgICAgICAgdmFyIGFTbmlwcGV0RnJvbU9mZnNldCA9IGZ1bmN0aW9uICh2ZWM0T2Zmc2V0LCBpbmRleFZhcikge1xuICAgICAgICAgICAgcmV0dXJuIChhT3JpZW50ID09PSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgP1xuICAgICAgICAgICAgICAgIFwiYVJvdywgXCIgKyBpbmRleFZhciArIFwiICsgXCIgKyB2ZWM0T2Zmc2V0IDpcbiAgICAgICAgICAgICAgICBpbmRleFZhciArIFwiICsgXCIgKyB2ZWM0T2Zmc2V0ICsgXCIsIGFSb3dcIjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJTbmlwcGV0RnJvbU9mZnNldCA9IGZ1bmN0aW9uICh2ZWM0T2Zmc2V0LCBpbmRleFZhcikge1xuICAgICAgICAgICAgcmV0dXJuIChiT3JpZW50ID09PSBtYXRoXzEuTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgP1xuICAgICAgICAgICAgICAgIGluZGV4VmFyICsgXCIgKyBcIiArIHZlYzRPZmZzZXQgKyBcIiwgYkNvbFwiIDpcbiAgICAgICAgICAgICAgICBcImJDb2wsIFwiICsgaW5kZXhWYXIgKyBcIiArIFwiICsgdmVjNE9mZnNldDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNoYXJlZERpbU5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcihzaGFyZWREaW0gLyA0KSAqIDQ7XG4gICAgICAgIHZhciBzaGFyZWREaW1WZWM0UmVtYWluZGVyID0gc2hhcmVkRGltICUgNDtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiIGZsb2F0IGRvdEFSb3dCQ29sKGludCBhUm93LCBpbnQgYkNvbCkge1xcbiAgICAgIGZsb2F0IHJlc3VsdCA9IDAuMDtcXG4gICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiICsgc2hhcmVkRGltTmVhcmVzdFZlYzQgKyBcIjsgaSArPSA0KSB7XFxuICAgICAgICB2ZWM0IGEgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDAsICdpJykgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMSwgJ2knKSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgyLCAnaScpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDMsICdpJykgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICB2ZWM0IGIgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDAsICdpJykgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMSwgJ2knKSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgyLCAnaScpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDMsICdpJykgKyBcIilcXG4gICAgICAgICk7XFxuXFxuICAgICAgICByZXN1bHQgKz0gZG90KGEsIGIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoXCIgKyAoc2hhcmVkRGltVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgcmVzdWx0ICs9IGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMCwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpICpcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgwLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIik7XFxuICAgICAgfSBlbHNlIGlmIChcIiArIChzaGFyZWREaW1WZWM0UmVtYWluZGVyID09PSAyKSArIFwiKSB7XFxuICAgICAgICB2ZWMyIGEgPSB2ZWMyKFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDAsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgxLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICB2ZWMyIGIgPSB2ZWMyKFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDAsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgxLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICByZXN1bHQgKz0gZG90KGEsIGIpO1xcbiAgICAgIH0gZWxzZSBpZiAoXCIgKyAoc2hhcmVkRGltVmVjNFJlbWFpbmRlciA9PT0gMykgKyBcIikge1xcbiAgICAgICAgdmVjMyBhID0gdmVjMyhcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgwLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMSwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDIsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKVxcbiAgICAgICAgKTtcXG4gICAgICAgIHZlYzMgYiA9IHZlYzMoXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMCwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDEsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgyLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICByZXN1bHQgKz0gZG90KGEsIGIpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBpdmVjMiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIHNldE91dHB1dChkb3RBUm93QkNvbChyZXNSQy54LCByZXNSQy55KSk7XFxuICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBNYXRNdWxQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuTWF0TXVsUHJvZ3JhbSA9IE1hdE11bFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWxtYXRfZ3B1LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/mulmat_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/multinomial_gpu.js":
/*!***********************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/multinomial_gpu.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MultinomialProgram = (function () {\n    function MultinomialProgram(numOutcomes, numSamples) {\n        this.variableNames = ['probs'];\n        this.outputShape = [numSamples];\n        this.params = [];\n        this.userCode = \"\\n      uniform float seed;\\n\\n      void main() {\\n        float r = random(seed);\\n        float cdf = 0.0;\\n\\n        for (int i = 0; i < \" + (numOutcomes - 1) + \"; i++) {\\n          cdf += getProbs(i);\\n\\n          if (r < cdf) {\\n            setOutput(float(i));\\n            return;\\n          }\\n        }\\n\\n        // If no other event happened, last event happened.\\n        setOutput(float(\" + (numOutcomes - 1) + \"));\\n      }\\n    \";\n    }\n    MultinomialProgram.prototype.getCustomSetupFunc = function (seed) {\n        var _this = this;\n        return function (gpgpu, webGLProgram) {\n            if (_this.seedLoc == null) {\n                _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');\n            }\n            gpgpu.gl.uniform1f(_this.seedLoc, seed);\n        };\n    };\n    return MultinomialProgram;\n}());\nexports.MultinomialProgram = MultinomialProgram;\n//# sourceMappingURL=multinomial_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvbXVsdGlub21pYWxfZ3B1LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL211bHRpbm9taWFsX2dwdS5qcz83YjAxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE11bHRpbm9taWFsUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTXVsdGlub21pYWxQcm9ncmFtKG51bU91dGNvbWVzLCBudW1TYW1wbGVzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsncHJvYnMnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtudW1TYW1wbGVzXTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBbXTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCBzZWVkO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHIgPSByYW5kb20oc2VlZCk7XFxuICAgICAgICBmbG9hdCBjZGYgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiICsgKG51bU91dGNvbWVzIC0gMSkgKyBcIjsgaSsrKSB7XFxuICAgICAgICAgIGNkZiArPSBnZXRQcm9icyhpKTtcXG5cXG4gICAgICAgICAgaWYgKHIgPCBjZGYpIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoaSkpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gSWYgbm8gb3RoZXIgZXZlbnQgaGFwcGVuZWQsIGxhc3QgZXZlbnQgaGFwcGVuZWQuXFxuICAgICAgICBzZXRPdXRwdXQoZmxvYXQoXCIgKyAobnVtT3V0Y29tZXMgLSAxKSArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgTXVsdGlub21pYWxQcm9ncmFtLnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmMgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdwZ3B1LCB3ZWJHTFByb2dyYW0pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zZWVkTG9jID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWVkTG9jID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKHdlYkdMUHJvZ3JhbSwgJ3NlZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xZihfdGhpcy5zZWVkTG9jLCBzZWVkKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBNdWx0aW5vbWlhbFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5NdWx0aW5vbWlhbFByb2dyYW0gPSBNdWx0aW5vbWlhbFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aW5vbWlhbF9ncHUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/multinomial_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/onehot_gpu.js":
/*!******************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/onehot_gpu.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar OneHotProgram = (function () {\n    function OneHotProgram(numIndices, depth, onValue, offValue) {\n        this.variableNames = ['indices'];\n        this.outputShape = [numIndices, depth];\n        this.params = [onValue, offValue];\n        this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int index = round(getIndices(coords.x));\\n        setOutput(mix(float(\" + offValue + \"), float(\" + onValue + \"),\\n                      float(index == coords.y)));\\n      }\\n    \";\n    }\n    OneHotProgram.prototype.getCustomSetupFunc = function (seed) {\n        var _this = this;\n        return function (gpgpu, webGLProgram) {\n            if (_this.seedLoc == null) {\n                _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');\n            }\n            gpgpu.gl.uniform1f(_this.seedLoc, seed);\n        };\n    };\n    return OneHotProgram;\n}());\nexports.OneHotProgram = OneHotProgram;\n//# sourceMappingURL=onehot_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvb25laG90X2dwdS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9vbmVob3RfZ3B1LmpzP2U3YjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgT25lSG90UHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT25lSG90UHJvZ3JhbShudW1JbmRpY2VzLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydpbmRpY2VzJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbbnVtSW5kaWNlcywgZGVwdGhdO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtvblZhbHVlLCBvZmZWYWx1ZV07XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZ2V0SW5kaWNlcyhjb29yZHMueCkpO1xcbiAgICAgICAgc2V0T3V0cHV0KG1peChmbG9hdChcIiArIG9mZlZhbHVlICsgXCIpLCBmbG9hdChcIiArIG9uVmFsdWUgKyBcIiksXFxuICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGluZGV4ID09IGNvb3Jkcy55KSkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIE9uZUhvdFByb2dyYW0ucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYyA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ3BncHUsIHdlYkdMUHJvZ3JhbSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnNlZWRMb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlZWRMb2MgPSBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCAnc2VlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFmKF90aGlzLnNlZWRMb2MsIHNlZWQpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIE9uZUhvdFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5PbmVIb3RQcm9ncmFtID0gT25lSG90UHJvZ3JhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uZWhvdF9ncHUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/onehot_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/pool_gpu.js":
/*!****************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/pool_gpu.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Pool2DProgram = (function () {\n    function Pool2DProgram(convInfo, poolType, computePositions) {\n        this.variableNames = ['x'];\n        if (poolType === 'avg' && computePositions) {\n            throw new Error('Cannot compute positions for average pool.');\n        }\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var xNumRows = convInfo.inShape[0];\n        var xNumCols = convInfo.inShape[1];\n        var padTop = convInfo.padInfo.top;\n        var padLeft = convInfo.padInfo.left;\n        this.params = [\n            strideHeight, strideWidth, padLeft, padTop, poolType, computePositions\n        ];\n        this.outputShape = convInfo.outShape;\n        var isAvgPool = poolType === 'avg';\n        var initializationValue = '0.0';\n        if (!isAvgPool) {\n            if (poolType === 'min') {\n                initializationValue = '1.0 / 0.0';\n            }\n            else {\n                initializationValue = '-1.0 / 0.0';\n            }\n        }\n        if (computePositions) {\n            var compareOp_1 = poolType === 'min' ? '<=' : '>=';\n            this.userCode = \"\\n        const ivec2 strides = ivec2(\" + strideHeight + \", \" + strideWidth + \");\\n        const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n\\n        void main() {\\n          ivec3 coords = getOutputCoords();\\n          int d = coords.z;\\n\\n          ivec2 xRCCorner = coords.xy * strides - pads;\\n          int xRCorner = xRCCorner.x;\\n          int xCCorner = xRCCorner.y;\\n\\n          // max/min x(?, ?, d) to get y(yR, yC, d).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n          float avgValue = 0.0;\\n\\n          for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \" + xNumRows + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + filterWidth + \"; wC++) {\\n              int xC = xCCorner + wC;\\n\\n              if (xC < 0 || xC >= \" + xNumCols + \") {\\n                continue;\\n              }\\n\\n              float value = getX(xR, xC, d);\\n\\n              if (isNaN(value)) {\\n                setOutput(value);\\n                return;\\n              }\\n\\n              // If a min / max value has already been found, use it. If not,\\n              // use the current value.\\n              float currMinMaxValue = mix(\\n                  value, minMaxValue, minMaxValueFound);\\n              if (value \" + compareOp_1 + \" currMinMaxValue) {\\n                minMaxValue = value;\\n                minMaxValueFound = 1.0;\\n                minMaxPosition = wR * \" + filterWidth + \" + wC;\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \";\n            return;\n        }\n        var compareOp = poolType === 'min' ? 'min' : 'max';\n        var returnValue = poolType + \"(\" + poolType + \"(\" + poolType + \"(\" +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (poolType === 'avg') {\n            returnValue = \"avgValue / \" + filterHeight * filterWidth + \".0\";\n        }\n        var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n        var filterWidthVec4Remainder = filterWidth % 4;\n        var updateSnippet = \"\\n      if (hasNaN(values)) {\\n        setOutput(getNaN(values));\\n        return;\\n      }\\n      if (\" + isAvgPool + \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = \" + compareOp + \"(values, minMaxValue);\\n      }\\n    \";\n        this.userCode = \"\\n      const ivec2 strides = ivec2(\" + strideHeight + \", \" + strideWidth + \");\\n      const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n      const float initializationValue = \" + initializationValue + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float getValue(int xR, int xC, int d) {\\n        if (xC < 0 || xC >= \" + xNumCols + \") {\\n          return initializationValue;\\n        }\\n        return getX(xR, xC, d);\\n      }\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        int d = coords.z;\\n\\n        ivec2 xRCCorner = coords.xy * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // max/min x(?, ?, d) to get y(yR, yC, d).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\" + initializationValue + \");\\n        float avgValue = 0.0;\\n\\n        for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n          int xR = xRCorner + wR;\\n\\n          if (xR < 0 || xR >= \" + xNumRows + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + filterWidthNearestVec4 + \"; wC += 4) {\\n            int xC = xCCorner + wC;\\n\\n            vec4 values = vec4(\\n              getValue(xR, xC, d),\\n              getValue(xR, xC + 1, d),\\n              getValue(xR, xC + 2, d),\\n              getValue(xR, xC + 3, d)\\n            );\\n\\n            \" + updateSnippet + \"\\n          }\\n\\n          int xC = xCCorner + \" + filterWidthNearestVec4 + \";\\n          if (\" + (filterWidthVec4Remainder === 1) + \") {\\n            vec4 values = vec4(\\n              getValue(xR, xC, d),\\n              initializationValue,\\n              initializationValue,\\n              initializationValue\\n            );\\n            \" + updateSnippet + \"\\n          } else if (\" + (filterWidthVec4Remainder === 2) + \") {\\n            vec4 values = vec4(\\n              getValue(xR, xC, d),\\n              getValue(xR, xC + 1, d),\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + updateSnippet + \"\\n          } else if (\" + (filterWidthVec4Remainder === 3) + \") {\\n            vec4 values = vec4(\\n              getValue(xR, xC, d),\\n              getValue(xR, xC + 1, d),\\n              getValue(xR, xC + 2, d),\\n              initializationValue\\n            );\\n\\n            \" + updateSnippet + \"\\n          }\\n        }\\n        setOutput(\" + returnValue + \");\\n      }\\n    \";\n    }\n    return Pool2DProgram;\n}());\nexports.Pool2DProgram = Pool2DProgram;\n//# sourceMappingURL=pool_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvcG9vbF9ncHUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvcG9vbF9ncHUuanM/MmFlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQb29sMkRQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb29sMkRQcm9ncmFtKGNvbnZJbmZvLCBwb29sVHlwZSwgY29tcHV0ZVBvc2l0aW9ucykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgICAgICAgaWYgKHBvb2xUeXBlID09PSAnYXZnJyAmJiBjb21wdXRlUG9zaXRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wdXRlIHBvc2l0aW9ucyBmb3IgYXZlcmFnZSBwb29sLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIHhOdW1Sb3dzID0gY29udkluZm8uaW5TaGFwZVswXTtcbiAgICAgICAgdmFyIHhOdW1Db2xzID0gY29udkluZm8uaW5TaGFwZVsxXTtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBbXG4gICAgICAgICAgICBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoLCBwYWRMZWZ0LCBwYWRUb3AsIHBvb2xUeXBlLCBjb21wdXRlUG9zaXRpb25zXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICAgICAgdmFyIGlzQXZnUG9vbCA9IHBvb2xUeXBlID09PSAnYXZnJztcbiAgICAgICAgdmFyIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnMC4wJztcbiAgICAgICAgaWYgKCFpc0F2Z1Bvb2wpIHtcbiAgICAgICAgICAgIGlmIChwb29sVHlwZSA9PT0gJ21pbicpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJzEuMCAvIDAuMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJy0xLjAgLyAwLjAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wdXRlUG9zaXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgY29tcGFyZU9wXzEgPSBwb29sVHlwZSA9PT0gJ21pbicgPyAnPD0nIDogJz49JztcbiAgICAgICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIsIFwiICsgc3RyaWRlV2lkdGggKyBcIik7XFxuICAgICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGQgPSBjb29yZHMuejtcXG5cXG4gICAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnh5ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlID0gMC4wO1xcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZUZvdW5kID0gMC4wO1xcbiAgICAgICAgICBpbnQgbWluTWF4UG9zaXRpb24gPSAwO1xcbiAgICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIgKyB4TnVtUm93cyArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyB4TnVtQ29scyArIFwiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRYKHhSLCB4QywgZCk7XFxuXFxuICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XFxuICAgICAgICAgICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIC8vIElmIGEgbWluIC8gbWF4IHZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gZm91bmQsIHVzZSBpdC4gSWYgbm90LFxcbiAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjdXJyZW50IHZhbHVlLlxcbiAgICAgICAgICAgICAgZmxvYXQgY3Vyck1pbk1heFZhbHVlID0gbWl4KFxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLCBtaW5NYXhWYWx1ZSwgbWluTWF4VmFsdWVGb3VuZCk7XFxuICAgICAgICAgICAgICBpZiAodmFsdWUgXCIgKyBjb21wYXJlT3BfMSArIFwiIGN1cnJNaW5NYXhWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IHZhbHVlO1xcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZUZvdW5kID0gMS4wO1xcbiAgICAgICAgICAgICAgICBtaW5NYXhQb3NpdGlvbiA9IHdSICogXCIgKyBmaWx0ZXJXaWR0aCArIFwiICsgd0M7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChtaW5NYXhQb3NpdGlvbikpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wYXJlT3AgPSBwb29sVHlwZSA9PT0gJ21pbicgPyAnbWluJyA6ICdtYXgnO1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBwb29sVHlwZSArIFwiKFwiICsgcG9vbFR5cGUgKyBcIihcIiArIHBvb2xUeXBlICsgXCIoXCIgK1xuICAgICAgICAgICAgJ21pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pJztcbiAgICAgICAgaWYgKHBvb2xUeXBlID09PSAnYXZnJykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBcImF2Z1ZhbHVlIC8gXCIgKyBmaWx0ZXJIZWlnaHQgKiBmaWx0ZXJXaWR0aCArIFwiLjBcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsdGVyV2lkdGhOZWFyZXN0VmVjNCA9IE1hdGguZmxvb3IoZmlsdGVyV2lkdGggLyA0KSAqIDQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPSBmaWx0ZXJXaWR0aCAlIDQ7XG4gICAgICAgIHZhciB1cGRhdGVTbmlwcGV0ID0gXCJcXG4gICAgICBpZiAoaGFzTmFOKHZhbHVlcykpIHtcXG4gICAgICAgIHNldE91dHB1dChnZXROYU4odmFsdWVzKSk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIGlmIChcIiArIGlzQXZnUG9vbCArIFwiKSB7XFxuICAgICAgICBhdmdWYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWluTWF4VmFsdWUgPSBcIiArIGNvbXBhcmVPcCArIFwiKHZhbHVlcywgbWluTWF4VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIiArIHN0cmlkZUhlaWdodCArIFwiLCBcIiArIHN0cmlkZVdpZHRoICsgXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiICsgaW5pdGlhbGl6YXRpb25WYWx1ZSArIFwiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgeFIsIGludCB4QywgaW50IGQpIHtcXG4gICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyB4TnVtQ29scyArIFwiKSB7XFxuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGdldFgoeFIsIHhDLCBkKTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkcy56O1xcblxcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnh5ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIgKyBpbml0aWFsaXphdGlvblZhbHVlICsgXCIpO1xcbiAgICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgeE51bVJvd3MgKyBcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoTmVhcmVzdFZlYzQgKyBcIjsgd0MgKz0gNCkge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0M7XFxuXFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKHhSLCB4QyArIDEsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoeFIsIHhDICsgMiwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZSh4UiwgeEMgKyAzLCBkKVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIFwiICsgZmlsdGVyV2lkdGhOZWFyZXN0VmVjNCArIFwiO1xcbiAgICAgICAgICBpZiAoXCIgKyAoZmlsdGVyV2lkdGhWZWM0UmVtYWluZGVyID09PSAxKSArIFwiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgICAgfSBlbHNlIGlmIChcIiArIChmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPT09IDIpICsgXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZSh4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoeFIsIHhDICsgMSwgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgICAgfSBlbHNlIGlmIChcIiArIChmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZSh4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoeFIsIHhDICsgMSwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZSh4UiwgeEMgKyAyLCBkKSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChcIiArIHJldHVyblZhbHVlICsgXCIpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBQb29sMkRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuUG9vbDJEUHJvZ3JhbSA9IFBvb2wyRFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb29sX2dwdS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/pool_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/reducesum_gpu.js":
/*!*********************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/reducesum_gpu.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ReduceSumProgram = (function () {\n    function ReduceSumProgram(size) {\n        this.size = size;\n        this.variableNames = ['A'];\n        this.params = [];\n        this.outputShape = [];\n        var sizeNearestVec4 = Math.floor(size / 4) * 4;\n        var sizeVec4Remainder = size % 4;\n        var r1 = sizeNearestVec4;\n        var r2 = sizeNearestVec4 + 1;\n        var r3 = sizeNearestVec4 + 2;\n        this.userCode = \"\\n      void main() {\\n        const vec2 ones2 = vec2(1);\\n        const vec3 ones3 = vec3(1);\\n        const vec4 ones4 = vec4(1);\\n\\n        float sum = 0.0;\\n        for (int i = 0; i < \" + sizeNearestVec4 + \"; i += 4) {\\n          vec4 aVec = vec4(getAFlat(i), getAFlat(i+1),\\n                           getAFlat(i+2), getAFlat(i+3));\\n          sum += dot(ones4, aVec);\\n        }\\n\\n        if (\" + (sizeVec4Remainder === 1) + \") {\\n          sum += getAFlat(\" + r1 + \");\\n        } else if (\" + (sizeVec4Remainder === 2) + \") {\\n          vec2 aVec = vec2(getAFlat(\" + r1 + \"), getAFlat(\" + r2 + \"));\\n          sum += dot(ones2, aVec);\\n        } else if (\" + (sizeVec4Remainder === 3) + \") {\\n          vec3 aVec = vec3(getAFlat(\" + r1 + \"), getAFlat(\" + r2 + \"), getAFlat(\" + r3 + \"));\\n          sum += dot(ones3, aVec);\\n        }\\n\\n        setOutput(sum);\\n      }\\n    \";\n    }\n    return ReduceSumProgram;\n}());\nexports.ReduceSumProgram = ReduceSumProgram;\n//# sourceMappingURL=reducesum_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvcmVkdWNlc3VtX2dwdS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9yZWR1Y2VzdW1fZ3B1LmpzPzdlMWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVkdWNlU3VtUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVkdWNlU3VtUHJvZ3JhbShzaXplKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHZhciBzaXplTmVhcmVzdFZlYzQgPSBNYXRoLmZsb29yKHNpemUgLyA0KSAqIDQ7XG4gICAgICAgIHZhciBzaXplVmVjNFJlbWFpbmRlciA9IHNpemUgJSA0O1xuICAgICAgICB2YXIgcjEgPSBzaXplTmVhcmVzdFZlYzQ7XG4gICAgICAgIHZhciByMiA9IHNpemVOZWFyZXN0VmVjNCArIDE7XG4gICAgICAgIHZhciByMyA9IHNpemVOZWFyZXN0VmVjNCArIDI7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGNvbnN0IHZlYzIgb25lczIgPSB2ZWMyKDEpO1xcbiAgICAgICAgY29uc3QgdmVjMyBvbmVzMyA9IHZlYzMoMSk7XFxuICAgICAgICBjb25zdCB2ZWM0IG9uZXM0ID0gdmVjNCgxKTtcXG5cXG4gICAgICAgIGZsb2F0IHN1bSA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIgKyBzaXplTmVhcmVzdFZlYzQgKyBcIjsgaSArPSA0KSB7XFxuICAgICAgICAgIHZlYzQgYVZlYyA9IHZlYzQoZ2V0QUZsYXQoaSksIGdldEFGbGF0KGkrMSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QUZsYXQoaSsyKSwgZ2V0QUZsYXQoaSszKSk7XFxuICAgICAgICAgIHN1bSArPSBkb3Qob25lczQsIGFWZWMpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKFwiICsgKHNpemVWZWM0UmVtYWluZGVyID09PSAxKSArIFwiKSB7XFxuICAgICAgICAgIHN1bSArPSBnZXRBRmxhdChcIiArIHIxICsgXCIpO1xcbiAgICAgICAgfSBlbHNlIGlmIChcIiArIChzaXplVmVjNFJlbWFpbmRlciA9PT0gMikgKyBcIikge1xcbiAgICAgICAgICB2ZWMyIGFWZWMgPSB2ZWMyKGdldEFGbGF0KFwiICsgcjEgKyBcIiksIGdldEFGbGF0KFwiICsgcjIgKyBcIikpO1xcbiAgICAgICAgICBzdW0gKz0gZG90KG9uZXMyLCBhVmVjKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoc2l6ZVZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgICAgdmVjMyBhVmVjID0gdmVjMyhnZXRBRmxhdChcIiArIHIxICsgXCIpLCBnZXRBRmxhdChcIiArIHIyICsgXCIpLCBnZXRBRmxhdChcIiArIHIzICsgXCIpKTtcXG4gICAgICAgICAgc3VtICs9IGRvdChvbmVzMywgYVZlYyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQoc3VtKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUmVkdWNlU3VtUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlJlZHVjZVN1bVByb2dyYW0gPSBSZWR1Y2VTdW1Qcm9ncmFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdWNlc3VtX2dwdS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/reducesum_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/render_ndarray_gpu_util.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/render_ndarray_gpu_util.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar webgl_util = __webpack_require__(/*! ./webgl_util */ \"./node_modules/deeplearn/dist/src/math/webgl/webgl_util.js\");\nfunction getRenderRGBShader(gpgpu, destinationWidth) {\n    var fragmentShaderSource = \"\\n    precision highp float;\\n    uniform sampler2D source;\\n    varying vec2 resultUV;\\n\\n    const float destinationWidth = \" + destinationWidth + \".0;\\n    const float a = 1.0;\\n\\n    void main() {\\n      float xr = floor(resultUV.s * destinationWidth) * 3.0;\\n      vec3 x = xr + vec3(0, 1, 2);\\n\\n      float sourceWidth = destinationWidth * 3.0;\\n      vec3 u = (x + 0.5) / sourceWidth;\\n      float v = 1.0 - resultUV.t;\\n\\n      float r = texture2D(source, vec2(u[0], v)).r;\\n      float g = texture2D(source, vec2(u[1], v)).r;\\n      float b = texture2D(source, vec2(u[2], v)).r;\\n\\n      gl_FragColor = vec4(r, g, b, a);\\n    }\";\n    return gpgpu.createProgram(fragmentShaderSource);\n}\nexports.getRenderRGBShader = getRenderRGBShader;\nfunction renderToCanvas(gpgpu, renderShader, sourceTex) {\n    webgl_util.bindCanvasToFramebuffer(gpgpu.gl);\n    renderToFramebuffer(gpgpu, renderShader, sourceTex);\n}\nexports.renderToCanvas = renderToCanvas;\nfunction renderToFramebuffer(gpgpu, renderShader, sourceTex) {\n    gpgpu.setProgram(renderShader);\n    var sourceSamplerLocation = webgl_util.getProgramUniformLocationOrThrow(gpgpu.gl, renderShader, 'source');\n    gpgpu.setInputMatrixTexture(sourceTex, sourceSamplerLocation, 0);\n    gpgpu.executeProgram();\n}\nexports.renderToFramebuffer = renderToFramebuffer;\n//# sourceMappingURL=render_ndarray_gpu_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvcmVuZGVyX25kYXJyYXlfZ3B1X3V0aWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvcmVuZGVyX25kYXJyYXlfZ3B1X3V0aWwuanM/OWFhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3ZWJnbF91dGlsID0gcmVxdWlyZShcIi4vd2ViZ2xfdXRpbFwiKTtcbmZ1bmN0aW9uIGdldFJlbmRlclJHQlNoYWRlcihncGdwdSwgZGVzdGluYXRpb25XaWR0aCkge1xuICAgIHZhciBmcmFnbWVudFNoYWRlclNvdXJjZSA9IFwiXFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgc291cmNlO1xcbiAgICB2YXJ5aW5nIHZlYzIgcmVzdWx0VVY7XFxuXFxuICAgIGNvbnN0IGZsb2F0IGRlc3RpbmF0aW9uV2lkdGggPSBcIiArIGRlc3RpbmF0aW9uV2lkdGggKyBcIi4wO1xcbiAgICBjb25zdCBmbG9hdCBhID0gMS4wO1xcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgZmxvYXQgeHIgPSBmbG9vcihyZXN1bHRVVi5zICogZGVzdGluYXRpb25XaWR0aCkgKiAzLjA7XFxuICAgICAgdmVjMyB4ID0geHIgKyB2ZWMzKDAsIDEsIDIpO1xcblxcbiAgICAgIGZsb2F0IHNvdXJjZVdpZHRoID0gZGVzdGluYXRpb25XaWR0aCAqIDMuMDtcXG4gICAgICB2ZWMzIHUgPSAoeCArIDAuNSkgLyBzb3VyY2VXaWR0aDtcXG4gICAgICBmbG9hdCB2ID0gMS4wIC0gcmVzdWx0VVYudDtcXG5cXG4gICAgICBmbG9hdCByID0gdGV4dHVyZTJEKHNvdXJjZSwgdmVjMih1WzBdLCB2KSkucjtcXG4gICAgICBmbG9hdCBnID0gdGV4dHVyZTJEKHNvdXJjZSwgdmVjMih1WzFdLCB2KSkucjtcXG4gICAgICBmbG9hdCBiID0gdGV4dHVyZTJEKHNvdXJjZSwgdmVjMih1WzJdLCB2KSkucjtcXG5cXG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHIsIGcsIGIsIGEpO1xcbiAgICB9XCI7XG4gICAgcmV0dXJuIGdwZ3B1LmNyZWF0ZVByb2dyYW0oZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xufVxuZXhwb3J0cy5nZXRSZW5kZXJSR0JTaGFkZXIgPSBnZXRSZW5kZXJSR0JTaGFkZXI7XG5mdW5jdGlvbiByZW5kZXJUb0NhbnZhcyhncGdwdSwgcmVuZGVyU2hhZGVyLCBzb3VyY2VUZXgpIHtcbiAgICB3ZWJnbF91dGlsLmJpbmRDYW52YXNUb0ZyYW1lYnVmZmVyKGdwZ3B1LmdsKTtcbiAgICByZW5kZXJUb0ZyYW1lYnVmZmVyKGdwZ3B1LCByZW5kZXJTaGFkZXIsIHNvdXJjZVRleCk7XG59XG5leHBvcnRzLnJlbmRlclRvQ2FudmFzID0gcmVuZGVyVG9DYW52YXM7XG5mdW5jdGlvbiByZW5kZXJUb0ZyYW1lYnVmZmVyKGdwZ3B1LCByZW5kZXJTaGFkZXIsIHNvdXJjZVRleCkge1xuICAgIGdwZ3B1LnNldFByb2dyYW0ocmVuZGVyU2hhZGVyKTtcbiAgICB2YXIgc291cmNlU2FtcGxlckxvY2F0aW9uID0gd2ViZ2xfdXRpbC5nZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdyhncGdwdS5nbCwgcmVuZGVyU2hhZGVyLCAnc291cmNlJyk7XG4gICAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKHNvdXJjZVRleCwgc291cmNlU2FtcGxlckxvY2F0aW9uLCAwKTtcbiAgICBncGdwdS5leGVjdXRlUHJvZ3JhbSgpO1xufVxuZXhwb3J0cy5yZW5kZXJUb0ZyYW1lYnVmZmVyID0gcmVuZGVyVG9GcmFtZWJ1ZmZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlcl9uZGFycmF5X2dwdV91dGlsLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/render_ndarray_gpu_util.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/resize_bilinear_gpu.js":
/*!***************************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/resize_bilinear_gpu.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ResizeBilinear3DProgram = (function () {\n    function ResizeBilinear3DProgram(inputShape, outputDimensionsRowCol, alignCorners) {\n        this.variableNames = ['A'];\n        this.params = [];\n        this.outputShape = [];\n        var depth = inputShape[2];\n        this.outputShape =\n            [outputDimensionsRowCol[0], outputDimensionsRowCol[1], depth];\n        this.params = [alignCorners];\n        var effectiveInputShape = alignCorners ?\n            [inputShape[0] - 1, inputShape[1] - 1, depth] :\n            inputShape;\n        var effectiveOutputShape = alignCorners ?\n            [this.outputShape[0] - 1, this.outputShape[1] - 1, depth] :\n            this.outputShape;\n        this.userCode = \"\\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\\n          \" + effectiveInputShape[0] /\n            effectiveOutputShape[0] + \",\\n          \" + effectiveInputShape[1] /\n            effectiveOutputShape[1] + \");\\n      const vec2 inputShapeRC = vec2(\" + inputShape[0] + \".0, \" + inputShape[1] + \".0);\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        ivec2 yRC = coords.xy;\\n        int d = coords.z;\\n\\n        // Fractional source index.\\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the four integer indices.\\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\\n        ivec2 sourceCeilRC = ivec2(\\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\\n\\n        float topLeft = getA(sourceFloorRC.x, sourceFloorRC.y, d);\\n        float bottomLeft = getA(sourceCeilRC.x, sourceFloorRC.y, d);\\n        float topRight = getA(sourceFloorRC.x, sourceCeilRC.y, d);\\n        float bottomRight = getA(sourceCeilRC.x, sourceCeilRC.y, d);\\n\\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\\n\\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\\n        float newValue = top + (bottom - top) * fracRC.x;\\n\\n        setOutput(newValue);\\n      }\\n    \";\n    }\n    return ResizeBilinear3DProgram;\n}());\nexports.ResizeBilinear3DProgram = ResizeBilinear3DProgram;\n//# sourceMappingURL=resize_bilinear_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvcmVzaXplX2JpbGluZWFyX2dwdS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC9yZXNpemVfYmlsaW5lYXJfZ3B1LmpzPzAyZDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVzaXplQmlsaW5lYXIzRFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc2l6ZUJpbGluZWFyM0RQcm9ncmFtKGlucHV0U2hhcGUsIG91dHB1dERpbWVuc2lvbnNSb3dDb2wsIGFsaWduQ29ybmVycykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBbXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB2YXIgZGVwdGggPSBpbnB1dFNoYXBlWzJdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID1cbiAgICAgICAgICAgIFtvdXRwdXREaW1lbnNpb25zUm93Q29sWzBdLCBvdXRwdXREaW1lbnNpb25zUm93Q29sWzFdLCBkZXB0aF07XG4gICAgICAgIHRoaXMucGFyYW1zID0gW2FsaWduQ29ybmVyc107XG4gICAgICAgIHZhciBlZmZlY3RpdmVJbnB1dFNoYXBlID0gYWxpZ25Db3JuZXJzID9cbiAgICAgICAgICAgIFtpbnB1dFNoYXBlWzBdIC0gMSwgaW5wdXRTaGFwZVsxXSAtIDEsIGRlcHRoXSA6XG4gICAgICAgICAgICBpbnB1dFNoYXBlO1xuICAgICAgICB2YXIgZWZmZWN0aXZlT3V0cHV0U2hhcGUgPSBhbGlnbkNvcm5lcnMgP1xuICAgICAgICAgICAgW3RoaXMub3V0cHV0U2hhcGVbMF0gLSAxLCB0aGlzLm91dHB1dFNoYXBlWzFdIC0gMSwgZGVwdGhdIDpcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IHZlYzIgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyA9IHZlYzIoXFxuICAgICAgICAgIFwiICsgZWZmZWN0aXZlSW5wdXRTaGFwZVswXSAvXG4gICAgICAgICAgICBlZmZlY3RpdmVPdXRwdXRTaGFwZVswXSArIFwiLFxcbiAgICAgICAgICBcIiArIGVmZmVjdGl2ZUlucHV0U2hhcGVbMV0gL1xuICAgICAgICAgICAgZWZmZWN0aXZlT3V0cHV0U2hhcGVbMV0gKyBcIik7XFxuICAgICAgY29uc3QgdmVjMiBpbnB1dFNoYXBlUkMgPSB2ZWMyKFwiICsgaW5wdXRTaGFwZVswXSArIFwiLjAsIFwiICsgaW5wdXRTaGFwZVsxXSArIFwiLjApO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaXZlYzIgeVJDID0gY29vcmRzLnh5O1xcbiAgICAgICAgaW50IGQgPSBjb29yZHMuejtcXG5cXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxcbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhSQyA9IHZlYzIoeVJDKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkM7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cXG4gICAgICAgIGl2ZWMyIHNvdXJjZUZsb29yUkMgPSBpdmVjMihzb3VyY2VGcmFjSW5kZXhSQyk7XFxuICAgICAgICBpdmVjMiBzb3VyY2VDZWlsUkMgPSBpdmVjMihcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgY2VpbChzb3VyY2VGcmFjSW5kZXhSQykpKTtcXG5cXG4gICAgICAgIGZsb2F0IHRvcExlZnQgPSBnZXRBKHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbUxlZnQgPSBnZXRBKHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgdG9wUmlnaHQgPSBnZXRBKHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgYm90dG9tUmlnaHQgPSBnZXRBKHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCk7XFxuXFxuICAgICAgICB2ZWMyIGZyYWNSQyA9IHNvdXJjZUZyYWNJbmRleFJDIC0gdmVjMihzb3VyY2VGbG9vclJDKTtcXG5cXG4gICAgICAgIGZsb2F0IHRvcCA9IHRvcExlZnQgKyAodG9wUmlnaHQgLSB0b3BMZWZ0KSAqIGZyYWNSQy55O1xcbiAgICAgICAgZmxvYXQgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogZnJhY1JDLnk7XFxuICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IHRvcCArIChib3R0b20gLSB0b3ApICogZnJhY1JDLng7XFxuXFxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBSZXNpemVCaWxpbmVhcjNEUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlJlc2l6ZUJpbGluZWFyM0RQcm9ncmFtID0gUmVzaXplQmlsaW5lYXIzRFByb2dyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNpemVfYmlsaW5lYXJfZ3B1LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/resize_bilinear_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/shader_compiler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/shader_compiler.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar environment_1 = __webpack_require__(/*! ../../environment */ \"./node_modules/deeplearn/dist/src/environment.js\");\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar tex_util = __webpack_require__(/*! ./tex_util */ \"./node_modules/deeplearn/dist/src/math/webgl/tex_util.js\");\nfunction makeShader(inputsInfo, outputShape, userCode, broadcast) {\n    var sampleSnippet = getSampleSnippet();\n    var setOutputSnippet = getSetOutputSnippet();\n    var inputPrefixSnippet = inputsInfo.map(function (x) { return \"uniform sampler2D \" + x.name + \";\"; }).join('\\n');\n    var inputSamplingSnippet = inputsInfo.map(function (x) { return getInputSamplingSnippet(x, outputShape, broadcast); })\n        .join('\\n');\n    var outTexShape = outputShape.texShape;\n    var outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n    var source = [\n        SHADER_PREFIX, sampleSnippet, setOutputSnippet, inputPrefixSnippet,\n        inputSamplingSnippet, outputSamplingSnippet, userCode\n    ].join('\\n');\n    return source;\n}\nexports.makeShader = makeShader;\nfunction getSampleSnippet() {\n    return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?\n        FLOAT_TEXTURE_SAMPLE_SNIPPET :\n        UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET;\n}\nfunction getSetOutputSnippet() {\n    return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?\n        FLOAT_TEXTURE_SETOUTPUT_SNIPPET :\n        UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET;\n}\nfunction getInputSamplingSnippet(inInfo, outShapeInfo, broadcast) {\n    var shape = inInfo.shapeInfo.logicalShape;\n    var texShape = inInfo.shapeInfo.texShape;\n    var outTexShape = outShapeInfo.texShape;\n    var res = '';\n    switch (shape.length) {\n        case 0:\n            res += getSamplerScalar(inInfo.name);\n            break;\n        case 1:\n            res += getSampler1D(inInfo.name, texShape);\n            break;\n        case 2:\n            res += getSampler2D(inInfo.name, shape, texShape);\n            break;\n        case 3:\n            res += getSampler3D(inInfo.name, shape, texShape);\n            break;\n        case 4:\n            res += getSampler4D(inInfo.name, shape, texShape);\n            break;\n        default:\n            throw new Error(shape.length + \"-D input sampling\" +\n                \" is not yet supported\");\n    }\n    if (broadcast ||\n        util.arraysEqual(inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {\n        res +=\n            getSamplerAtOutputCoords(inInfo.name, texShape, outTexShape, broadcast);\n    }\n    res += getSamplerFlat(inInfo.name, texShape);\n    return res;\n}\nfunction getOutputSamplingSnippet(outShape, outTexShape) {\n    switch (outShape.length) {\n        case 0:\n            return '';\n        case 1:\n            return getOutput1DCoords(outShape, outTexShape);\n        case 2:\n            return getOutput2DCoords(outShape, outTexShape);\n        case 3:\n            return getOutput3DCoords(outShape, outTexShape);\n        case 4:\n            return getOutput4DCoords(outShape, outTexShape);\n        default:\n            throw new Error(outShape.length + \"-D output sampling is not yet supported\");\n    }\n}\nvar SAMPLE_1D_SNIPPET = \"\\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\";\nvar SAMPLE_2D_SNIPPET = \"\\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\\n  int index = row * numC + col;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\";\nvar SAMPLE_3D_SNIPPET = \"\\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\\n    int stride1, int row, int col, int depth) {\\n  int index = row * stride0 + col * stride1 + depth;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\";\nvar SAMPLE_4D_SNIPPET = \"\\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\\n    int stride1, int stride2, int row, int col, int depth,\\n    int depth2) {\\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\";\nvar UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET = \"\\n  uniform float NaN;\\n\\n  const vec4 floatDeltas = vec4(\\n      1.0,\\n      1.0 / 255.0,\\n      1.0 / (255.0 * 255.0),\\n      1.0 / (255.0 * 255.0 * 255.0)\\n  );\\n  const float minValue = \" + tex_util.FLOAT_MIN + \".0;\\n  const float maxValue = \" + tex_util.FLOAT_MAX + \".0;\\n  const float range = (maxValue - minValue) / 255.0;\\n  const vec2 dotRange = vec2(1.0, range);\\n\\n  float sample(sampler2D texture, vec2 uv) {\\n    vec4 sampleValue = texture2D(texture, uv);\\n    if (all(equal(sampleValue, vec4(\" + tex_util.BYTE_NAN_VALUE + \")))) {\\n      return NaN;\\n    }\\n\\n    vec4 encValue = floor(sampleValue * 255.0 + 0.5);\\n    float decodedValue = dot(encValue, floatDeltas);\\n    return dot(vec2(minValue, decodedValue), dotRange);\\n  }\\n\";\nvar UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET = \"\\n  const vec4 floatPowers = vec4(\\n    1.0,\\n    255.0,\\n    255.0 * 255.0,\\n    255.0 * 255.0 * 255.0\\n  );\\n  const vec2 recipRange = vec2(1.0/range);\\n  const vec2 recipRange255 = vec2(1.0/(maxValue - minValue));\\n\\n  void setOutput(float decodedValue) {\\n    if (isNaN(decodedValue)) {\\n      gl_FragColor = vec4(\" + tex_util.BYTE_NAN_VALUE + \");\\n      return;\\n    }\\n\\n    float a = dot(vec2(decodedValue, -minValue), recipRange);\\n    float b = fract(a) * 255.0;\\n    float c = fract(b) * 255.0;\\n    float d = fract(c) * 255.0;\\n    gl_FragColor = floor(vec4(a, b, c, d)) / 255.0;\\n\\n    // TODO(dsmilkov): Version above gets better accuracy but probably slower\\n    // than the version below. Benchmark to determine if the accuracy is worth\\n    // the cost.\\n\\n    // float normValue = dot(vec2(decodedValue, -minValue), recipRange255);\\n    // vec4 f = normValue * floatPowers;\\n    // gl_FragColor = floor(fract(f) * 255.0) / 255.0;\\n  }\\n\";\nvar FLOAT_TEXTURE_SAMPLE_SNIPPET = \"\\n  float sample(sampler2D texture, vec2 uv) {\\n    return texture2D(texture, uv).r;\\n  }\\n\";\nvar FLOAT_TEXTURE_SETOUTPUT_SNIPPET = \"\\n  void setOutput(float val) {\\n    gl_FragColor = vec4(val, 0, 0, 0);\\n  }\\n\";\nvar SHADER_PREFIX = \"\\n  precision highp float;\\n  precision highp int;\\n  varying vec2 resultUV;\\n  const vec2 halfCR = vec2(0.5, 0.5);\\n\\n  bool isNaN(float val) {\\n    return val == val ? false : true;\\n  }\\n\\n  bool hasNaN(vec4 values) {\\n    return any(notEqual(values, values));\\n  }\\n\\n  float getNaN(vec4 values) {\\n    return dot(vec4(1), values);\\n  }\\n\\n  int round(float value) {\\n    return int(floor(value + 0.5));\\n  }\\n\\n  const vec2 randomConst = vec2(\\n    23.14069263277926, // e^pi (Gelfond's constant)\\n     2.665144142690225 // 2^sqrt(2) (Gelfond\\u2013Schneider constant)\\n  );\\n\\n  float random(float seed) {\\n      return fract(cos(dot(resultUV * seed, randomConst)) * 12345.6789);\\n  }\\n\\n  \" + SAMPLE_1D_SNIPPET + \"\\n  \" + SAMPLE_2D_SNIPPET + \"\\n  \" + SAMPLE_3D_SNIPPET + \"\\n  \" + SAMPLE_4D_SNIPPET + \"\\n\";\nfunction getOutput1DCoords(shape, texShape) {\n    if (texShape[0] === 1) {\n        return \"\\n      int getOutputCoords() {\\n        return int(resultUV.x * \" + texShape[1] + \".0);\\n      }\\n    \";\n    }\n    if (texShape[1] === 1) {\n        return \"\\n      int getOutputCoords() {\\n        return int(resultUV.y * \" + texShape[0] + \".0);\\n      }\\n    \";\n    }\n    return \"\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      return resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n    }\\n  \";\n}\nfunction getOutput3DCoords(shape, texShape) {\n    var stride0 = shape[1] * shape[2];\n    var stride1 = shape[2];\n    return \"\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n      int r = index / \" + stride0 + \";\\n      index -= r * \" + stride0 + \";\\n      int c = index / \" + stride1 + \";\\n      int d = index - c * \" + stride1 + \";\\n      return ivec3(r, c, d);\\n    }\\n  \";\n}\nfunction getOutput4DCoords(shape, texShape) {\n    var stride2 = shape[3];\n    var stride1 = shape[2] * stride2;\n    var stride0 = shape[1] * stride1;\n    return \"\\n    ivec4 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n\\n      int r = index / \" + stride0 + \";\\n      index -= r * \" + stride0 + \";\\n\\n      int c = index / \" + stride1 + \";\\n      index -= c * \" + stride1 + \";\\n\\n      int d = index / \" + stride2 + \";\\n      int d2 = index - d * \" + stride2 + \";\\n\\n      return ivec4(r, c, d, d2);\\n    }\\n  \";\n}\nfunction getOutput2DCoords(shape, texShape) {\n    if (util.arraysEqual(shape, texShape)) {\n        return \"\\n      ivec2 getOutputCoords() {\\n        return ivec2(resultUV.yx * vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      }\\n    \";\n    }\n    if (shape[1] === 1) {\n        return \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n        int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n        return ivec2(index, 0);\\n      }\\n    \";\n    }\n    if (shape[0] === 1) {\n        return \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n        int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n        return ivec2(0, index);\\n      }\\n    \";\n    }\n    return \"\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + texShape[0] + \", \" + texShape[1] + \"));\\n      int index = resTexRC.x * \" + texShape[1] + \" + resTexRC.y;\\n      int r = index / \" + shape[1] + \";\\n      int c = index - r * \" + shape[1] + \";\\n      return ivec2(r, c);\\n    }\\n  \";\n}\nfunction getSamplerScalar(texName) {\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    return \"\\n    float \" + funcName + \"() {\\n      return sample(\" + texName + \", halfCR);\\n    }\\n  \";\n}\nfunction getSampler1D(texName, texShape) {\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var tR = texShape[0];\n    var tC = texShape[1];\n    if (texShape[0] === 1 && texShape[1] === 1) {\n        return \"\\n      float \" + funcName + \"(int index) {\\n        return sample(\" + texName + \", halfCR);\\n      }\\n    \";\n    }\n    if (texShape[1] === 1) {\n        return \"\\n      float \" + funcName + \"(int index) {\\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / \" + tR + \".0);\\n        return sample(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    if (texShape[0] === 1) {\n        return \"\\n      float \" + funcName + \"(int index) {\\n        vec2 uv = vec2((float(index) + 0.5) / \" + tC + \".0, 0.5);\\n        return sample(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    return \"\\n    float \" + funcName + \"(int index) {\\n      vec2 uv = UVfrom1D(\" + tR + \", \" + tC + \", index);\\n      return sample(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getSampler3D(texName, shape, texShape) {\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var tR = texShape[0];\n    var tC = texShape[1];\n    var stride0 = shape[1] * shape[2];\n    var stride1 = shape[2];\n    if (tC === stride0) {\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth) {\\n        int texR = row;\\n        int texC = col * \" + stride1 + \" + depth;\\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + tC + \".0, \" + tR + \".0);\\n        return sample(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    return \"\\n    float \" + funcName + \"(int row, int col, int depth) {\\n      vec2 uv = UVfrom3D(\" + tR + \", \" + tC + \", \" + stride0 + \", \" + stride1 + \", row, col, depth);\\n      return sample(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getSampler4D(texName, shape, texShape) {\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var tR = texShape[0];\n    var tC = texShape[1];\n    var stride2 = shape[3];\n    var stride1 = shape[2] * stride2;\n    var stride0 = shape[1] * stride1;\n    if (tC === stride0) {\n        return \"\\n      float \" + funcName + \"(int row, int col, int depth, int depth2) {\\n        int texR = row;\\n        int texC = col * \" + stride1 + \" + depth * \" + stride2 + \" + depth2;\\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + tC + \".0, \" + tR + \".0);\\n        return sample(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    return \"\\n    float \" + funcName + \"(int row, int col, int depth, int depth2) {\\n      vec2 uv = UVfrom4D(\" + tR + \", \" + tC + \", \" + stride0 + \", \" + stride1 + \", \" + stride2 + \",\\n          row, col, depth, depth2);\\n      return sample(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getSampler2D(texName, shape, texShape) {\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    var tR = texShape[0];\n    var tC = texShape[1];\n    if (util.arraysEqual(shape, texShape)) {\n        return \"\\n      float \" + funcName + \"(int row, int col) {\\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(\" + tC + \".0, \" + tR + \".0);\\n        return sample(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    if (tC === 1) {\n        if (shape[0] === 1) {\n            return \"\\n        float \" + funcName + \"(int row, int col) {\\n          vec2 uv = vec2(0.5, (float(col) + 0.5) / \" + tR + \".0);\\n          return sample(\" + texName + \", uv);\\n        }\\n      \";\n        }\n        if (shape[1] === 1) {\n            return \"\\n        float \" + funcName + \"(int row, int col) {\\n          vec2 uv = vec2(0.5, (float(row) + 0.5) / \" + tR + \".0);\\n          return sample(\" + texName + \", uv);\\n        }\\n      \";\n        }\n        return \"\\n      float \" + funcName + \"(int row, int col) {\\n        int index = row * \" + shape[1] + \" + col;\\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / \" + tR + \".0);\\n        return sample(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    if (tR === 1) {\n        return \"\\n      float \" + funcName + \"(int row, int col) {\\n        int index = row * \" + shape[1] + \" + col;\\n        vec2 uv = vec2((float(index) + 0.5) / \" + tC + \".0, 0.5);\\n        return sample(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    return \"\\n    float \" + funcName + \"(int row, int col) {\\n      vec2 uv = UVfrom2D(\" + tR + \", \" + tC + \", \" + shape[1] + \", row, col);\\n      return sample(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getSamplerFlat(texName, texShape) {\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) + 'Flat';\n    var tNumR = texShape[0];\n    var tNumC = texShape[1];\n    if (tNumC === 1 && tNumR === 1) {\n        return \"\\n      float \" + funcName + \"(int index) {\\n        return sample(\" + texName + \", halfCR);\\n      }\\n    \";\n    }\n    if (tNumC === 1) {\n        return \"\\n      float \" + funcName + \"(int index) {\\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / \" + tNumR + \".0);\\n        return sample(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    if (tNumR === 1) {\n        return \"\\n      float \" + funcName + \"(int index) {\\n        vec2 uv = vec2((float(index) + 0.5) / \" + tNumC + \".0, 0.5);\\n        return sample(\" + texName + \", uv);\\n      }\\n    \";\n    }\n    return \"\\n    float \" + funcName + \"(int index) {\\n      int texR = index / \" + tNumC + \";\\n      int texC = index - texR * \" + tNumC + \";\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + tNumC + \".0, \" + tNumR + \".0);\\n      return sample(\" + texName + \", uv);\\n    }\\n  \";\n}\nfunction getSamplerAtOutputCoords(texName, inTexShape, outTexShape, broadcast) {\n    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) +\n        'AtOutCoords';\n    if (util.arraysEqual(inTexShape, outTexShape)) {\n        return \"\\n      float \" + funcName + \"() {\\n        return sample(\" + texName + \", resultUV);\\n      }\\n    \";\n    }\n    var inSize = util.sizeFromShape(inTexShape);\n    var broadcastSnippet = '';\n    if (broadcast) {\n        broadcastSnippet = \"\\n      int mainPart = index / \" + inSize + \";\\n      index -= mainPart * \" + inSize + \";\\n    \";\n    }\n    return \"\\n    float \" + funcName + \"() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + outTexShape[0] + \", \" + outTexShape[1] + \"));\\n      int index = resTexRC.x * \" + outTexShape[1] + \" + resTexRC.y;\\n      \" + broadcastSnippet + \"\\n      int texR = index / \" + inTexShape[1] + \";\\n      int texC = index - texR * \" + inTexShape[1] + \";\\n      vec2 uv = (vec2(texC, texR) + halfCR) /\\n                 vec2(\" + inTexShape[1] + \".0, \" + inTexShape[0] + \".0);\\n      return sample(\" + texName + \", uv);\\n    }\\n  \";\n}\n//# sourceMappingURL=shader_compiler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvc2hhZGVyX2NvbXBpbGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL3NoYWRlcl9jb21waWxlci5qcz9hM2Q2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIHRleF91dGlsID0gcmVxdWlyZShcIi4vdGV4X3V0aWxcIik7XG5mdW5jdGlvbiBtYWtlU2hhZGVyKGlucHV0c0luZm8sIG91dHB1dFNoYXBlLCB1c2VyQ29kZSwgYnJvYWRjYXN0KSB7XG4gICAgdmFyIHNhbXBsZVNuaXBwZXQgPSBnZXRTYW1wbGVTbmlwcGV0KCk7XG4gICAgdmFyIHNldE91dHB1dFNuaXBwZXQgPSBnZXRTZXRPdXRwdXRTbmlwcGV0KCk7XG4gICAgdmFyIGlucHV0UHJlZml4U25pcHBldCA9IGlucHV0c0luZm8ubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBcInVuaWZvcm0gc2FtcGxlcjJEIFwiICsgeC5uYW1lICsgXCI7XCI7IH0pLmpvaW4oJ1xcbicpO1xuICAgIHZhciBpbnB1dFNhbXBsaW5nU25pcHBldCA9IGlucHV0c0luZm8ubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBnZXRJbnB1dFNhbXBsaW5nU25pcHBldCh4LCBvdXRwdXRTaGFwZSwgYnJvYWRjYXN0KTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIHZhciBvdXRUZXhTaGFwZSA9IG91dHB1dFNoYXBlLnRleFNoYXBlO1xuICAgIHZhciBvdXRwdXRTYW1wbGluZ1NuaXBwZXQgPSBnZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQob3V0cHV0U2hhcGUubG9naWNhbFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgdmFyIHNvdXJjZSA9IFtcbiAgICAgICAgU0hBREVSX1BSRUZJWCwgc2FtcGxlU25pcHBldCwgc2V0T3V0cHV0U25pcHBldCwgaW5wdXRQcmVmaXhTbmlwcGV0LFxuICAgICAgICBpbnB1dFNhbXBsaW5nU25pcHBldCwgb3V0cHV0U2FtcGxpbmdTbmlwcGV0LCB1c2VyQ29kZVxuICAgIF0uam9pbignXFxuJyk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbn1cbmV4cG9ydHMubWFrZVNoYWRlciA9IG1ha2VTaGFkZXI7XG5mdW5jdGlvbiBnZXRTYW1wbGVTbmlwcGV0KCkge1xuICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpID9cbiAgICAgICAgRkxPQVRfVEVYVFVSRV9TQU1QTEVfU05JUFBFVCA6XG4gICAgICAgIFVOU0lHTkVEX0JZVEVfVEVYVFVSRV9TQU1QTEVfU05JUFBFVDtcbn1cbmZ1bmN0aW9uIGdldFNldE91dHB1dFNuaXBwZXQoKSB7XG4gICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykgP1xuICAgICAgICBGTE9BVF9URVhUVVJFX1NFVE9VVFBVVF9TTklQUEVUIDpcbiAgICAgICAgVU5TSUdORURfQllURV9URVhUVVJFX1NFVE9VVFBVVF9TTklQUEVUO1xufVxuZnVuY3Rpb24gZ2V0SW5wdXRTYW1wbGluZ1NuaXBwZXQoaW5JbmZvLCBvdXRTaGFwZUluZm8sIGJyb2FkY2FzdCkge1xuICAgIHZhciBzaGFwZSA9IGluSW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlO1xuICAgIHZhciB0ZXhTaGFwZSA9IGluSW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gICAgdmFyIG91dFRleFNoYXBlID0gb3V0U2hhcGVJbmZvLnRleFNoYXBlO1xuICAgIHZhciByZXMgPSAnJztcbiAgICBzd2l0Y2ggKHNoYXBlLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXMgKz0gZ2V0U2FtcGxlclNjYWxhcihpbkluZm8ubmFtZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmVzICs9IGdldFNhbXBsZXIxRChpbkluZm8ubmFtZSwgdGV4U2hhcGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJlcyArPSBnZXRTYW1wbGVyMkQoaW5JbmZvLm5hbWUsIHNoYXBlLCB0ZXhTaGFwZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmVzICs9IGdldFNhbXBsZXIzRChpbkluZm8ubmFtZSwgc2hhcGUsIHRleFNoYXBlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXMgKz0gZ2V0U2FtcGxlcjREKGluSW5mby5uYW1lLCBzaGFwZSwgdGV4U2hhcGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc2hhcGUubGVuZ3RoICsgXCItRCBpbnB1dCBzYW1wbGluZ1wiICtcbiAgICAgICAgICAgICAgICBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKGJyb2FkY2FzdCB8fFxuICAgICAgICB1dGlsLmFycmF5c0VxdWFsKGluSW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlLCBvdXRTaGFwZUluZm8ubG9naWNhbFNoYXBlKSkge1xuICAgICAgICByZXMgKz1cbiAgICAgICAgICAgIGdldFNhbXBsZXJBdE91dHB1dENvb3JkcyhpbkluZm8ubmFtZSwgdGV4U2hhcGUsIG91dFRleFNoYXBlLCBicm9hZGNhc3QpO1xuICAgIH1cbiAgICByZXMgKz0gZ2V0U2FtcGxlckZsYXQoaW5JbmZvLm5hbWUsIHRleFNoYXBlKTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0U2FtcGxpbmdTbmlwcGV0KG91dFNoYXBlLCBvdXRUZXhTaGFwZSkge1xuICAgIHN3aXRjaCAob3V0U2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dDFEQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXQyRENvb3JkcyhvdXRTaGFwZSwgb3V0VGV4U2hhcGUpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0cHV0M0RDb29yZHMob3V0U2hhcGUsIG91dFRleFNoYXBlKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dDREQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3V0U2hhcGUubGVuZ3RoICsgXCItRCBvdXRwdXQgc2FtcGxpbmcgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxufVxudmFyIFNBTVBMRV8xRF9TTklQUEVUID0gXCJcXG52ZWMyIFVWZnJvbTFEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIjtcbnZhciBTQU1QTEVfMkRfU05JUFBFVCA9IFwiXFxudmVjMiBVVmZyb20yRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBudW1DLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICBpbnQgaW5kZXggPSByb3cgKiBudW1DICsgY29sO1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCI7XG52YXIgU0FNUExFXzNEX1NOSVBQRVQgPSBcIlxcbnZlYzIgVVZmcm9tM0QoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgc3RyaWRlMCxcXG4gICAgaW50IHN0cmlkZTEsIGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgaW50IGluZGV4ID0gcm93ICogc3RyaWRlMCArIGNvbCAqIHN0cmlkZTEgKyBkZXB0aDtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiO1xudmFyIFNBTVBMRV80RF9TTklQUEVUID0gXCJcXG52ZWMyIFVWZnJvbTREKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IHN0cmlkZTAsXFxuICAgIGludCBzdHJpZGUxLCBpbnQgc3RyaWRlMiwgaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICBpbnQgZGVwdGgyKSB7XFxuICBpbnQgaW5kZXggPSByb3cgKiBzdHJpZGUwICsgY29sICogc3RyaWRlMSArIGRlcHRoICogc3RyaWRlMiArIGRlcHRoMjtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiO1xudmFyIFVOU0lHTkVEX0JZVEVfVEVYVFVSRV9TQU1QTEVfU05JUFBFVCA9IFwiXFxuICB1bmlmb3JtIGZsb2F0IE5hTjtcXG5cXG4gIGNvbnN0IHZlYzQgZmxvYXREZWx0YXMgPSB2ZWM0KFxcbiAgICAgIDEuMCxcXG4gICAgICAxLjAgLyAyNTUuMCxcXG4gICAgICAxLjAgLyAoMjU1LjAgKiAyNTUuMCksXFxuICAgICAgMS4wIC8gKDI1NS4wICogMjU1LjAgKiAyNTUuMClcXG4gICk7XFxuICBjb25zdCBmbG9hdCBtaW5WYWx1ZSA9IFwiICsgdGV4X3V0aWwuRkxPQVRfTUlOICsgXCIuMDtcXG4gIGNvbnN0IGZsb2F0IG1heFZhbHVlID0gXCIgKyB0ZXhfdXRpbC5GTE9BVF9NQVggKyBcIi4wO1xcbiAgY29uc3QgZmxvYXQgcmFuZ2UgPSAobWF4VmFsdWUgLSBtaW5WYWx1ZSkgLyAyNTUuMDtcXG4gIGNvbnN0IHZlYzIgZG90UmFuZ2UgPSB2ZWMyKDEuMCwgcmFuZ2UpO1xcblxcbiAgZmxvYXQgc2FtcGxlKHNhbXBsZXIyRCB0ZXh0dXJlLCB2ZWMyIHV2KSB7XFxuICAgIHZlYzQgc2FtcGxlVmFsdWUgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdXYpO1xcbiAgICBpZiAoYWxsKGVxdWFsKHNhbXBsZVZhbHVlLCB2ZWM0KFwiICsgdGV4X3V0aWwuQllURV9OQU5fVkFMVUUgKyBcIikpKSkge1xcbiAgICAgIHJldHVybiBOYU47XFxuICAgIH1cXG5cXG4gICAgdmVjNCBlbmNWYWx1ZSA9IGZsb29yKHNhbXBsZVZhbHVlICogMjU1LjAgKyAwLjUpO1xcbiAgICBmbG9hdCBkZWNvZGVkVmFsdWUgPSBkb3QoZW5jVmFsdWUsIGZsb2F0RGVsdGFzKTtcXG4gICAgcmV0dXJuIGRvdCh2ZWMyKG1pblZhbHVlLCBkZWNvZGVkVmFsdWUpLCBkb3RSYW5nZSk7XFxuICB9XFxuXCI7XG52YXIgVU5TSUdORURfQllURV9URVhUVVJFX1NFVE9VVFBVVF9TTklQUEVUID0gXCJcXG4gIGNvbnN0IHZlYzQgZmxvYXRQb3dlcnMgPSB2ZWM0KFxcbiAgICAxLjAsXFxuICAgIDI1NS4wLFxcbiAgICAyNTUuMCAqIDI1NS4wLFxcbiAgICAyNTUuMCAqIDI1NS4wICogMjU1LjBcXG4gICk7XFxuICBjb25zdCB2ZWMyIHJlY2lwUmFuZ2UgPSB2ZWMyKDEuMC9yYW5nZSk7XFxuICBjb25zdCB2ZWMyIHJlY2lwUmFuZ2UyNTUgPSB2ZWMyKDEuMC8obWF4VmFsdWUgLSBtaW5WYWx1ZSkpO1xcblxcbiAgdm9pZCBzZXRPdXRwdXQoZmxvYXQgZGVjb2RlZFZhbHVlKSB7XFxuICAgIGlmIChpc05hTihkZWNvZGVkVmFsdWUpKSB7XFxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChcIiArIHRleF91dGlsLkJZVEVfTkFOX1ZBTFVFICsgXCIpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBmbG9hdCBhID0gZG90KHZlYzIoZGVjb2RlZFZhbHVlLCAtbWluVmFsdWUpLCByZWNpcFJhbmdlKTtcXG4gICAgZmxvYXQgYiA9IGZyYWN0KGEpICogMjU1LjA7XFxuICAgIGZsb2F0IGMgPSBmcmFjdChiKSAqIDI1NS4wO1xcbiAgICBmbG9hdCBkID0gZnJhY3QoYykgKiAyNTUuMDtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gZmxvb3IodmVjNChhLCBiLCBjLCBkKSkgLyAyNTUuMDtcXG5cXG4gICAgLy8gVE9ETyhkc21pbGtvdik6IFZlcnNpb24gYWJvdmUgZ2V0cyBiZXR0ZXIgYWNjdXJhY3kgYnV0IHByb2JhYmx5IHNsb3dlclxcbiAgICAvLyB0aGFuIHRoZSB2ZXJzaW9uIGJlbG93LiBCZW5jaG1hcmsgdG8gZGV0ZXJtaW5lIGlmIHRoZSBhY2N1cmFjeSBpcyB3b3J0aFxcbiAgICAvLyB0aGUgY29zdC5cXG5cXG4gICAgLy8gZmxvYXQgbm9ybVZhbHVlID0gZG90KHZlYzIoZGVjb2RlZFZhbHVlLCAtbWluVmFsdWUpLCByZWNpcFJhbmdlMjU1KTtcXG4gICAgLy8gdmVjNCBmID0gbm9ybVZhbHVlICogZmxvYXRQb3dlcnM7XFxuICAgIC8vIGdsX0ZyYWdDb2xvciA9IGZsb29yKGZyYWN0KGYpICogMjU1LjApIC8gMjU1LjA7XFxuICB9XFxuXCI7XG52YXIgRkxPQVRfVEVYVFVSRV9TQU1QTEVfU05JUFBFVCA9IFwiXFxuICBmbG9hdCBzYW1wbGUoc2FtcGxlcjJEIHRleHR1cmUsIHZlYzIgdXYpIHtcXG4gICAgcmV0dXJuIHRleHR1cmUyRCh0ZXh0dXJlLCB1dikucjtcXG4gIH1cXG5cIjtcbnZhciBGTE9BVF9URVhUVVJFX1NFVE9VVFBVVF9TTklQUEVUID0gXCJcXG4gIHZvaWQgc2V0T3V0cHV0KGZsb2F0IHZhbCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZhbCwgMCwgMCwgMCk7XFxuICB9XFxuXCI7XG52YXIgU0hBREVSX1BSRUZJWCA9IFwiXFxuICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICBwcmVjaXNpb24gaGlnaHAgaW50O1xcbiAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO1xcbiAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcXG5cXG4gIGJvb2wgaXNOYU4oZmxvYXQgdmFsKSB7XFxuICAgIHJldHVybiB2YWwgPT0gdmFsID8gZmFsc2UgOiB0cnVlO1xcbiAgfVxcblxcbiAgYm9vbCBoYXNOYU4odmVjNCB2YWx1ZXMpIHtcXG4gICAgcmV0dXJuIGFueShub3RFcXVhbCh2YWx1ZXMsIHZhbHVlcykpO1xcbiAgfVxcblxcbiAgZmxvYXQgZ2V0TmFOKHZlYzQgdmFsdWVzKSB7XFxuICAgIHJldHVybiBkb3QodmVjNCgxKSwgdmFsdWVzKTtcXG4gIH1cXG5cXG4gIGludCByb3VuZChmbG9hdCB2YWx1ZSkge1xcbiAgICByZXR1cm4gaW50KGZsb29yKHZhbHVlICsgMC41KSk7XFxuICB9XFxuXFxuICBjb25zdCB2ZWMyIHJhbmRvbUNvbnN0ID0gdmVjMihcXG4gICAgMjMuMTQwNjkyNjMyNzc5MjYsIC8vIGVecGkgKEdlbGZvbmQncyBjb25zdGFudClcXG4gICAgIDIuNjY1MTQ0MTQyNjkwMjI1IC8vIDJec3FydCgyKSAoR2VsZm9uZFxcdTIwMTNTY2huZWlkZXIgY29uc3RhbnQpXFxuICApO1xcblxcbiAgZmxvYXQgcmFuZG9tKGZsb2F0IHNlZWQpIHtcXG4gICAgICByZXR1cm4gZnJhY3QoY29zKGRvdChyZXN1bHRVViAqIHNlZWQsIHJhbmRvbUNvbnN0KSkgKiAxMjM0NS42Nzg5KTtcXG4gIH1cXG5cXG4gIFwiICsgU0FNUExFXzFEX1NOSVBQRVQgKyBcIlxcbiAgXCIgKyBTQU1QTEVfMkRfU05JUFBFVCArIFwiXFxuICBcIiArIFNBTVBMRV8zRF9TTklQUEVUICsgXCJcXG4gIFwiICsgU0FNUExFXzREX1NOSVBQRVQgKyBcIlxcblwiO1xuZnVuY3Rpb24gZ2V0T3V0cHV0MURDb29yZHMoc2hhcGUsIHRleFNoYXBlKSB7XG4gICAgaWYgKHRleFNoYXBlWzBdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaW50KHJlc3VsdFVWLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleFNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaW50KHJlc3VsdFVWLnkgKiBcIiArIHRleFNoYXBlWzBdICsgXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgcmV0dXJuIHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dDNEQ29vcmRzKHNoYXBlLCB0ZXhTaGFwZSkge1xuICAgIHZhciBzdHJpZGUwID0gc2hhcGVbMV0gKiBzaGFwZVsyXTtcbiAgICB2YXIgc3RyaWRlMSA9IHNoYXBlWzJdO1xuICAgIHJldHVybiBcIlxcbiAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiICsgdGV4U2hhcGVbMV0gKyBcIiArIHJlc1RleFJDLnk7XFxuICAgICAgaW50IHIgPSBpbmRleCAvIFwiICsgc3RyaWRlMCArIFwiO1xcbiAgICAgIGluZGV4IC09IHIgKiBcIiArIHN0cmlkZTAgKyBcIjtcXG4gICAgICBpbnQgYyA9IGluZGV4IC8gXCIgKyBzdHJpZGUxICsgXCI7XFxuICAgICAgaW50IGQgPSBpbmRleCAtIGMgKiBcIiArIHN0cmlkZTEgKyBcIjtcXG4gICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0NERDb29yZHMoc2hhcGUsIHRleFNoYXBlKSB7XG4gICAgdmFyIHN0cmlkZTIgPSBzaGFwZVszXTtcbiAgICB2YXIgc3RyaWRlMSA9IHNoYXBlWzJdICogc3RyaWRlMjtcbiAgICB2YXIgc3RyaWRlMCA9IHNoYXBlWzFdICogc3RyaWRlMTtcbiAgICByZXR1cm4gXCJcXG4gICAgaXZlYzQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcblxcbiAgICAgIGludCByID0gaW5kZXggLyBcIiArIHN0cmlkZTAgKyBcIjtcXG4gICAgICBpbmRleCAtPSByICogXCIgKyBzdHJpZGUwICsgXCI7XFxuXFxuICAgICAgaW50IGMgPSBpbmRleCAvIFwiICsgc3RyaWRlMSArIFwiO1xcbiAgICAgIGluZGV4IC09IGMgKiBcIiArIHN0cmlkZTEgKyBcIjtcXG5cXG4gICAgICBpbnQgZCA9IGluZGV4IC8gXCIgKyBzdHJpZGUyICsgXCI7XFxuICAgICAgaW50IGQyID0gaW5kZXggLSBkICogXCIgKyBzdHJpZGUyICsgXCI7XFxuXFxuICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXQyRENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICBpZiAodXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAoc2hhcGVbMV0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKGluZGV4LCAwKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAoc2hhcGVbMF0gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKDAsIGluZGV4KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIGludCByID0gaW5kZXggLyBcIiArIHNoYXBlWzFdICsgXCI7XFxuICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiBcIiArIHNoYXBlWzFdICsgXCI7XFxuICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXJTY2FsYXIodGV4TmFtZSkge1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIigpIHtcXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCBoYWxmQ1IpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXIxRCh0ZXhOYW1lLCB0ZXhTaGFwZSkge1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgdmFyIHRSID0gdGV4U2hhcGVbMF07XG4gICAgdmFyIHRDID0gdGV4U2hhcGVbMV07XG4gICAgaWYgKHRleFNoYXBlWzBdID09PSAxICYmIHRleFNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIGhhbGZDUik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleFNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4KSArIDAuNSkgLyBcIiArIHRSICsgXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleFNoYXBlWzBdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKChmbG9hdChpbmRleCkgKyAwLjUpIC8gXCIgKyB0QyArIFwiLjAsIDAuNSk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICB2ZWMyIHV2ID0gVVZmcm9tMUQoXCIgKyB0UiArIFwiLCBcIiArIHRDICsgXCIsIGluZGV4KTtcXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlcjNEKHRleE5hbWUsIHNoYXBlLCB0ZXhTaGFwZSkge1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgdmFyIHRSID0gdGV4U2hhcGVbMF07XG4gICAgdmFyIHRDID0gdGV4U2hhcGVbMV07XG4gICAgdmFyIHN0cmlkZTAgPSBzaGFwZVsxXSAqIHNoYXBlWzJdO1xuICAgIHZhciBzdHJpZGUxID0gc2hhcGVbMl07XG4gICAgaWYgKHRDID09PSBzdHJpZGUwKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgIGludCB0ZXhSID0gcm93O1xcbiAgICAgICAgaW50IHRleEMgPSBjb2wgKiBcIiArIHN0cmlkZTEgKyBcIiArIGRlcHRoO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoXCIgKyB0QyArIFwiLjAsIFwiICsgdFIgKyBcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgIHZlYzIgdXYgPSBVVmZyb20zRChcIiArIHRSICsgXCIsIFwiICsgdEMgKyBcIiwgXCIgKyBzdHJpZGUwICsgXCIsIFwiICsgc3RyaWRlMSArIFwiLCByb3csIGNvbCwgZGVwdGgpO1xcbiAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyNEQodGV4TmFtZSwgc2hhcGUsIHRleFNoYXBlKSB7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICB2YXIgdFIgPSB0ZXhTaGFwZVswXTtcbiAgICB2YXIgdEMgPSB0ZXhTaGFwZVsxXTtcbiAgICB2YXIgc3RyaWRlMiA9IHNoYXBlWzNdO1xuICAgIHZhciBzdHJpZGUxID0gc2hhcGVbMl0gKiBzdHJpZGUyO1xuICAgIHZhciBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuICAgIGlmICh0QyA9PT0gc3RyaWRlMCkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICBpbnQgdGV4UiA9IHJvdztcXG4gICAgICAgIGludCB0ZXhDID0gY29sICogXCIgKyBzdHJpZGUxICsgXCIgKyBkZXB0aCAqIFwiICsgc3RyaWRlMiArIFwiICsgZGVwdGgyO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoXCIgKyB0QyArIFwiLjAsIFwiICsgdFIgKyBcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgIHZlYzIgdXYgPSBVVmZyb200RChcIiArIHRSICsgXCIsIFwiICsgdEMgKyBcIiwgXCIgKyBzdHJpZGUwICsgXCIsIFwiICsgc3RyaWRlMSArIFwiLCBcIiArIHN0cmlkZTIgKyBcIixcXG4gICAgICAgICAgcm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpO1xcbiAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyMkQodGV4TmFtZSwgc2hhcGUsIHRleFNoYXBlKSB7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICB2YXIgdFIgPSB0ZXhTaGFwZVswXTtcbiAgICB2YXIgdEMgPSB0ZXhTaGFwZVsxXTtcbiAgICBpZiAodXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sLCByb3cpICsgaGFsZkNSKSAvIHZlYzIoXCIgKyB0QyArIFwiLjAsIFwiICsgdFIgKyBcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodEMgPT09IDEpIHtcbiAgICAgICAgaWYgKHNoYXBlWzBdID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcXG4gICAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGNvbCkgKyAwLjUpIC8gXCIgKyB0UiArIFwiLjApO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcXG4gICAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KHJvdykgKyAwLjUpIC8gXCIgKyB0UiArIFwiLjApO1xcbiAgICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiICsgc2hhcGVbMV0gKyBcIiArIGNvbDtcXG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4KSArIDAuNSkgLyBcIiArIHRSICsgXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRSID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3cgKiBcIiArIHNoYXBlWzFdICsgXCIgKyBjb2w7XFxuICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXgpICsgMC41KSAvIFwiICsgdEMgKyBcIi4wLCAwLjUpO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSBVVmZyb20yRChcIiArIHRSICsgXCIsIFwiICsgdEMgKyBcIiwgXCIgKyBzaGFwZVsxXSArIFwiLCByb3csIGNvbCk7XFxuICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXJGbGF0KHRleE5hbWUsIHRleFNoYXBlKSB7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKSArICdGbGF0JztcbiAgICB2YXIgdE51bVIgPSB0ZXhTaGFwZVswXTtcbiAgICB2YXIgdE51bUMgPSB0ZXhTaGFwZVsxXTtcbiAgICBpZiAodE51bUMgPT09IDEgJiYgdE51bVIgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBpbmRleCkge1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgaGFsZkNSKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodE51bUMgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBpbmRleCkge1xcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoZmxvYXQoaW5kZXgpICsgMC41KSAvIFwiICsgdE51bVIgKyBcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodE51bVIgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBpbmRleCkge1xcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoKGZsb2F0KGluZGV4KSArIDAuNSkgLyBcIiArIHROdW1DICsgXCIuMCwgMC41KTtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBpbmRleCkge1xcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLyBcIiArIHROdW1DICsgXCI7XFxuICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiBcIiArIHROdW1DICsgXCI7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoXCIgKyB0TnVtQyArIFwiLjAsIFwiICsgdE51bVIgKyBcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlckF0T3V0cHV0Q29vcmRzKHRleE5hbWUsIGluVGV4U2hhcGUsIG91dFRleFNoYXBlLCBicm9hZGNhc3QpIHtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpICtcbiAgICAgICAgJ0F0T3V0Q29vcmRzJztcbiAgICBpZiAodXRpbC5hcnJheXNFcXVhbChpblRleFNoYXBlLCBvdXRUZXhTaGFwZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKCkge1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgcmVzdWx0VVYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHZhciBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoaW5UZXhTaGFwZSk7XG4gICAgdmFyIGJyb2FkY2FzdFNuaXBwZXQgPSAnJztcbiAgICBpZiAoYnJvYWRjYXN0KSB7XG4gICAgICAgIGJyb2FkY2FzdFNuaXBwZXQgPSBcIlxcbiAgICAgIGludCBtYWluUGFydCA9IGluZGV4IC8gXCIgKyBpblNpemUgKyBcIjtcXG4gICAgICBpbmRleCAtPSBtYWluUGFydCAqIFwiICsgaW5TaXplICsgXCI7XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIG91dFRleFNoYXBlWzBdICsgXCIsIFwiICsgb3V0VGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIG91dFRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIFwiICsgYnJvYWRjYXN0U25pcHBldCArIFwiXFxuICAgICAgaW50IHRleFIgPSBpbmRleCAvIFwiICsgaW5UZXhTaGFwZVsxXSArIFwiO1xcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogXCIgKyBpblRleFNoYXBlWzFdICsgXCI7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgaW5UZXhTaGFwZVsxXSArIFwiLjAsIFwiICsgaW5UZXhTaGFwZVswXSArIFwiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkZXJfY29tcGlsZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/shader_compiler.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/slice_gpu.js":
/*!*****************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/slice_gpu.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SliceProgram = (function () {\n    function SliceProgram(destSize) {\n        this.variableNames = ['source'];\n        this.outputShape = destSize;\n        this.rank = destSize.length;\n        this.params = [];\n        var dtype = getDataType(this.rank);\n        var sourceCoords = getCoords(this.rank);\n        this.userCode = \"\\n      uniform \" + dtype + \" start;\\n\\n      void main() {\\n        \" + dtype + \" sourceLoc = start + getOutputCoords();\\n        setOutput(getSource(\" + sourceCoords + \"));\\n      }\\n    \";\n    }\n    SliceProgram.prototype.getCustomSetupFunc = function (start) {\n        var _this = this;\n        if (start.length !== this.rank) {\n            throw Error(\"The rank (\" + this.rank + \") of the program must match the \" +\n                (\"length of start (\" + start.length + \")\"));\n        }\n        return function (gpgpu, webGLProgram) {\n            if (_this.startLoc == null) {\n                _this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');\n                if (_this.startLoc == null) {\n                    return;\n                }\n            }\n            if (_this.rank === 1) {\n                gpgpu.gl.uniform1i(_this.startLoc, start[0]);\n            }\n            else if (_this.rank === 2) {\n                gpgpu.gl.uniform2i(_this.startLoc, start[0], start[1]);\n            }\n            else if (_this.rank === 3) {\n                gpgpu.gl.uniform3i(_this.startLoc, start[0], start[1], start[2]);\n            }\n            else if (_this.rank === 4) {\n                gpgpu.gl.uniform4i(_this.startLoc, start[0], start[1], start[2], start[3]);\n            }\n            else {\n                throw Error(\"Slicing for rank \" + _this.rank + \" is not yet supported\");\n            }\n        };\n    };\n    return SliceProgram;\n}());\nexports.SliceProgram = SliceProgram;\nfunction getCoords(rank) {\n    if (rank === 1) {\n        return 'sourceLoc';\n    }\n    else if (rank === 2) {\n        return 'sourceLoc.x, sourceLoc.y';\n    }\n    else if (rank === 3) {\n        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z';\n    }\n    else if (rank === 4) {\n        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w';\n    }\n    else {\n        throw Error(\"Slicing for rank \" + rank + \" is not yet supported\");\n    }\n}\nfunction getDataType(rank) {\n    if (rank === 1) {\n        return 'int';\n    }\n    else if (rank === 2) {\n        return 'ivec2';\n    }\n    else if (rank === 3) {\n        return 'ivec3';\n    }\n    else if (rank === 4) {\n        return 'ivec4';\n    }\n    else {\n        throw Error(\"Slicing for rank \" + rank + \" is not yet supported\");\n    }\n}\n//# sourceMappingURL=slice_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvc2xpY2VfZ3B1LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL3NsaWNlX2dwdS5qcz9iOTIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFNsaWNlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2xpY2VQcm9ncmFtKGRlc3RTaXplKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnc291cmNlJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBkZXN0U2l6ZTtcbiAgICAgICAgdGhpcy5yYW5rID0gZGVzdFNpemUubGVuZ3RoO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IFtdO1xuICAgICAgICB2YXIgZHR5cGUgPSBnZXREYXRhVHlwZSh0aGlzLnJhbmspO1xuICAgICAgICB2YXIgc291cmNlQ29vcmRzID0gZ2V0Q29vcmRzKHRoaXMucmFuayk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHVuaWZvcm0gXCIgKyBkdHlwZSArIFwiIHN0YXJ0O1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiBzb3VyY2VMb2MgPSBzdGFydCArIGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldFNvdXJjZShcIiArIHNvdXJjZUNvb3JkcyArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgU2xpY2VQcm9ncmFtLnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmMgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHN0YXJ0Lmxlbmd0aCAhPT0gdGhpcy5yYW5rKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSByYW5rIChcIiArIHRoaXMucmFuayArIFwiKSBvZiB0aGUgcHJvZ3JhbSBtdXN0IG1hdGNoIHRoZSBcIiArXG4gICAgICAgICAgICAgICAgKFwibGVuZ3RoIG9mIHN0YXJ0IChcIiArIHN0YXJ0Lmxlbmd0aCArIFwiKVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChncGdwdSwgd2ViR0xQcm9ncmFtKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhcnRMb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXJ0TG9jID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyh3ZWJHTFByb2dyYW0sICdzdGFydCcpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGFydExvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xaShfdGhpcy5zdGFydExvYywgc3RhcnRbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMucmFuayA9PT0gMikge1xuICAgICAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0yaShfdGhpcy5zdGFydExvYywgc3RhcnRbMF0sIHN0YXJ0WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtM2koX3RoaXMuc3RhcnRMb2MsIHN0YXJ0WzBdLCBzdGFydFsxXSwgc3RhcnRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMucmFuayA9PT0gNCkge1xuICAgICAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm00aShfdGhpcy5zdGFydExvYywgc3RhcnRbMF0sIHN0YXJ0WzFdLCBzdGFydFsyXSwgc3RhcnRbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTbGljaW5nIGZvciByYW5rIFwiICsgX3RoaXMucmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFNsaWNlUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlNsaWNlUHJvZ3JhbSA9IFNsaWNlUHJvZ3JhbTtcbmZ1bmN0aW9uIGdldENvb3JkcyhyYW5rKSB7XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2VMb2MnO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAyKSB7XG4gICAgICAgIHJldHVybiAnc291cmNlTG9jLngsIHNvdXJjZUxvYy55JztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMykge1xuICAgICAgICByZXR1cm4gJ3NvdXJjZUxvYy54LCBzb3VyY2VMb2MueSwgc291cmNlTG9jLnonO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSA0KSB7XG4gICAgICAgIHJldHVybiAnc291cmNlTG9jLngsIHNvdXJjZUxvYy55LCBzb3VyY2VMb2Mueiwgc291cmNlTG9jLncnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJTbGljaW5nIGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldERhdGFUeXBlKHJhbmspIHtcbiAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ2ludCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjMic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjMyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDQpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjNCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlNsaWNpbmcgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2xpY2VfZ3B1LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/slice_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/tex_util.js":
/*!****************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/tex_util.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {\n    return [columns, rows];\n}\nexports.getUnpackedMatrixTextureShapeWidthHeight = getUnpackedMatrixTextureShapeWidthHeight;\nfunction getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {\n    return matrixSize * channelsPerTexture;\n}\nexports.getUnpackedArraySizeFromMatrixSize = getUnpackedArraySizeFromMatrixSize;\nfunction getColorMatrixTextureShapeWidthHeight(rows, columns) {\n    return [columns * 4, rows];\n}\nexports.getColorMatrixTextureShapeWidthHeight = getColorMatrixTextureShapeWidthHeight;\nfunction getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {\n    if (unpackedSize % channelsPerTexture !== 0) {\n        throw new Error('unpackedSize (' + unpackedSize + ') must be a multiple of ' +\n            channelsPerTexture);\n    }\n    return unpackedSize / channelsPerTexture;\n}\nexports.getMatrixSizeFromUnpackedArraySize = getMatrixSizeFromUnpackedArraySize;\nfunction encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture) {\n    var requiredSize = getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture);\n    if (unpackedArray.length < requiredSize) {\n        throw new Error('unpackedArray length (' + unpackedArray.length +\n            ') must be >= ' + requiredSize);\n    }\n    var dst = 0;\n    for (var src = 0; src < matrix.length; ++src) {\n        unpackedArray[dst] = matrix[src];\n        dst += channelsPerTexture;\n    }\n}\nexports.encodeMatrixToUnpackedArray = encodeMatrixToUnpackedArray;\nexports.FLOAT_MAX = 20000;\nexports.FLOAT_MIN = -exports.FLOAT_MAX;\nvar FLOAT_RANGE = (exports.FLOAT_MAX - exports.FLOAT_MIN) / 255;\nvar FLOAT_DELTAS = [1, 1 / 255, 1 / (255 * 255), 1 / (255 * 255 * 255)];\nvar FLOAT_POWERS = [1, 255, 255 * 255];\nexports.BYTE_NAN_VALUE = 0;\nfunction encodeFloatArray(floatArray) {\n    var uintArray = new Uint8Array(floatArray.length * 4);\n    var _loop_1 = function (i) {\n        var value = floatArray[i / 4];\n        if (isNaN(value)) {\n            uintArray[i] = exports.BYTE_NAN_VALUE;\n            uintArray[i + 1] = exports.BYTE_NAN_VALUE;\n            uintArray[i + 2] = exports.BYTE_NAN_VALUE;\n            uintArray[i + 3] = exports.BYTE_NAN_VALUE;\n            return \"continue\";\n        }\n        var normalizedValue = (value - exports.FLOAT_MIN) / FLOAT_RANGE;\n        var enc = FLOAT_POWERS.map(function (pow) { return pow * normalizedValue; });\n        var buckets = enc.map(function (value) { return Math.floor((value % 1) * 255); });\n        uintArray[i] = Math.floor(normalizedValue);\n        uintArray[i + 1] = buckets[0];\n        uintArray[i + 2] = buckets[1];\n        uintArray[i + 3] = buckets[2];\n    };\n    for (var i = 0; i < uintArray.length; i += 4) {\n        _loop_1(i);\n    }\n    return uintArray;\n}\nexports.encodeFloatArray = encodeFloatArray;\nfunction decodeToFloatArray(uintArray) {\n    var floatArray = new Float32Array(uintArray.length / 4);\n    var _loop_2 = function (i) {\n        if (uintArray[i] === exports.BYTE_NAN_VALUE &&\n            uintArray[i + 1] === exports.BYTE_NAN_VALUE &&\n            uintArray[i + 2] === exports.BYTE_NAN_VALUE &&\n            uintArray[i + 3] === exports.BYTE_NAN_VALUE) {\n            floatArray[i / 4] = NaN;\n            return \"continue\";\n        }\n        var dot = 0;\n        FLOAT_DELTAS.forEach(function (delta, j) {\n            dot += delta * uintArray[i + j];\n        });\n        var value = dot * FLOAT_RANGE + exports.FLOAT_MIN;\n        floatArray[i / 4] = value;\n    };\n    for (var i = 0; i < uintArray.length; i += 4) {\n        _loop_2(i);\n    }\n    return floatArray;\n}\nexports.decodeToFloatArray = decodeToFloatArray;\nfunction decodeMatrixFromUnpackedArray(unpackedArray, matrix, channelsPerTexture) {\n    var requiredSize = getMatrixSizeFromUnpackedArraySize(unpackedArray.length, channelsPerTexture);\n    if (matrix.length < requiredSize) {\n        throw new Error('matrix length (' + matrix.length + ') must be >= ' + requiredSize);\n    }\n    var dst = 0;\n    for (var src = 0; src < unpackedArray.length; src += channelsPerTexture) {\n        matrix[dst++] = unpackedArray[src];\n    }\n}\nexports.decodeMatrixFromUnpackedArray = decodeMatrixFromUnpackedArray;\nfunction getPackedMatrixTextureShapeWidthHeight(rows, columns) {\n    return [Math.ceil(columns / 2), Math.ceil(rows / 2)];\n}\nexports.getPackedMatrixTextureShapeWidthHeight = getPackedMatrixTextureShapeWidthHeight;\nfunction getPackedRGBAArraySizeFromMatrixShape(rows, columns) {\n    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];\n    return w * h * 4;\n}\nexports.getPackedRGBAArraySizeFromMatrixShape = getPackedRGBAArraySizeFromMatrixShape;\nfunction encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA) {\n    var requiredSize = getPackedRGBAArraySizeFromMatrixShape(rows, columns);\n    if (packedRGBA.length < requiredSize) {\n        throw new Error('packedRGBA length (' + packedRGBA.length +\n            ') must be >= ' + requiredSize);\n    }\n    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];\n    var oddWidth = (columns % 2) === 1;\n    var oddHeight = (rows % 2) === 1;\n    var widthInFullBlocks = Math.floor(columns / 2);\n    var heightInFullBlocks = Math.floor(rows / 2);\n    {\n        var dstStride = (oddWidth ? 4 : 0);\n        var oneRow = columns;\n        var dst = 0;\n        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {\n            var matrixSrcRow = (blockY * 2 * columns);\n            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {\n                var matrixSrcCol = blockX * 2;\n                var src = matrixSrcRow + matrixSrcCol;\n                packedRGBA[dst] = matrix[src];\n                packedRGBA[dst + 1] = matrix[src + 1];\n                packedRGBA[dst + 2] = matrix[src + oneRow];\n                packedRGBA[dst + 3] = matrix[src + oneRow + 1];\n                dst += 4;\n            }\n            dst += dstStride;\n        }\n    }\n    if (oddWidth) {\n        var src = columns - 1;\n        var dst = (textureWidth - 1) * 4;\n        var srcStride = 2 * columns;\n        var dstStride = textureWidth * 4;\n        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {\n            packedRGBA[dst] = matrix[src];\n            packedRGBA[dst + 2] = matrix[src + columns];\n            src += srcStride;\n            dst += dstStride;\n        }\n    }\n    if (oddHeight) {\n        var src = (rows - 1) * columns;\n        var dst = (textureHeight - 1) * textureWidth * 4;\n        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {\n            packedRGBA[dst++] = matrix[src++];\n            packedRGBA[dst++] = matrix[src++];\n            dst += 2;\n        }\n    }\n    if (oddWidth && oddHeight) {\n        packedRGBA[packedRGBA.length - 4] = matrix[matrix.length - 1];\n    }\n    return packedRGBA;\n}\nexports.encodeMatrixToPackedRGBA = encodeMatrixToPackedRGBA;\nfunction decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix) {\n    var requiredSize = rows * columns;\n    if (requiredSize < matrix.length) {\n        throw new Error('matrix length (' + matrix.length + ') must be >= ' + requiredSize);\n    }\n    var oddWidth = (columns % 2) === 1;\n    var oddHeight = (rows % 2) === 1;\n    var widthInFullBlocks = Math.floor(columns / 2);\n    var heightInFullBlocks = Math.floor(rows / 2);\n    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];\n    {\n        var srcStride = oddWidth ? 4 : 0;\n        var dstStride = columns + (oddWidth ? 1 : 0);\n        var src = 0;\n        var dstRow1 = 0;\n        var dstRow2 = columns;\n        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {\n            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {\n                matrix[dstRow1++] = packedRGBA[src++];\n                matrix[dstRow1++] = packedRGBA[src++];\n                matrix[dstRow2++] = packedRGBA[src++];\n                matrix[dstRow2++] = packedRGBA[src++];\n            }\n            src += srcStride;\n            dstRow1 += dstStride;\n            dstRow2 += dstStride;\n        }\n    }\n    if (oddWidth) {\n        var src = (textureWidth - 1) * 4;\n        var dst = columns - 1;\n        var srcStride = textureWidth * 4;\n        var dstStride = 2 * columns;\n        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {\n            matrix[dst] = packedRGBA[src];\n            matrix[dst + columns] = packedRGBA[src + 2];\n            src += srcStride;\n            dst += dstStride;\n        }\n    }\n    if (oddHeight) {\n        var src = (textureHeight - 1) * textureWidth * 4;\n        var dst = (rows - 1) * columns;\n        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {\n            matrix[dst++] = packedRGBA[src++];\n            matrix[dst++] = packedRGBA[src++];\n            src += 2;\n        }\n    }\n    if (oddWidth && oddHeight) {\n        matrix[matrix.length - 1] = packedRGBA[packedRGBA.length - 4];\n    }\n    return matrix;\n}\nexports.decodeMatrixFromPackedRGBA = decodeMatrixFromPackedRGBA;\n//# sourceMappingURL=tex_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvdGV4X3V0aWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvdGV4X3V0aWwuanM/NTFmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucykge1xuICAgIHJldHVybiBbY29sdW1ucywgcm93c107XG59XG5leHBvcnRzLmdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQgPSBnZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0O1xuZnVuY3Rpb24gZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShtYXRyaXhTaXplLCBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICByZXR1cm4gbWF0cml4U2l6ZSAqIGNoYW5uZWxzUGVyVGV4dHVyZTtcbn1cbmV4cG9ydHMuZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZSA9IGdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemU7XG5mdW5jdGlvbiBnZXRDb2xvck1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gW2NvbHVtbnMgKiA0LCByb3dzXTtcbn1cbmV4cG9ydHMuZ2V0Q29sb3JNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodCA9IGdldENvbG9yTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQ7XG5mdW5jdGlvbiBnZXRNYXRyaXhTaXplRnJvbVVucGFja2VkQXJyYXlTaXplKHVucGFja2VkU2l6ZSwgY2hhbm5lbHNQZXJUZXh0dXJlKSB7XG4gICAgaWYgKHVucGFja2VkU2l6ZSAlIGNoYW5uZWxzUGVyVGV4dHVyZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucGFja2VkU2l6ZSAoJyArIHVucGFja2VkU2l6ZSArICcpIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAnICtcbiAgICAgICAgICAgIGNoYW5uZWxzUGVyVGV4dHVyZSk7XG4gICAgfVxuICAgIHJldHVybiB1bnBhY2tlZFNpemUgLyBjaGFubmVsc1BlclRleHR1cmU7XG59XG5leHBvcnRzLmdldE1hdHJpeFNpemVGcm9tVW5wYWNrZWRBcnJheVNpemUgPSBnZXRNYXRyaXhTaXplRnJvbVVucGFja2VkQXJyYXlTaXplO1xuZnVuY3Rpb24gZW5jb2RlTWF0cml4VG9VbnBhY2tlZEFycmF5KG1hdHJpeCwgdW5wYWNrZWRBcnJheSwgY2hhbm5lbHNQZXJUZXh0dXJlKSB7XG4gICAgdmFyIHJlcXVpcmVkU2l6ZSA9IGdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemUobWF0cml4Lmxlbmd0aCwgY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgICBpZiAodW5wYWNrZWRBcnJheS5sZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnBhY2tlZEFycmF5IGxlbmd0aCAoJyArIHVucGFja2VkQXJyYXkubGVuZ3RoICtcbiAgICAgICAgICAgICcpIG11c3QgYmUgPj0gJyArIHJlcXVpcmVkU2l6ZSk7XG4gICAgfVxuICAgIHZhciBkc3QgPSAwO1xuICAgIGZvciAodmFyIHNyYyA9IDA7IHNyYyA8IG1hdHJpeC5sZW5ndGg7ICsrc3JjKSB7XG4gICAgICAgIHVucGFja2VkQXJyYXlbZHN0XSA9IG1hdHJpeFtzcmNdO1xuICAgICAgICBkc3QgKz0gY2hhbm5lbHNQZXJUZXh0dXJlO1xuICAgIH1cbn1cbmV4cG9ydHMuZW5jb2RlTWF0cml4VG9VbnBhY2tlZEFycmF5ID0gZW5jb2RlTWF0cml4VG9VbnBhY2tlZEFycmF5O1xuZXhwb3J0cy5GTE9BVF9NQVggPSAyMDAwMDtcbmV4cG9ydHMuRkxPQVRfTUlOID0gLWV4cG9ydHMuRkxPQVRfTUFYO1xudmFyIEZMT0FUX1JBTkdFID0gKGV4cG9ydHMuRkxPQVRfTUFYIC0gZXhwb3J0cy5GTE9BVF9NSU4pIC8gMjU1O1xudmFyIEZMT0FUX0RFTFRBUyA9IFsxLCAxIC8gMjU1LCAxIC8gKDI1NSAqIDI1NSksIDEgLyAoMjU1ICogMjU1ICogMjU1KV07XG52YXIgRkxPQVRfUE9XRVJTID0gWzEsIDI1NSwgMjU1ICogMjU1XTtcbmV4cG9ydHMuQllURV9OQU5fVkFMVUUgPSAwO1xuZnVuY3Rpb24gZW5jb2RlRmxvYXRBcnJheShmbG9hdEFycmF5KSB7XG4gICAgdmFyIHVpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGZsb2F0QXJyYXkubGVuZ3RoICogNCk7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBmbG9hdEFycmF5W2kgLyA0XTtcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgdWludEFycmF5W2ldID0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRTtcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgMV0gPSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFO1xuICAgICAgICAgICAgdWludEFycmF5W2kgKyAyXSA9IGV4cG9ydHMuQllURV9OQU5fVkFMVUU7XG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDNdID0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRTtcbiAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRWYWx1ZSA9ICh2YWx1ZSAtIGV4cG9ydHMuRkxPQVRfTUlOKSAvIEZMT0FUX1JBTkdFO1xuICAgICAgICB2YXIgZW5jID0gRkxPQVRfUE9XRVJTLm1hcChmdW5jdGlvbiAocG93KSB7IHJldHVybiBwb3cgKiBub3JtYWxpemVkVmFsdWU7IH0pO1xuICAgICAgICB2YXIgYnVja2V0cyA9IGVuYy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBNYXRoLmZsb29yKCh2YWx1ZSAlIDEpICogMjU1KTsgfSk7XG4gICAgICAgIHVpbnRBcnJheVtpXSA9IE1hdGguZmxvb3Iobm9ybWFsaXplZFZhbHVlKTtcbiAgICAgICAgdWludEFycmF5W2kgKyAxXSA9IGJ1Y2tldHNbMF07XG4gICAgICAgIHVpbnRBcnJheVtpICsgMl0gPSBidWNrZXRzWzFdO1xuICAgICAgICB1aW50QXJyYXlbaSArIDNdID0gYnVja2V0c1syXTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdWludEFycmF5Lmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIF9sb29wXzEoaSk7XG4gICAgfVxuICAgIHJldHVybiB1aW50QXJyYXk7XG59XG5leHBvcnRzLmVuY29kZUZsb2F0QXJyYXkgPSBlbmNvZGVGbG9hdEFycmF5O1xuZnVuY3Rpb24gZGVjb2RlVG9GbG9hdEFycmF5KHVpbnRBcnJheSkge1xuICAgIHZhciBmbG9hdEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSh1aW50QXJyYXkubGVuZ3RoIC8gNCk7XG4gICAgdmFyIF9sb29wXzIgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICBpZiAodWludEFycmF5W2ldID09PSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFICYmXG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDFdID09PSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFICYmXG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDJdID09PSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFICYmXG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDNdID09PSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFKSB7XG4gICAgICAgICAgICBmbG9hdEFycmF5W2kgLyA0XSA9IE5hTjtcbiAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRvdCA9IDA7XG4gICAgICAgIEZMT0FUX0RFTFRBUy5mb3JFYWNoKGZ1bmN0aW9uIChkZWx0YSwgaikge1xuICAgICAgICAgICAgZG90ICs9IGRlbHRhICogdWludEFycmF5W2kgKyBqXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRvdCAqIEZMT0FUX1JBTkdFICsgZXhwb3J0cy5GTE9BVF9NSU47XG4gICAgICAgIGZsb2F0QXJyYXlbaSAvIDRdID0gdmFsdWU7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVpbnRBcnJheS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBfbG9vcF8yKGkpO1xuICAgIH1cbiAgICByZXR1cm4gZmxvYXRBcnJheTtcbn1cbmV4cG9ydHMuZGVjb2RlVG9GbG9hdEFycmF5ID0gZGVjb2RlVG9GbG9hdEFycmF5O1xuZnVuY3Rpb24gZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXkodW5wYWNrZWRBcnJheSwgbWF0cml4LCBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICB2YXIgcmVxdWlyZWRTaXplID0gZ2V0TWF0cml4U2l6ZUZyb21VbnBhY2tlZEFycmF5U2l6ZSh1bnBhY2tlZEFycmF5Lmxlbmd0aCwgY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgICBpZiAobWF0cml4Lmxlbmd0aCA8IHJlcXVpcmVkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hdHJpeCBsZW5ndGggKCcgKyBtYXRyaXgubGVuZ3RoICsgJykgbXVzdCBiZSA+PSAnICsgcmVxdWlyZWRTaXplKTtcbiAgICB9XG4gICAgdmFyIGRzdCA9IDA7XG4gICAgZm9yICh2YXIgc3JjID0gMDsgc3JjIDwgdW5wYWNrZWRBcnJheS5sZW5ndGg7IHNyYyArPSBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICAgICAgbWF0cml4W2RzdCsrXSA9IHVucGFja2VkQXJyYXlbc3JjXTtcbiAgICB9XG59XG5leHBvcnRzLmRlY29kZU1hdHJpeEZyb21VbnBhY2tlZEFycmF5ID0gZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXk7XG5mdW5jdGlvbiBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSB7XG4gICAgcmV0dXJuIFtNYXRoLmNlaWwoY29sdW1ucyAvIDIpLCBNYXRoLmNlaWwocm93cyAvIDIpXTtcbn1cbmV4cG9ydHMuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQgPSBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodDtcbmZ1bmN0aW9uIGdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUocm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICByZXR1cm4gdyAqIGggKiA0O1xufVxuZXhwb3J0cy5nZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlID0gZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZTtcbmZ1bmN0aW9uIGVuY29kZU1hdHJpeFRvUGFja2VkUkdCQShtYXRyaXgsIHJvd3MsIGNvbHVtbnMsIHBhY2tlZFJHQkEpIHtcbiAgICB2YXIgcmVxdWlyZWRTaXplID0gZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShyb3dzLCBjb2x1bW5zKTtcbiAgICBpZiAocGFja2VkUkdCQS5sZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWNrZWRSR0JBIGxlbmd0aCAoJyArIHBhY2tlZFJHQkEubGVuZ3RoICtcbiAgICAgICAgICAgICcpIG11c3QgYmUgPj0gJyArIHJlcXVpcmVkU2l6ZSk7XG4gICAgfVxuICAgIHZhciBfYSA9IGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB0ZXh0dXJlV2lkdGggPSBfYVswXSwgdGV4dHVyZUhlaWdodCA9IF9hWzFdO1xuICAgIHZhciBvZGRXaWR0aCA9IChjb2x1bW5zICUgMikgPT09IDE7XG4gICAgdmFyIG9kZEhlaWdodCA9IChyb3dzICUgMikgPT09IDE7XG4gICAgdmFyIHdpZHRoSW5GdWxsQmxvY2tzID0gTWF0aC5mbG9vcihjb2x1bW5zIC8gMik7XG4gICAgdmFyIGhlaWdodEluRnVsbEJsb2NrcyA9IE1hdGguZmxvb3Iocm93cyAvIDIpO1xuICAgIHtcbiAgICAgICAgdmFyIGRzdFN0cmlkZSA9IChvZGRXaWR0aCA/IDQgOiAwKTtcbiAgICAgICAgdmFyIG9uZVJvdyA9IGNvbHVtbnM7XG4gICAgICAgIHZhciBkc3QgPSAwO1xuICAgICAgICBmb3IgKHZhciBibG9ja1kgPSAwOyBibG9ja1kgPCBoZWlnaHRJbkZ1bGxCbG9ja3M7ICsrYmxvY2tZKSB7XG4gICAgICAgICAgICB2YXIgbWF0cml4U3JjUm93ID0gKGJsb2NrWSAqIDIgKiBjb2x1bW5zKTtcbiAgICAgICAgICAgIGZvciAodmFyIGJsb2NrWCA9IDA7IGJsb2NrWCA8IHdpZHRoSW5GdWxsQmxvY2tzOyArK2Jsb2NrWCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRyaXhTcmNDb2wgPSBibG9ja1ggKiAyO1xuICAgICAgICAgICAgICAgIHZhciBzcmMgPSBtYXRyaXhTcmNSb3cgKyBtYXRyaXhTcmNDb2w7XG4gICAgICAgICAgICAgICAgcGFja2VkUkdCQVtkc3RdID0gbWF0cml4W3NyY107XG4gICAgICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAxXSA9IG1hdHJpeFtzcmMgKyAxXTtcbiAgICAgICAgICAgICAgICBwYWNrZWRSR0JBW2RzdCArIDJdID0gbWF0cml4W3NyYyArIG9uZVJvd107XG4gICAgICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAzXSA9IG1hdHJpeFtzcmMgKyBvbmVSb3cgKyAxXTtcbiAgICAgICAgICAgICAgICBkc3QgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRzdCArPSBkc3RTdHJpZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZFdpZHRoKSB7XG4gICAgICAgIHZhciBzcmMgPSBjb2x1bW5zIC0gMTtcbiAgICAgICAgdmFyIGRzdCA9ICh0ZXh0dXJlV2lkdGggLSAxKSAqIDQ7XG4gICAgICAgIHZhciBzcmNTdHJpZGUgPSAyICogY29sdW1ucztcbiAgICAgICAgdmFyIGRzdFN0cmlkZSA9IHRleHR1cmVXaWR0aCAqIDQ7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWSA9IDA7IGJsb2NrWSA8IGhlaWdodEluRnVsbEJsb2NrczsgKytibG9ja1kpIHtcbiAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0XSA9IG1hdHJpeFtzcmNdO1xuICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAyXSA9IG1hdHJpeFtzcmMgKyBjb2x1bW5zXTtcbiAgICAgICAgICAgIHNyYyArPSBzcmNTdHJpZGU7XG4gICAgICAgICAgICBkc3QgKz0gZHN0U3RyaWRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRIZWlnaHQpIHtcbiAgICAgICAgdmFyIHNyYyA9IChyb3dzIC0gMSkgKiBjb2x1bW5zO1xuICAgICAgICB2YXIgZHN0ID0gKHRleHR1cmVIZWlnaHQgLSAxKSAqIHRleHR1cmVXaWR0aCAqIDQ7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWCA9IDA7IGJsb2NrWCA8IHdpZHRoSW5GdWxsQmxvY2tzOyArK2Jsb2NrWCkge1xuICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QrK10gPSBtYXRyaXhbc3JjKytdO1xuICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QrK10gPSBtYXRyaXhbc3JjKytdO1xuICAgICAgICAgICAgZHN0ICs9IDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZFdpZHRoICYmIG9kZEhlaWdodCkge1xuICAgICAgICBwYWNrZWRSR0JBW3BhY2tlZFJHQkEubGVuZ3RoIC0gNF0gPSBtYXRyaXhbbWF0cml4Lmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gcGFja2VkUkdCQTtcbn1cbmV4cG9ydHMuZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBID0gZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBO1xuZnVuY3Rpb24gZGVjb2RlTWF0cml4RnJvbVBhY2tlZFJHQkEocGFja2VkUkdCQSwgcm93cywgY29sdW1ucywgbWF0cml4KSB7XG4gICAgdmFyIHJlcXVpcmVkU2l6ZSA9IHJvd3MgKiBjb2x1bW5zO1xuICAgIGlmIChyZXF1aXJlZFNpemUgPCBtYXRyaXgubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWF0cml4IGxlbmd0aCAoJyArIG1hdHJpeC5sZW5ndGggKyAnKSBtdXN0IGJlID49ICcgKyByZXF1aXJlZFNpemUpO1xuICAgIH1cbiAgICB2YXIgb2RkV2lkdGggPSAoY29sdW1ucyAlIDIpID09PSAxO1xuICAgIHZhciBvZGRIZWlnaHQgPSAocm93cyAlIDIpID09PSAxO1xuICAgIHZhciB3aWR0aEluRnVsbEJsb2NrcyA9IE1hdGguZmxvb3IoY29sdW1ucyAvIDIpO1xuICAgIHZhciBoZWlnaHRJbkZ1bGxCbG9ja3MgPSBNYXRoLmZsb29yKHJvd3MgLyAyKTtcbiAgICB2YXIgX2EgPSBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgdGV4dHVyZVdpZHRoID0gX2FbMF0sIHRleHR1cmVIZWlnaHQgPSBfYVsxXTtcbiAgICB7XG4gICAgICAgIHZhciBzcmNTdHJpZGUgPSBvZGRXaWR0aCA/IDQgOiAwO1xuICAgICAgICB2YXIgZHN0U3RyaWRlID0gY29sdW1ucyArIChvZGRXaWR0aCA/IDEgOiAwKTtcbiAgICAgICAgdmFyIHNyYyA9IDA7XG4gICAgICAgIHZhciBkc3RSb3cxID0gMDtcbiAgICAgICAgdmFyIGRzdFJvdzIgPSBjb2x1bW5zO1xuICAgICAgICBmb3IgKHZhciBibG9ja1kgPSAwOyBibG9ja1kgPCBoZWlnaHRJbkZ1bGxCbG9ja3M7ICsrYmxvY2tZKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBibG9ja1ggPSAwOyBibG9ja1ggPCB3aWR0aEluRnVsbEJsb2NrczsgKytibG9ja1gpIHtcbiAgICAgICAgICAgICAgICBtYXRyaXhbZHN0Um93MSsrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgICAgIG1hdHJpeFtkc3RSb3cxKytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgICAgICAgICAgbWF0cml4W2RzdFJvdzIrK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgICAgICBtYXRyaXhbZHN0Um93MisrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3JjICs9IHNyY1N0cmlkZTtcbiAgICAgICAgICAgIGRzdFJvdzEgKz0gZHN0U3RyaWRlO1xuICAgICAgICAgICAgZHN0Um93MiArPSBkc3RTdHJpZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZFdpZHRoKSB7XG4gICAgICAgIHZhciBzcmMgPSAodGV4dHVyZVdpZHRoIC0gMSkgKiA0O1xuICAgICAgICB2YXIgZHN0ID0gY29sdW1ucyAtIDE7XG4gICAgICAgIHZhciBzcmNTdHJpZGUgPSB0ZXh0dXJlV2lkdGggKiA0O1xuICAgICAgICB2YXIgZHN0U3RyaWRlID0gMiAqIGNvbHVtbnM7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWSA9IDA7IGJsb2NrWSA8IGhlaWdodEluRnVsbEJsb2NrczsgKytibG9ja1kpIHtcbiAgICAgICAgICAgIG1hdHJpeFtkc3RdID0gcGFja2VkUkdCQVtzcmNdO1xuICAgICAgICAgICAgbWF0cml4W2RzdCArIGNvbHVtbnNdID0gcGFja2VkUkdCQVtzcmMgKyAyXTtcbiAgICAgICAgICAgIHNyYyArPSBzcmNTdHJpZGU7XG4gICAgICAgICAgICBkc3QgKz0gZHN0U3RyaWRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRIZWlnaHQpIHtcbiAgICAgICAgdmFyIHNyYyA9ICh0ZXh0dXJlSGVpZ2h0IC0gMSkgKiB0ZXh0dXJlV2lkdGggKiA0O1xuICAgICAgICB2YXIgZHN0ID0gKHJvd3MgLSAxKSAqIGNvbHVtbnM7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWCA9IDA7IGJsb2NrWCA8IHdpZHRoSW5GdWxsQmxvY2tzOyArK2Jsb2NrWCkge1xuICAgICAgICAgICAgbWF0cml4W2RzdCsrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgbWF0cml4W2RzdCsrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgc3JjICs9IDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZFdpZHRoICYmIG9kZEhlaWdodCkge1xuICAgICAgICBtYXRyaXhbbWF0cml4Lmxlbmd0aCAtIDFdID0gcGFja2VkUkdCQVtwYWNrZWRSR0JBLmxlbmd0aCAtIDRdO1xuICAgIH1cbiAgICByZXR1cm4gbWF0cml4O1xufVxuZXhwb3J0cy5kZWNvZGVNYXRyaXhGcm9tUGFja2VkUkdCQSA9IGRlY29kZU1hdHJpeEZyb21QYWNrZWRSR0JBO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGV4X3V0aWwuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/tex_util.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/texture_manager.js":
/*!***********************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/texture_manager.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TextureManager = (function () {\n    function TextureManager(gpgpu) {\n        this.gpgpu = gpgpu;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this.freeTextures = {};\n        this.logEnabled = false;\n        this.usedTextureCount = {};\n    }\n    TextureManager.prototype.acquireTexture = function (shapeRC) {\n        var shapeKey = getKeyFromTextureShape(shapeRC);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        if (!(shapeKey in this.usedTextureCount)) {\n            this.usedTextureCount[shapeKey] = 0;\n        }\n        this.usedTextureCount[shapeKey]++;\n        if (this.freeTextures[shapeKey].length > 0) {\n            this.numFreeTextures--;\n            this.numUsedTextures++;\n            this.log();\n            return this.freeTextures[shapeKey].shift();\n        }\n        this.numUsedTextures++;\n        this.log();\n        return this.gpgpu.createMatrixTexture(shapeRC[0], shapeRC[1]);\n    };\n    TextureManager.prototype.releaseTexture = function (texture, shape) {\n        var shapeKey = getKeyFromTextureShape(shape);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        this.freeTextures[shapeKey].push(texture);\n        this.numFreeTextures++;\n        this.numUsedTextures--;\n        this.usedTextureCount[shapeKey]--;\n        this.log();\n    };\n    TextureManager.prototype.log = function () {\n        if (!this.logEnabled) {\n            return;\n        }\n        var total = this.numFreeTextures + this.numUsedTextures;\n        console.log('Free/Used', this.numFreeTextures + ' / ' + this.numUsedTextures, \"(\" + total + \")\");\n    };\n    TextureManager.prototype.getNumUsedTextures = function () {\n        return this.numUsedTextures;\n    };\n    TextureManager.prototype.getNumFreeTextures = function () {\n        return this.numFreeTextures;\n    };\n    TextureManager.prototype.dispose = function () {\n        for (var shape in this.freeTextures) {\n            if (this.freeTextures.hasOwnProperty(shape)) {\n                for (var i = 0; i < this.freeTextures[shape].length; i++) {\n                    this.gpgpu.deleteMatrixTexture(this.freeTextures[shape][i]);\n                }\n            }\n        }\n    };\n    return TextureManager;\n}());\nexports.TextureManager = TextureManager;\nfunction getKeyFromTextureShape(shapeRowsCol) {\n    return shapeRowsCol[0] + '_' + shapeRowsCol[1];\n}\n//# sourceMappingURL=texture_manager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvdGV4dHVyZV9tYW5hZ2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3NyYy9tYXRoL3dlYmdsL3RleHR1cmVfbWFuYWdlci5qcz82MTZlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRleHR1cmVNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0dXJlTWFuYWdlcihncGdwdSkge1xuICAgICAgICB0aGlzLmdwZ3B1ID0gZ3BncHU7XG4gICAgICAgIHRoaXMubnVtVXNlZFRleHR1cmVzID0gMDtcbiAgICAgICAgdGhpcy5udW1GcmVlVGV4dHVyZXMgPSAwO1xuICAgICAgICB0aGlzLmZyZWVUZXh0dXJlcyA9IHt9O1xuICAgICAgICB0aGlzLmxvZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51c2VkVGV4dHVyZUNvdW50ID0ge307XG4gICAgfVxuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5hY3F1aXJlVGV4dHVyZSA9IGZ1bmN0aW9uIChzaGFwZVJDKSB7XG4gICAgICAgIHZhciBzaGFwZUtleSA9IGdldEtleUZyb21UZXh0dXJlU2hhcGUoc2hhcGVSQyk7XG4gICAgICAgIGlmICghKHNoYXBlS2V5IGluIHRoaXMuZnJlZVRleHR1cmVzKSkge1xuICAgICAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc2hhcGVLZXkgaW4gdGhpcy51c2VkVGV4dHVyZUNvdW50KSkge1xuICAgICAgICAgICAgdGhpcy51c2VkVGV4dHVyZUNvdW50W3NoYXBlS2V5XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51c2VkVGV4dHVyZUNvdW50W3NoYXBlS2V5XSsrO1xuICAgICAgICBpZiAodGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubnVtRnJlZVRleHR1cmVzLS07XG4gICAgICAgICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcysrO1xuICAgICAgICAgICAgdGhpcy5sb2coKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0uc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcysrO1xuICAgICAgICB0aGlzLmxvZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5ncGdwdS5jcmVhdGVNYXRyaXhUZXh0dXJlKHNoYXBlUkNbMF0sIHNoYXBlUkNbMV0pO1xuICAgIH07XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLnJlbGVhc2VUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHNoYXBlKSB7XG4gICAgICAgIHZhciBzaGFwZUtleSA9IGdldEtleUZyb21UZXh0dXJlU2hhcGUoc2hhcGUpO1xuICAgICAgICBpZiAoIShzaGFwZUtleSBpbiB0aGlzLmZyZWVUZXh0dXJlcykpIHtcbiAgICAgICAgICAgIHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XS5wdXNoKHRleHR1cmUpO1xuICAgICAgICB0aGlzLm51bUZyZWVUZXh0dXJlcysrO1xuICAgICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcy0tO1xuICAgICAgICB0aGlzLnVzZWRUZXh0dXJlQ291bnRbc2hhcGVLZXldLS07XG4gICAgICAgIHRoaXMubG9nKCk7XG4gICAgfTtcbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMubnVtRnJlZVRleHR1cmVzICsgdGhpcy5udW1Vc2VkVGV4dHVyZXM7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGcmVlL1VzZWQnLCB0aGlzLm51bUZyZWVUZXh0dXJlcyArICcgLyAnICsgdGhpcy5udW1Vc2VkVGV4dHVyZXMsIFwiKFwiICsgdG90YWwgKyBcIilcIik7XG4gICAgfTtcbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUuZ2V0TnVtVXNlZFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1Vc2VkVGV4dHVyZXM7XG4gICAgfTtcbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUuZ2V0TnVtRnJlZVRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1GcmVlVGV4dHVyZXM7XG4gICAgfTtcbiAgICBUZXh0dXJlTWFuYWdlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgc2hhcGUgaW4gdGhpcy5mcmVlVGV4dHVyZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyZWVUZXh0dXJlcy5oYXNPd25Qcm9wZXJ0eShzaGFwZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUodGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVdW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUZXh0dXJlTWFuYWdlcjtcbn0oKSk7XG5leHBvcnRzLlRleHR1cmVNYW5hZ2VyID0gVGV4dHVyZU1hbmFnZXI7XG5mdW5jdGlvbiBnZXRLZXlGcm9tVGV4dHVyZVNoYXBlKHNoYXBlUm93c0NvbCkge1xuICAgIHJldHVybiBzaGFwZVJvd3NDb2xbMF0gKyAnXycgKyBzaGFwZVJvd3NDb2xbMV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXh0dXJlX21hbmFnZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/texture_manager.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/unaryop_gpu.js":
/*!*******************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/unaryop_gpu.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar UnaryOpProgram = (function () {\n    function UnaryOpProgram(aShape, opSnippet) {\n        this.variableNames = ['A'];\n        this.outputShape = aShape;\n        this.params = [opSnippet];\n        this.userCode = \"\\n      float unaryOperation(float x) {\\n        \" + opSnippet + \"\\n      }\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        float y = unaryOperation(x);\\n\\n        setOutput(y);\\n      }\\n    \";\n    }\n    return UnaryOpProgram;\n}());\nexports.UnaryOpProgram = UnaryOpProgram;\nexports.CHECK_NAN_SNIPPET = \"\\n  if (isNaN(x)) {\\n    return x;\\n  }\\n\";\nexports.ABS = \"\\n  return abs(x);\\n\";\nexports.RELU = \"\\n  return (x < 0.0) ? 0.0 : x;\\n\";\nexports.STEP = \"\\n  return (x == x) ? (x > 0.0 ? 1.0 : 0.0) : x;\\n\";\nexports.NEG = \"\\n  return -x;\\n\";\nexports.EXP = \"\\n  return exp(x);\\n\";\nexports.LOG = \"\\n  return log(x);\\n\";\nexports.SQRT = exports.CHECK_NAN_SNIPPET + \"\\n  return sqrt(x);\\n\";\nexports.SIGMOID = \"\\n  return 1.0 / (1.0 + exp(-1.0 * x));\\n\";\nexports.SIN = exports.CHECK_NAN_SNIPPET + \"\\n  return sin(x);\\n\";\nexports.COS = exports.CHECK_NAN_SNIPPET + \"\\n  return cos(x);\\n\";\nexports.TAN = \"\\n  return tan(x);\\n\";\nexports.ASIN = exports.CHECK_NAN_SNIPPET + \"\\n  return asin(x);\\n\";\nexports.ACOS = exports.CHECK_NAN_SNIPPET + \"\\n  return acos(x);\\n\";\nexports.ATAN = exports.CHECK_NAN_SNIPPET + \"\\n  return atan(x);\\n\";\nexports.SINH = \"\\n  float e2x = exp(x);\\n  return (e2x - 1.0 / e2x) / 2.0;\\n\";\nexports.COSH = \"\\n  float e2x = exp(-x);\\n  return (e2x + 1.0 / e2x) / 2.0;\\n\";\nexports.TANH = \"\\n  float e2x = exp(-2.0 * abs(x));\\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\\n\";\n//# sourceMappingURL=unaryop_gpu.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvdW5hcnlvcF9ncHUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvdW5hcnlvcF9ncHUuanM/NWNhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBVbmFyeU9wUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5hcnlPcFByb2dyYW0oYVNoYXBlLCBvcFNuaXBwZXQpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBhU2hhcGU7XG4gICAgICAgIHRoaXMucGFyYW1zID0gW29wU25pcHBldF07XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGZsb2F0IHVuYXJ5T3BlcmF0aW9uKGZsb2F0IHgpIHtcXG4gICAgICAgIFwiICsgb3BTbmlwcGV0ICsgXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgeCA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgeSA9IHVuYXJ5T3BlcmF0aW9uKHgpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KHkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBVbmFyeU9wUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlVuYXJ5T3BQcm9ncmFtID0gVW5hcnlPcFByb2dyYW07XG5leHBvcnRzLkNIRUNLX05BTl9TTklQUEVUID0gXCJcXG4gIGlmIChpc05hTih4KSkge1xcbiAgICByZXR1cm4geDtcXG4gIH1cXG5cIjtcbmV4cG9ydHMuQUJTID0gXCJcXG4gIHJldHVybiBhYnMoeCk7XFxuXCI7XG5leHBvcnRzLlJFTFUgPSBcIlxcbiAgcmV0dXJuICh4IDwgMC4wKSA/IDAuMCA6IHg7XFxuXCI7XG5leHBvcnRzLlNURVAgPSBcIlxcbiAgcmV0dXJuICh4ID09IHgpID8gKHggPiAwLjAgPyAxLjAgOiAwLjApIDogeDtcXG5cIjtcbmV4cG9ydHMuTkVHID0gXCJcXG4gIHJldHVybiAteDtcXG5cIjtcbmV4cG9ydHMuRVhQID0gXCJcXG4gIHJldHVybiBleHAoeCk7XFxuXCI7XG5leHBvcnRzLkxPRyA9IFwiXFxuICByZXR1cm4gbG9nKHgpO1xcblwiO1xuZXhwb3J0cy5TUVJUID0gZXhwb3J0cy5DSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gc3FydCh4KTtcXG5cIjtcbmV4cG9ydHMuU0lHTU9JRCA9IFwiXFxuICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtMS4wICogeCkpO1xcblwiO1xuZXhwb3J0cy5TSU4gPSBleHBvcnRzLkNIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBzaW4oeCk7XFxuXCI7XG5leHBvcnRzLkNPUyA9IGV4cG9ydHMuQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIGNvcyh4KTtcXG5cIjtcbmV4cG9ydHMuVEFOID0gXCJcXG4gIHJldHVybiB0YW4oeCk7XFxuXCI7XG5leHBvcnRzLkFTSU4gPSBleHBvcnRzLkNIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBhc2luKHgpO1xcblwiO1xuZXhwb3J0cy5BQ09TID0gZXhwb3J0cy5DSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gYWNvcyh4KTtcXG5cIjtcbmV4cG9ydHMuQVRBTiA9IGV4cG9ydHMuQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIGF0YW4oeCk7XFxuXCI7XG5leHBvcnRzLlNJTkggPSBcIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKHgpO1xcbiAgcmV0dXJuIChlMnggLSAxLjAgLyBlMngpIC8gMi4wO1xcblwiO1xuZXhwb3J0cy5DT1NIID0gXCJcXG4gIGZsb2F0IGUyeCA9IGV4cCgteCk7XFxuICByZXR1cm4gKGUyeCArIDEuMCAvIGUyeCkgLyAyLjA7XFxuXCI7XG5leHBvcnRzLlRBTkggPSBcIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKC0yLjAgKiBhYnMoeCkpO1xcbiAgcmV0dXJuIHNpZ24oeCkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5hcnlvcF9ncHUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/unaryop_gpu.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/math/webgl/webgl_util.js":
/*!******************************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/math/webgl/webgl_util.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MAX_TEXTURE_SIZE = null;\nvar util = __webpack_require__(/*! ../../util */ \"./node_modules/deeplearn/dist/src/util.js\");\nvar environment_1 = __webpack_require__(/*! ../../environment */ \"./node_modules/deeplearn/dist/src/environment.js\");\nfunction createWebGLRenderingContext(attributes) {\n    var canvas = document.createElement('canvas');\n    canvas.width = 1;\n    canvas.height = 1;\n    return createWebGLRenderingContextFromCanvas(canvas, attributes);\n}\nexports.createWebGLRenderingContext = createWebGLRenderingContext;\nfunction createWebGLRenderingContextFromCanvas(canvas, attributes) {\n    var gl;\n    var webglVersion = environment_1.ENV.get('WEBGL_VERSION');\n    if (webglVersion === 2) {\n        gl = canvas.getContext('webgl2', attributes);\n    }\n    else if (webglVersion === 1) {\n        gl = (canvas.getContext('webgl', attributes) ||\n            canvas.getContext('experimental-webgl', attributes));\n    }\n    if (webglVersion === 0 || gl == null) {\n        throw new Error('This browser does not support WebGL.');\n    }\n    return gl;\n}\nexports.createWebGLRenderingContextFromCanvas = createWebGLRenderingContextFromCanvas;\nfunction callAndCheck(gl, func) {\n    var returnValue = func();\n    checkWebGLError(gl);\n    return returnValue;\n}\nexports.callAndCheck = callAndCheck;\nvar webGLDebugErrorCheckingEnabled = false;\nfunction enableDebugWebGLErrorChecking(enabled) {\n    webGLDebugErrorCheckingEnabled = enabled;\n}\nexports.enableDebugWebGLErrorChecking = enableDebugWebGLErrorChecking;\nfunction checkWebGLError(gl) {\n    if (webGLDebugErrorCheckingEnabled) {\n        var error = gl.getError();\n        if (error !== gl.NO_ERROR) {\n            throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n        }\n    }\n}\nexports.checkWebGLError = checkWebGLError;\nfunction getWebGLErrorMessage(gl, status) {\n    switch (status) {\n        case gl.NO_ERROR:\n            return 'NO_ERROR';\n        case gl.INVALID_ENUM:\n            return 'INVALID_ENUM';\n        case gl.INVALID_VALUE:\n            return 'INVALID_VALUE';\n        case gl.INVALID_OPERATION:\n            return 'INVALID_OPERATION';\n        case gl.INVALID_FRAMEBUFFER_OPERATION:\n            return 'INVALID_FRAMEBUFFER_OPERATION';\n        case gl.OUT_OF_MEMORY:\n            return 'OUT_OF_MEMORY';\n        case gl.CONTEXT_LOST_WEBGL:\n            return 'CONTEXT_LOST_WEBGL';\n        default:\n            return 'Unknown error code ' + status;\n    }\n}\nexports.getWebGLErrorMessage = getWebGLErrorMessage;\nfunction getExtensionOrThrow(gl, extensionName) {\n    return throwIfNull(gl, function () { return gl.getExtension(extensionName); }, 'Extension \"' + extensionName + '\" not supported on this browser.');\n}\nexports.getExtensionOrThrow = getExtensionOrThrow;\nfunction createVertexShader(gl, vertexShaderSource) {\n    var vertexShader = throwIfNull(gl, function () { return gl.createShader(gl.VERTEX_SHADER); }, 'Unable to create vertex WebGLShader.');\n    callAndCheck(gl, function () { return gl.shaderSource(vertexShader, vertexShaderSource); });\n    callAndCheck(gl, function () { return gl.compileShader(vertexShader); });\n    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n        console.log(gl.getShaderInfoLog(vertexShader));\n        throw new Error('Failed to compile vertex shader.');\n    }\n    return vertexShader;\n}\nexports.createVertexShader = createVertexShader;\nfunction createFragmentShader(gl, fragmentShaderSource) {\n    var fragmentShader = throwIfNull(gl, function () { return gl.createShader(gl.FRAGMENT_SHADER); }, 'Unable to create fragment WebGLShader.');\n    callAndCheck(gl, function () { return gl.shaderSource(fragmentShader, fragmentShaderSource); });\n    callAndCheck(gl, function () { return gl.compileShader(fragmentShader); });\n    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n        throw new Error('Failed to compile fragment shader.');\n    }\n    return fragmentShader;\n}\nexports.createFragmentShader = createFragmentShader;\nvar lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nfunction logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {\n    var lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n    if (lineNumberRegexResult == null) {\n        console.log(\"Couldn't parse line number in error: \" + shaderInfoLog);\n        console.log(shaderSource);\n        return;\n    }\n    var lineNumber = +lineNumberRegexResult[1];\n    var shaderLines = shaderSource.split('\\n');\n    var pad = ('' + shaderLines.length).length + 2;\n    var linesWithLineNumbers = shaderLines.map(function (line, lineNumber) { return util.rightPad('' + (lineNumber + 1), pad) + line; });\n    var maxLineLength = 0;\n    for (var i = 0; i < linesWithLineNumbers.length; i++) {\n        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n    }\n    var beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n    var errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n    var afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n    console.log(beforeErrorLines.join('\\n'));\n    console.log(shaderInfoLog.split('\\n')[0]);\n    console.log(\"%c \" + util.rightPad(errorLine[0], maxLineLength), 'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n    console.log(afterErrorLines.join('\\n'));\n}\nfunction createProgram(gl) {\n    return throwIfNull(gl, function () { return gl.createProgram(); }, 'Unable to create WebGLProgram.');\n}\nexports.createProgram = createProgram;\nfunction linkProgram(gl, program) {\n    callAndCheck(gl, function () { return gl.linkProgram(program); });\n    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n        console.log(gl.getProgramInfoLog(program));\n        throw new Error('Failed to link vertex and fragment shaders.');\n    }\n}\nexports.linkProgram = linkProgram;\nfunction validateProgram(gl, program) {\n    callAndCheck(gl, function () { return gl.validateProgram(program); });\n    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n        console.log(gl.getProgramInfoLog(program));\n        throw new Error('Shader program validation failed.');\n    }\n}\nexports.validateProgram = validateProgram;\nfunction createStaticVertexBuffer(gl, data) {\n    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');\n    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });\n    callAndCheck(gl, function () { return gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); });\n    return buffer;\n}\nexports.createStaticVertexBuffer = createStaticVertexBuffer;\nfunction createStaticIndexBuffer(gl, data) {\n    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');\n    callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); });\n    callAndCheck(gl, function () { return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW); });\n    return buffer;\n}\nexports.createStaticIndexBuffer = createStaticIndexBuffer;\nfunction queryMaxTextureSize(gl) {\n    if (MAX_TEXTURE_SIZE != null) {\n        return MAX_TEXTURE_SIZE;\n    }\n    MAX_TEXTURE_SIZE =\n        callAndCheck(gl, function () { return gl.getParameter(gl.MAX_TEXTURE_SIZE); });\n    return MAX_TEXTURE_SIZE;\n}\nexports.queryMaxTextureSize = queryMaxTextureSize;\nfunction getChannelsPerTexture() {\n    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {\n        return 4;\n    }\n    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {\n        return 1;\n    }\n    return 4;\n}\nexports.getChannelsPerTexture = getChannelsPerTexture;\nfunction createTexture(gl) {\n    return throwIfNull(gl, function () { return gl.createTexture(); }, 'Unable to create WebGLTexture.');\n}\nexports.createTexture = createTexture;\nfunction validateTextureSize(gl, width, height) {\n    var maxTextureSize = queryMaxTextureSize(gl);\n    if ((width <= 0) || (height <= 0)) {\n        var requested = '[' + width + 'x' + height + ']';\n        throw new Error('Requested texture size ' + requested + ' is invalid.');\n    }\n    if ((width > maxTextureSize) || (height > maxTextureSize)) {\n        var requested = '[' + width + 'x' + height + ']';\n        var max = '[' + maxTextureSize + 'x' + maxTextureSize + ']';\n        throw new Error('Requested texture size ' + requested +\n            ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n    }\n}\nexports.validateTextureSize = validateTextureSize;\nfunction createFramebuffer(gl) {\n    return throwIfNull(gl, function () { return gl.createFramebuffer(); }, 'Unable to create WebGLFramebuffer.');\n}\nexports.createFramebuffer = createFramebuffer;\nfunction bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes, attribLocations) {\n    var loc = -1;\n    if ((attribLocations != null) && (attribute in attribLocations)) {\n        loc = attribLocations[attribute];\n    }\n    else {\n        loc = gl.getAttribLocation(program, attribute);\n    }\n    if (loc === -1) {\n        return;\n    }\n    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });\n    callAndCheck(gl, function () { return gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes); });\n    callAndCheck(gl, function () { return gl.enableVertexAttribArray(loc); });\n}\nexports.bindVertexBufferToProgramAttribute = bindVertexBufferToProgramAttribute;\nfunction bindTextureUnit(gl, texture, textureUnit) {\n    validateTextureUnit(gl, textureUnit);\n    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });\n    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });\n}\nexports.bindTextureUnit = bindTextureUnit;\nfunction unbindTextureUnit(gl, textureUnit) {\n    validateTextureUnit(gl, textureUnit);\n    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });\n    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });\n}\nexports.unbindTextureUnit = unbindTextureUnit;\nfunction getProgramUniformLocationOrThrow(gl, program, uniformName) {\n    return throwIfNull(gl, function () { return gl.getUniformLocation(program, uniformName); }, 'uniform \"' + uniformName + '\" not present in program.');\n}\nexports.getProgramUniformLocationOrThrow = getProgramUniformLocationOrThrow;\nfunction bindTextureToProgramUniformSampler(gl, program, texture, uniformSamplerLocation, textureUnit) {\n    callAndCheck(gl, function () { return bindTextureUnit(gl, texture, textureUnit); });\n    callAndCheck(gl, function () { return gl.uniform1i(uniformSamplerLocation, textureUnit); });\n}\nexports.bindTextureToProgramUniformSampler = bindTextureToProgramUniformSampler;\nfunction bindCanvasToFramebuffer(gl) {\n    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });\n    callAndCheck(gl, function () { return gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); });\n    callAndCheck(gl, function () { return gl.scissor(0, 0, gl.canvas.width, gl.canvas.height); });\n}\nexports.bindCanvasToFramebuffer = bindCanvasToFramebuffer;\nfunction bindColorTextureToFramebuffer(gl, texture, framebuffer) {\n    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });\n    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); });\n}\nexports.bindColorTextureToFramebuffer = bindColorTextureToFramebuffer;\nfunction unbindColorTextureFromFramebuffer(gl, framebuffer) {\n    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });\n    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0); });\n}\nexports.unbindColorTextureFromFramebuffer = unbindColorTextureFromFramebuffer;\nfunction validateFramebuffer(gl) {\n    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (status !== gl.FRAMEBUFFER_COMPLETE) {\n        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n    }\n}\nexports.validateFramebuffer = validateFramebuffer;\nfunction getFramebufferErrorMessage(gl, status) {\n    switch (status) {\n        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n        case gl.FRAMEBUFFER_UNSUPPORTED:\n            return 'FRAMEBUFFER_UNSUPPORTED';\n        default:\n            return 'unknown error ' + status;\n    }\n}\nexports.getFramebufferErrorMessage = getFramebufferErrorMessage;\nfunction throwIfNull(gl, returnTOrNull, failureMessage) {\n    var tOrNull = callAndCheck(gl, function () { return returnTOrNull(); });\n    if (tOrNull == null) {\n        throw new Error(failureMessage);\n    }\n    return tOrNull;\n}\nfunction validateTextureUnit(gl, textureUnit) {\n    var maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n    var glTextureUnit = textureUnit + gl.TEXTURE0;\n    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n        var textureUnitRange = '[gl.TEXTURE0, gl.TEXTURE' + maxTextureUnit + ']';\n        throw new Error('textureUnit must be in ' + textureUnitRange + '.');\n    }\n}\nfunction getTextureShapeFromLogicalShape(gl, logShape, preferredTexShape) {\n    var maxTexSize = queryMaxTextureSize(gl);\n    var size = util.sizeFromShape(logShape);\n    if (preferredTexShape != null) {\n        var sizePreferred = util.sizeFromShape(preferredTexShape);\n        util.assert(size === sizePreferred, \"Size of shape (\" + size + \") must match size of \" +\n            (\"preferredShape (\" + sizePreferred + \")\"));\n        if (preferredTexShape[0] <= maxTexSize &&\n            preferredTexShape[1] <= maxTexSize) {\n            return preferredTexShape;\n        }\n    }\n    if (logShape.length <= 1 && size <= maxTexSize) {\n        return [size, 1];\n    }\n    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&\n        logShape[1] <= maxTexSize) {\n        return logShape;\n    }\n    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&\n        logShape[1] * logShape[2] <= maxTexSize) {\n        return [logShape[0], logShape[1] * logShape[2]];\n    }\n    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&\n        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n    }\n    else {\n        return util.sizeToSquarishShape(size);\n    }\n}\nexports.getTextureShapeFromLogicalShape = getTextureShapeFromLogicalShape;\n//# sourceMappingURL=webgl_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL21hdGgvd2ViZ2wvd2ViZ2xfdXRpbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvbWF0aC93ZWJnbC93ZWJnbF91dGlsLmpzP2E3YTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTUFYX1RFWFRVUkVfU0laRSA9IG51bGw7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vZW52aXJvbm1lbnRcIik7XG5mdW5jdGlvbiBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHQoYXR0cmlidXRlcykge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSAxO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIHJldHVybiBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzKGNhbnZhcywgYXR0cmlidXRlcyk7XG59XG5leHBvcnRzLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dCA9IGNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbmZ1bmN0aW9uIGNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXMoY2FudmFzLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGdsO1xuICAgIHZhciB3ZWJnbFZlcnNpb24gPSBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKTtcbiAgICBpZiAod2ViZ2xWZXJzaW9uID09PSAyKSB7XG4gICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh3ZWJnbFZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgZ2wgPSAoY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgYXR0cmlidXRlcykgfHxcbiAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIGlmICh3ZWJnbFZlcnNpb24gPT09IDAgfHwgZ2wgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkdMLicpO1xuICAgIH1cbiAgICByZXR1cm4gZ2w7XG59XG5leHBvcnRzLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXMgPSBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzO1xuZnVuY3Rpb24gY2FsbEFuZENoZWNrKGdsLCBmdW5jKSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gZnVuYygpO1xuICAgIGNoZWNrV2ViR0xFcnJvcihnbCk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuZXhwb3J0cy5jYWxsQW5kQ2hlY2sgPSBjYWxsQW5kQ2hlY2s7XG52YXIgd2ViR0xEZWJ1Z0Vycm9yQ2hlY2tpbmdFbmFibGVkID0gZmFsc2U7XG5mdW5jdGlvbiBlbmFibGVEZWJ1Z1dlYkdMRXJyb3JDaGVja2luZyhlbmFibGVkKSB7XG4gICAgd2ViR0xEZWJ1Z0Vycm9yQ2hlY2tpbmdFbmFibGVkID0gZW5hYmxlZDtcbn1cbmV4cG9ydHMuZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmcgPSBlbmFibGVEZWJ1Z1dlYkdMRXJyb3JDaGVja2luZztcbmZ1bmN0aW9uIGNoZWNrV2ViR0xFcnJvcihnbCkge1xuICAgIGlmICh3ZWJHTERlYnVnRXJyb3JDaGVja2luZ0VuYWJsZWQpIHtcbiAgICAgICAgdmFyIGVycm9yID0gZ2wuZ2V0RXJyb3IoKTtcbiAgICAgICAgaWYgKGVycm9yICE9PSBnbC5OT19FUlJPUikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTCBFcnJvcjogJyArIGdldFdlYkdMRXJyb3JNZXNzYWdlKGdsLCBlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1dlYkdMRXJyb3IgPSBjaGVja1dlYkdMRXJyb3I7XG5mdW5jdGlvbiBnZXRXZWJHTEVycm9yTWVzc2FnZShnbCwgc3RhdHVzKSB7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgY2FzZSBnbC5OT19FUlJPUjpcbiAgICAgICAgICAgIHJldHVybiAnTk9fRVJST1InO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfRU5VTTpcbiAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9FTlVNJztcbiAgICAgICAgY2FzZSBnbC5JTlZBTElEX1ZBTFVFOlxuICAgICAgICAgICAgcmV0dXJuICdJTlZBTElEX1ZBTFVFJztcbiAgICAgICAgY2FzZSBnbC5JTlZBTElEX09QRVJBVElPTjpcbiAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9PUEVSQVRJT04nO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OOlxuICAgICAgICAgICAgcmV0dXJuICdJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTic7XG4gICAgICAgIGNhc2UgZ2wuT1VUX09GX01FTU9SWTpcbiAgICAgICAgICAgIHJldHVybiAnT1VUX09GX01FTU9SWSc7XG4gICAgICAgIGNhc2UgZ2wuQ09OVEVYVF9MT1NUX1dFQkdMOlxuICAgICAgICAgICAgcmV0dXJuICdDT05URVhUX0xPU1RfV0VCR0wnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICdVbmtub3duIGVycm9yIGNvZGUgJyArIHN0YXR1cztcbiAgICB9XG59XG5leHBvcnRzLmdldFdlYkdMRXJyb3JNZXNzYWdlID0gZ2V0V2ViR0xFcnJvck1lc3NhZ2U7XG5mdW5jdGlvbiBnZXRFeHRlbnNpb25PclRocm93KGdsLCBleHRlbnNpb25OYW1lKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5nZXRFeHRlbnNpb24oZXh0ZW5zaW9uTmFtZSk7IH0sICdFeHRlbnNpb24gXCInICsgZXh0ZW5zaW9uTmFtZSArICdcIiBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci4nKTtcbn1cbmV4cG9ydHMuZ2V0RXh0ZW5zaW9uT3JUaHJvdyA9IGdldEV4dGVuc2lvbk9yVGhyb3c7XG5mdW5jdGlvbiBjcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wsIHZlcnRleFNoYWRlclNvdXJjZSkge1xuICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSB2ZXJ0ZXggV2ViR0xTaGFkZXIuJyk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKTsgfSk7XG4gICAgaWYgKGdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0ZXhTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coZ2wuZ2V0U2hhZGVySW5mb0xvZyh2ZXJ0ZXhTaGFkZXIpKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29tcGlsZSB2ZXJ0ZXggc2hhZGVyLicpO1xuICAgIH1cbiAgICByZXR1cm4gdmVydGV4U2hhZGVyO1xufVxuZXhwb3J0cy5jcmVhdGVWZXJ0ZXhTaGFkZXIgPSBjcmVhdGVWZXJ0ZXhTaGFkZXI7XG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudFNoYWRlcihnbCwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpIHtcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7IH0sICdVbmFibGUgdG8gY3JlYXRlIGZyYWdtZW50IFdlYkdMU2hhZGVyLicpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7IH0pO1xuICAgIGlmIChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbG9nU2hhZGVyU291cmNlQW5kSW5mb0xvZyhmcmFnbWVudFNoYWRlclNvdXJjZSwgZ2wuZ2V0U2hhZGVySW5mb0xvZyhmcmFnbWVudFNoYWRlcikpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb21waWxlIGZyYWdtZW50IHNoYWRlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xufVxuZXhwb3J0cy5jcmVhdGVGcmFnbWVudFNoYWRlciA9IGNyZWF0ZUZyYWdtZW50U2hhZGVyO1xudmFyIGxpbmVOdW1iZXJSZWdleCA9IC9FUlJPUjogWzAtOV0rOihbMC05XSspOi9nO1xuZnVuY3Rpb24gbG9nU2hhZGVyU291cmNlQW5kSW5mb0xvZyhzaGFkZXJTb3VyY2UsIHNoYWRlckluZm9Mb2cpIHtcbiAgICB2YXIgbGluZU51bWJlclJlZ2V4UmVzdWx0ID0gbGluZU51bWJlclJlZ2V4LmV4ZWMoc2hhZGVySW5mb0xvZyk7XG4gICAgaWYgKGxpbmVOdW1iZXJSZWdleFJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGRuJ3QgcGFyc2UgbGluZSBudW1iZXIgaW4gZXJyb3I6IFwiICsgc2hhZGVySW5mb0xvZyk7XG4gICAgICAgIGNvbnNvbGUubG9nKHNoYWRlclNvdXJjZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxpbmVOdW1iZXIgPSArbGluZU51bWJlclJlZ2V4UmVzdWx0WzFdO1xuICAgIHZhciBzaGFkZXJMaW5lcyA9IHNoYWRlclNvdXJjZS5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIHBhZCA9ICgnJyArIHNoYWRlckxpbmVzLmxlbmd0aCkubGVuZ3RoICsgMjtcbiAgICB2YXIgbGluZXNXaXRoTGluZU51bWJlcnMgPSBzaGFkZXJMaW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUsIGxpbmVOdW1iZXIpIHsgcmV0dXJuIHV0aWwucmlnaHRQYWQoJycgKyAobGluZU51bWJlciArIDEpLCBwYWQpICsgbGluZTsgfSk7XG4gICAgdmFyIG1heExpbmVMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXNXaXRoTGluZU51bWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWF4TGluZUxlbmd0aCA9IE1hdGgubWF4KGxpbmVzV2l0aExpbmVOdW1iZXJzW2ldLmxlbmd0aCwgbWF4TGluZUxlbmd0aCk7XG4gICAgfVxuICAgIHZhciBiZWZvcmVFcnJvckxpbmVzID0gbGluZXNXaXRoTGluZU51bWJlcnMuc2xpY2UoMCwgbGluZU51bWJlciAtIDEpO1xuICAgIHZhciBlcnJvckxpbmUgPSBsaW5lc1dpdGhMaW5lTnVtYmVycy5zbGljZShsaW5lTnVtYmVyIC0gMSwgbGluZU51bWJlcik7XG4gICAgdmFyIGFmdGVyRXJyb3JMaW5lcyA9IGxpbmVzV2l0aExpbmVOdW1iZXJzLnNsaWNlKGxpbmVOdW1iZXIpO1xuICAgIGNvbnNvbGUubG9nKGJlZm9yZUVycm9yTGluZXMuam9pbignXFxuJykpO1xuICAgIGNvbnNvbGUubG9nKHNoYWRlckluZm9Mb2cuc3BsaXQoJ1xcbicpWzBdKTtcbiAgICBjb25zb2xlLmxvZyhcIiVjIFwiICsgdXRpbC5yaWdodFBhZChlcnJvckxpbmVbMF0sIG1heExpbmVMZW5ndGgpLCAnYm9yZGVyOjFweCBzb2xpZCByZWQ7IGJhY2tncm91bmQtY29sb3I6I2UzZDJkMjsgY29sb3I6I2E2MTcxNycpO1xuICAgIGNvbnNvbGUubG9nKGFmdGVyRXJyb3JMaW5lcy5qb2luKCdcXG4nKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9ncmFtKGdsKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVQcm9ncmFtKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMUHJvZ3JhbS4nKTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW07XG5mdW5jdGlvbiBsaW5rUHJvZ3JhbShnbCwgcHJvZ3JhbSkge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7IH0pO1xuICAgIGlmIChnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsaW5rIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycy4nKTtcbiAgICB9XG59XG5leHBvcnRzLmxpbmtQcm9ncmFtID0gbGlua1Byb2dyYW07XG5mdW5jdGlvbiB2YWxpZGF0ZVByb2dyYW0oZ2wsIHByb2dyYW0pIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnZhbGlkYXRlUHJvZ3JhbShwcm9ncmFtKTsgfSk7XG4gICAgaWYgKGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWRlciBwcm9ncmFtIHZhbGlkYXRpb24gZmFpbGVkLicpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVQcm9ncmFtID0gdmFsaWRhdGVQcm9ncmFtO1xuZnVuY3Rpb24gY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyKGdsLCBkYXRhKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVCdWZmZXIoKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgV2ViR0xCdWZmZXInKTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7IH0pO1xuICAgIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLmNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlciA9IGNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcjtcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyKGdsLCBkYXRhKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVCdWZmZXIoKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgV2ViR0xCdWZmZXInKTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpOyB9KTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5jcmVhdGVTdGF0aWNJbmRleEJ1ZmZlciA9IGNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyO1xuZnVuY3Rpb24gcXVlcnlNYXhUZXh0dXJlU2l6ZShnbCkge1xuICAgIGlmIChNQVhfVEVYVFVSRV9TSVpFICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE1BWF9URVhUVVJFX1NJWkU7XG4gICAgfVxuICAgIE1BWF9URVhUVVJFX1NJWkUgPVxuICAgICAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKTsgfSk7XG4gICAgcmV0dXJuIE1BWF9URVhUVVJFX1NJWkU7XG59XG5leHBvcnRzLnF1ZXJ5TWF4VGV4dHVyZVNpemUgPSBxdWVyeU1heFRleHR1cmVTaXplO1xuZnVuY3Rpb24gZ2V0Q2hhbm5lbHNQZXJUZXh0dXJlKCkge1xuICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSkge1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gNDtcbn1cbmV4cG9ydHMuZ2V0Q2hhbm5lbHNQZXJUZXh0dXJlID0gZ2V0Q2hhbm5lbHNQZXJUZXh0dXJlO1xuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShnbCkge1xuICAgIHJldHVybiB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3JlYXRlVGV4dHVyZSgpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTFRleHR1cmUuJyk7XG59XG5leHBvcnRzLmNyZWF0ZVRleHR1cmUgPSBjcmVhdGVUZXh0dXJlO1xuZnVuY3Rpb24gdmFsaWRhdGVUZXh0dXJlU2l6ZShnbCwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBtYXhUZXh0dXJlU2l6ZSA9IHF1ZXJ5TWF4VGV4dHVyZVNpemUoZ2wpO1xuICAgIGlmICgod2lkdGggPD0gMCkgfHwgKGhlaWdodCA8PSAwKSkge1xuICAgICAgICB2YXIgcmVxdWVzdGVkID0gJ1snICsgd2lkdGggKyAneCcgKyBoZWlnaHQgKyAnXSc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSAnICsgcmVxdWVzdGVkICsgJyBpcyBpbnZhbGlkLicpO1xuICAgIH1cbiAgICBpZiAoKHdpZHRoID4gbWF4VGV4dHVyZVNpemUpIHx8IChoZWlnaHQgPiBtYXhUZXh0dXJlU2l6ZSkpIHtcbiAgICAgICAgdmFyIHJlcXVlc3RlZCA9ICdbJyArIHdpZHRoICsgJ3gnICsgaGVpZ2h0ICsgJ10nO1xuICAgICAgICB2YXIgbWF4ID0gJ1snICsgbWF4VGV4dHVyZVNpemUgKyAneCcgKyBtYXhUZXh0dXJlU2l6ZSArICddJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0ZWQgdGV4dHVyZSBzaXplICcgKyByZXF1ZXN0ZWQgK1xuICAgICAgICAgICAgJyBncmVhdGVyIHRoYW4gV2ViR0wgbWF4aW11bSBvbiB0aGlzIGJyb3dzZXIgLyBHUFUgJyArIG1heCArICcuJyk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVRleHR1cmVTaXplID0gdmFsaWRhdGVUZXh0dXJlU2l6ZTtcbmZ1bmN0aW9uIGNyZWF0ZUZyYW1lYnVmZmVyKGdsKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEZyYW1lYnVmZmVyLicpO1xufVxuZXhwb3J0cy5jcmVhdGVGcmFtZWJ1ZmZlciA9IGNyZWF0ZUZyYW1lYnVmZmVyO1xuZnVuY3Rpb24gYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgYXR0cmlidXRlLCBidWZmZXIsIGFycmF5RW50cmllc1Blckl0ZW0sIGl0ZW1TdHJpZGVJbkJ5dGVzLCBpdGVtT2Zmc2V0SW5CeXRlcywgYXR0cmliTG9jYXRpb25zKSB7XG4gICAgdmFyIGxvYyA9IC0xO1xuICAgIGlmICgoYXR0cmliTG9jYXRpb25zICE9IG51bGwpICYmIChhdHRyaWJ1dGUgaW4gYXR0cmliTG9jYXRpb25zKSkge1xuICAgICAgICBsb2MgPSBhdHRyaWJMb2NhdGlvbnNbYXR0cmlidXRlXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxvYyA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHJpYnV0ZSk7XG4gICAgfVxuICAgIGlmIChsb2MgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvYywgYXJyYXlFbnRyaWVzUGVySXRlbSwgZ2wuRkxPQVQsIGZhbHNlLCBpdGVtU3RyaWRlSW5CeXRlcywgaXRlbU9mZnNldEluQnl0ZXMpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvYyk7IH0pO1xufVxuZXhwb3J0cy5iaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlID0gYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZTtcbmZ1bmN0aW9uIGJpbmRUZXh0dXJlVW5pdChnbCwgdGV4dHVyZSwgdGV4dHVyZVVuaXQpIHtcbiAgICB2YWxpZGF0ZVRleHR1cmVVbml0KGdsLCB0ZXh0dXJlVW5pdCk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZVVuaXQpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpOyB9KTtcbn1cbmV4cG9ydHMuYmluZFRleHR1cmVVbml0ID0gYmluZFRleHR1cmVVbml0O1xuZnVuY3Rpb24gdW5iaW5kVGV4dHVyZVVuaXQoZ2wsIHRleHR1cmVVbml0KSB7XG4gICAgdmFsaWRhdGVUZXh0dXJlVW5pdChnbCwgdGV4dHVyZVVuaXQpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVVbml0KTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTsgfSk7XG59XG5leHBvcnRzLnVuYmluZFRleHR1cmVVbml0ID0gdW5iaW5kVGV4dHVyZVVuaXQ7XG5mdW5jdGlvbiBnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdyhnbCwgcHJvZ3JhbSwgdW5pZm9ybU5hbWUpIHtcbiAgICByZXR1cm4gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtTmFtZSk7IH0sICd1bmlmb3JtIFwiJyArIHVuaWZvcm1OYW1lICsgJ1wiIG5vdCBwcmVzZW50IGluIHByb2dyYW0uJyk7XG59XG5leHBvcnRzLmdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93ID0gZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3c7XG5mdW5jdGlvbiBiaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyKGdsLCBwcm9ncmFtLCB0ZXh0dXJlLCB1bmlmb3JtU2FtcGxlckxvY2F0aW9uLCB0ZXh0dXJlVW5pdCkge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYmluZFRleHR1cmVVbml0KGdsLCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudW5pZm9ybTFpKHVuaWZvcm1TYW1wbGVyTG9jYXRpb24sIHRleHR1cmVVbml0KTsgfSk7XG59XG5leHBvcnRzLmJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXIgPSBiaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyO1xuZnVuY3Rpb24gYmluZENhbnZhc1RvRnJhbWVidWZmZXIoZ2wpIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudmlld3BvcnQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5zY2lzc29yKDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7IH0pO1xufVxuZXhwb3J0cy5iaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlciA9IGJpbmRDYW52YXNUb0ZyYW1lYnVmZmVyO1xuZnVuY3Rpb24gYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIoZ2wsIHRleHR1cmUsIGZyYW1lYnVmZmVyKSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApOyB9KTtcbn1cbmV4cG9ydHMuYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIgPSBiaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcjtcbmZ1bmN0aW9uIHVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlcihnbCwgZnJhbWVidWZmZXIpIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgbnVsbCwgMCk7IH0pO1xufVxuZXhwb3J0cy51bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIgPSB1bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXI7XG5mdW5jdGlvbiB2YWxpZGF0ZUZyYW1lYnVmZmVyKGdsKSB7XG4gICAgdmFyIHN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpO1xuICAgIGlmIChzdGF0dXMgIT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYmluZGluZyBmcmFtZWJ1ZmZlcjogJyArIGdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlKGdsLCBzdGF0dXMpKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlRnJhbWVidWZmZXIgPSB2YWxpZGF0ZUZyYW1lYnVmZmVyO1xuZnVuY3Rpb24gZ2V0RnJhbWVidWZmZXJFcnJvck1lc3NhZ2UoZ2wsIHN0YXR1cykge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UOlxuICAgICAgICAgICAgcmV0dXJuICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQnO1xuICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOlxuICAgICAgICAgICAgcmV0dXJuICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCc7XG4gICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TOlxuICAgICAgICAgICAgcmV0dXJuICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlMnO1xuICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEOlxuICAgICAgICAgICAgcmV0dXJuICdGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ3Vua25vd24gZXJyb3IgJyArIHN0YXR1cztcbiAgICB9XG59XG5leHBvcnRzLmdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlID0gZ2V0RnJhbWVidWZmZXJFcnJvck1lc3NhZ2U7XG5mdW5jdGlvbiB0aHJvd0lmTnVsbChnbCwgcmV0dXJuVE9yTnVsbCwgZmFpbHVyZU1lc3NhZ2UpIHtcbiAgICB2YXIgdE9yTnVsbCA9IGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmV0dXJuVE9yTnVsbCgpOyB9KTtcbiAgICBpZiAodE9yTnVsbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmYWlsdXJlTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB0T3JOdWxsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVUZXh0dXJlVW5pdChnbCwgdGV4dHVyZVVuaXQpIHtcbiAgICB2YXIgbWF4VGV4dHVyZVVuaXQgPSBnbC5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyAtIDE7XG4gICAgdmFyIGdsVGV4dHVyZVVuaXQgPSB0ZXh0dXJlVW5pdCArIGdsLlRFWFRVUkUwO1xuICAgIGlmIChnbFRleHR1cmVVbml0IDwgZ2wuVEVYVFVSRTAgfHwgZ2xUZXh0dXJlVW5pdCA+IG1heFRleHR1cmVVbml0KSB7XG4gICAgICAgIHZhciB0ZXh0dXJlVW5pdFJhbmdlID0gJ1tnbC5URVhUVVJFMCwgZ2wuVEVYVFVSRScgKyBtYXhUZXh0dXJlVW5pdCArICddJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZXh0dXJlVW5pdCBtdXN0IGJlIGluICcgKyB0ZXh0dXJlVW5pdFJhbmdlICsgJy4nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlKGdsLCBsb2dTaGFwZSwgcHJlZmVycmVkVGV4U2hhcGUpIHtcbiAgICB2YXIgbWF4VGV4U2l6ZSA9IHF1ZXJ5TWF4VGV4dHVyZVNpemUoZ2wpO1xuICAgIHZhciBzaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKGxvZ1NoYXBlKTtcbiAgICBpZiAocHJlZmVycmVkVGV4U2hhcGUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgc2l6ZVByZWZlcnJlZCA9IHV0aWwuc2l6ZUZyb21TaGFwZShwcmVmZXJyZWRUZXhTaGFwZSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHNpemUgPT09IHNpemVQcmVmZXJyZWQsIFwiU2l6ZSBvZiBzaGFwZSAoXCIgKyBzaXplICsgXCIpIG11c3QgbWF0Y2ggc2l6ZSBvZiBcIiArXG4gICAgICAgICAgICAoXCJwcmVmZXJyZWRTaGFwZSAoXCIgKyBzaXplUHJlZmVycmVkICsgXCIpXCIpKTtcbiAgICAgICAgaWYgKHByZWZlcnJlZFRleFNoYXBlWzBdIDw9IG1heFRleFNpemUgJiZcbiAgICAgICAgICAgIHByZWZlcnJlZFRleFNoYXBlWzFdIDw9IG1heFRleFNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmZXJyZWRUZXhTaGFwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobG9nU2hhcGUubGVuZ3RoIDw9IDEgJiYgc2l6ZSA8PSBtYXhUZXhTaXplKSB7XG4gICAgICAgIHJldHVybiBbc2l6ZSwgMV07XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gMiAmJiBsb2dTaGFwZVswXSA8PSBtYXhUZXhTaXplICYmXG4gICAgICAgIGxvZ1NoYXBlWzFdIDw9IG1heFRleFNpemUpIHtcbiAgICAgICAgcmV0dXJuIGxvZ1NoYXBlO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDMgJiYgbG9nU2hhcGVbMF0gPD0gbWF4VGV4U2l6ZSAmJlxuICAgICAgICBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdIDw9IG1heFRleFNpemUpIHtcbiAgICAgICAgcmV0dXJuIFtsb2dTaGFwZVswXSwgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXV07XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gNCAmJiBsb2dTaGFwZVswXSA8PSBtYXhUZXhTaXplICYmXG4gICAgICAgIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gKiBsb2dTaGFwZVszXSA8PSBtYXhUZXhTaXplKSB7XG4gICAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0sIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gKiBsb2dTaGFwZVszXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdXRpbC5zaXplVG9TcXVhcmlzaFNoYXBlKHNpemUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZSA9IGdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJnbF91dGlsLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/math/webgl/webgl_util.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/test_util.js":
/*!******************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/test_util.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar environment = __webpack_require__(/*! ./environment */ \"./node_modules/deeplearn/dist/src/environment.js\");\nvar environment_1 = __webpack_require__(/*! ./environment */ \"./node_modules/deeplearn/dist/src/environment.js\");\nvar math_cpu_1 = __webpack_require__(/*! ./math/math_cpu */ \"./node_modules/deeplearn/dist/src/math/math_cpu.js\");\nvar math_gpu_1 = __webpack_require__(/*! ./math/math_gpu */ \"./node_modules/deeplearn/dist/src/math/math_gpu.js\");\nexports.TEST_EPSILON = 1e-2;\nfunction expectArraysClose(actual, expected, epsilon) {\n    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }\n    if (actual.length !== expected.length) {\n        throw new Error('Matrices have different lengths (' + actual.length + ' vs ' +\n            expected.length + ').');\n    }\n    for (var i = 0; i < expected.length; ++i) {\n        var a = actual[i];\n        var e = expected[i];\n        if (!areClose(a, e, epsilon)) {\n            var actualStr = 'actual[' + i + '] === ' + a;\n            var expectedStr = 'expected[' + i + '] === ' + e;\n            throw new Error('Arrays differ: ' + actualStr + ', ' + expectedStr);\n        }\n    }\n}\nexports.expectArraysClose = expectArraysClose;\nfunction expectNumbersClose(a, e, epsilon) {\n    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }\n    if (!areClose(a, e, epsilon)) {\n        throw new Error('Numbers differ: actual === ' + a + ', expected === ' + e);\n    }\n}\nexports.expectNumbersClose = expectNumbersClose;\nfunction areClose(a, e, epsilon) {\n    if (isNaN(a) && isNaN(e)) {\n        return true;\n    }\n    if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {\n        return false;\n    }\n    return true;\n}\nfunction randomArrayInRange(n, minValue, maxValue) {\n    var v = new Float32Array(n);\n    var range = maxValue - minValue;\n    for (var i = 0; i < n; ++i) {\n        v[i] = (Math.random() * range) + minValue;\n    }\n    return v;\n}\nexports.randomArrayInRange = randomArrayInRange;\nfunction makeIdentity(n) {\n    var i = new Float32Array(n * n);\n    for (var j = 0; j < n; ++j) {\n        i[(j * n) + j] = 1;\n    }\n    return i;\n}\nexports.makeIdentity = makeIdentity;\nfunction setValue(m, mNumRows, mNumCols, v, row, column) {\n    if (row >= mNumRows) {\n        throw new Error('row (' + row + ') must be in [0 ' + mNumRows + '].');\n    }\n    if (column >= mNumCols) {\n        throw new Error('column (' + column + ') must be in [0 ' + mNumCols + '].');\n    }\n    m[(row * mNumCols) + column] = v;\n}\nexports.setValue = setValue;\nfunction cpuMultiplyMatrix(a, aRow, aCol, b, bRow, bCol) {\n    var result = new Float32Array(aRow * bCol);\n    for (var r = 0; r < aRow; ++r) {\n        var aOffset = (r * aCol);\n        var cOffset = (r * bCol);\n        for (var c = 0; c < bCol; ++c) {\n            var d = 0;\n            for (var k = 0; k < aCol; ++k) {\n                d += a[aOffset + k] * b[(k * bCol) + c];\n            }\n            result[cOffset + c] = d;\n        }\n    }\n    return result;\n}\nexports.cpuMultiplyMatrix = cpuMultiplyMatrix;\nfunction cpuDotProduct(a, b) {\n    if (a.length !== b.length) {\n        throw new Error('cpuDotProduct: incompatible vectors.');\n    }\n    var d = 0;\n    for (var i = 0; i < a.length; ++i) {\n        d += a[i] * b[i];\n    }\n    return d;\n}\nexports.cpuDotProduct = cpuDotProduct;\nfunction describeMathCPU(name, tests, featuresList) {\n    var testNameBase = 'math_cpu.' + name;\n    describeWithFeaturesAndExecutor(testNameBase, tests, function (testName, tests, features) { return executeMathTests(testName, tests, function () { return new math_cpu_1.NDArrayMathCPU(); }, features); }, featuresList);\n}\nexports.describeMathCPU = describeMathCPU;\nfunction describeMathGPU(name, tests, featuresList) {\n    var testNameBase = 'math_gpu.' + name;\n    describeWithFeaturesAndExecutor(testNameBase, tests, function (testName, tests, features) { return executeMathTests(testName, tests, function () { return new math_gpu_1.NDArrayMathGPU(); }, features); }, featuresList);\n}\nexports.describeMathGPU = describeMathGPU;\nfunction describeCustom(name, tests, featuresList, customBeforeEach, customAfterEach) {\n    describeWithFeaturesAndExecutor(name, tests, function (testName, tests, features) { return executeTests(testName, tests, features, customBeforeEach, customAfterEach); }, featuresList);\n}\nexports.describeCustom = describeCustom;\nfunction describeWithFeaturesAndExecutor(testNameBase, tests, executor, featuresList) {\n    if (featuresList != null) {\n        featuresList.forEach(function (features) {\n            var testName = testNameBase + ' ' + JSON.stringify(features);\n            executor(testName, tests, features);\n        });\n    }\n    else {\n        executor(testNameBase, tests);\n    }\n}\nfunction executeMathTests(testName, tests, mathFactory, features) {\n    var math;\n    var customBeforeEach = function () {\n        math = mathFactory();\n        math.startScope();\n    };\n    var customAfterEach = function () {\n        math.endScope(null);\n        math.dispose();\n    };\n    var customIt = function (name, testFunc) {\n        it(name, function () { return testFunc(math); });\n    };\n    executeTests(testName, tests, features, customBeforeEach, customAfterEach, customIt);\n}\nexports.executeMathTests = executeMathTests;\nfunction executeTests(testName, tests, features, customBeforeEach, customAfterEach, customIt) {\n    if (customIt === void 0) { customIt = it; }\n    describe(testName, function () {\n        beforeEach(function () {\n            if (features != null) {\n                environment.setEnvironment(new environment_1.Environment(features));\n            }\n            if (customBeforeEach != null) {\n                customBeforeEach();\n            }\n        });\n        afterEach(function () {\n            if (customAfterEach != null) {\n                customAfterEach();\n            }\n            if (features != null) {\n                environment.setEnvironment(new environment_1.Environment());\n            }\n        });\n        tests.forEach(function (test) { return test(customIt); });\n    });\n}\nexports.executeTests = executeTests;\n//# sourceMappingURL=test_util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL3Rlc3RfdXRpbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9zcmMvdGVzdF91dGlsLmpzPzZkZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9lbnZpcm9ubWVudFwiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRcIik7XG52YXIgbWF0aF9jcHVfMSA9IHJlcXVpcmUoXCIuL21hdGgvbWF0aF9jcHVcIik7XG52YXIgbWF0aF9ncHVfMSA9IHJlcXVpcmUoXCIuL21hdGgvbWF0aF9ncHVcIik7XG5leHBvcnRzLlRFU1RfRVBTSUxPTiA9IDFlLTI7XG5mdW5jdGlvbiBleHBlY3RBcnJheXNDbG9zZShhY3R1YWwsIGV4cGVjdGVkLCBlcHNpbG9uKSB7XG4gICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gZXhwb3J0cy5URVNUX0VQU0lMT047IH1cbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPT0gZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWF0cmljZXMgaGF2ZSBkaWZmZXJlbnQgbGVuZ3RocyAoJyArIGFjdHVhbC5sZW5ndGggKyAnIHZzICcgK1xuICAgICAgICAgICAgZXhwZWN0ZWQubGVuZ3RoICsgJykuJyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGEgPSBhY3R1YWxbaV07XG4gICAgICAgIHZhciBlID0gZXhwZWN0ZWRbaV07XG4gICAgICAgIGlmICghYXJlQ2xvc2UoYSwgZSwgZXBzaWxvbikpIHtcbiAgICAgICAgICAgIHZhciBhY3R1YWxTdHIgPSAnYWN0dWFsWycgKyBpICsgJ10gPT09ICcgKyBhO1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkU3RyID0gJ2V4cGVjdGVkWycgKyBpICsgJ10gPT09ICcgKyBlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheXMgZGlmZmVyOiAnICsgYWN0dWFsU3RyICsgJywgJyArIGV4cGVjdGVkU3RyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZXhwZWN0QXJyYXlzQ2xvc2UgPSBleHBlY3RBcnJheXNDbG9zZTtcbmZ1bmN0aW9uIGV4cGVjdE51bWJlcnNDbG9zZShhLCBlLCBlcHNpbG9uKSB7XG4gICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gZXhwb3J0cy5URVNUX0VQU0lMT047IH1cbiAgICBpZiAoIWFyZUNsb3NlKGEsIGUsIGVwc2lsb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtYmVycyBkaWZmZXI6IGFjdHVhbCA9PT0gJyArIGEgKyAnLCBleHBlY3RlZCA9PT0gJyArIGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZXhwZWN0TnVtYmVyc0Nsb3NlID0gZXhwZWN0TnVtYmVyc0Nsb3NlO1xuZnVuY3Rpb24gYXJlQ2xvc2UoYSwgZSwgZXBzaWxvbikge1xuICAgIGlmIChpc05hTihhKSAmJiBpc05hTihlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKGEpIHx8IGlzTmFOKGUpIHx8IE1hdGguYWJzKGEgLSBlKSA+IGVwc2lsb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJhbmRvbUFycmF5SW5SYW5nZShuLCBtaW5WYWx1ZSwgbWF4VmFsdWUpIHtcbiAgICB2YXIgdiA9IG5ldyBGbG9hdDMyQXJyYXkobik7XG4gICAgdmFyIHJhbmdlID0gbWF4VmFsdWUgLSBtaW5WYWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICB2W2ldID0gKE1hdGgucmFuZG9tKCkgKiByYW5nZSkgKyBtaW5WYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5leHBvcnRzLnJhbmRvbUFycmF5SW5SYW5nZSA9IHJhbmRvbUFycmF5SW5SYW5nZTtcbmZ1bmN0aW9uIG1ha2VJZGVudGl0eShuKSB7XG4gICAgdmFyIGkgPSBuZXcgRmxvYXQzMkFycmF5KG4gKiBuKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgICBpWyhqICogbikgKyBqXSA9IDE7XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuZXhwb3J0cy5tYWtlSWRlbnRpdHkgPSBtYWtlSWRlbnRpdHk7XG5mdW5jdGlvbiBzZXRWYWx1ZShtLCBtTnVtUm93cywgbU51bUNvbHMsIHYsIHJvdywgY29sdW1uKSB7XG4gICAgaWYgKHJvdyA+PSBtTnVtUm93cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdyAoJyArIHJvdyArICcpIG11c3QgYmUgaW4gWzAgJyArIG1OdW1Sb3dzICsgJ10uJyk7XG4gICAgfVxuICAgIGlmIChjb2x1bW4gPj0gbU51bUNvbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb2x1bW4gKCcgKyBjb2x1bW4gKyAnKSBtdXN0IGJlIGluIFswICcgKyBtTnVtQ29scyArICddLicpO1xuICAgIH1cbiAgICBtWyhyb3cgKiBtTnVtQ29scykgKyBjb2x1bW5dID0gdjtcbn1cbmV4cG9ydHMuc2V0VmFsdWUgPSBzZXRWYWx1ZTtcbmZ1bmN0aW9uIGNwdU11bHRpcGx5TWF0cml4KGEsIGFSb3csIGFDb2wsIGIsIGJSb3csIGJDb2wpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShhUm93ICogYkNvbCk7XG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCBhUm93OyArK3IpIHtcbiAgICAgICAgdmFyIGFPZmZzZXQgPSAociAqIGFDb2wpO1xuICAgICAgICB2YXIgY09mZnNldCA9IChyICogYkNvbCk7XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgYkNvbDsgKytjKSB7XG4gICAgICAgICAgICB2YXIgZCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGFDb2w7ICsraykge1xuICAgICAgICAgICAgICAgIGQgKz0gYVthT2Zmc2V0ICsga10gKiBiWyhrICogYkNvbCkgKyBjXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjT2Zmc2V0ICsgY10gPSBkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmNwdU11bHRpcGx5TWF0cml4ID0gY3B1TXVsdGlwbHlNYXRyaXg7XG5mdW5jdGlvbiBjcHVEb3RQcm9kdWN0KGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3B1RG90UHJvZHVjdDogaW5jb21wYXRpYmxlIHZlY3RvcnMuJyk7XG4gICAgfVxuICAgIHZhciBkID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZCArPSBhW2ldICogYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGQ7XG59XG5leHBvcnRzLmNwdURvdFByb2R1Y3QgPSBjcHVEb3RQcm9kdWN0O1xuZnVuY3Rpb24gZGVzY3JpYmVNYXRoQ1BVKG5hbWUsIHRlc3RzLCBmZWF0dXJlc0xpc3QpIHtcbiAgICB2YXIgdGVzdE5hbWVCYXNlID0gJ21hdGhfY3B1LicgKyBuYW1lO1xuICAgIGRlc2NyaWJlV2l0aEZlYXR1cmVzQW5kRXhlY3V0b3IodGVzdE5hbWVCYXNlLCB0ZXN0cywgZnVuY3Rpb24gKHRlc3ROYW1lLCB0ZXN0cywgZmVhdHVyZXMpIHsgcmV0dXJuIGV4ZWN1dGVNYXRoVGVzdHModGVzdE5hbWUsIHRlc3RzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgbWF0aF9jcHVfMS5OREFycmF5TWF0aENQVSgpOyB9LCBmZWF0dXJlcyk7IH0sIGZlYXR1cmVzTGlzdCk7XG59XG5leHBvcnRzLmRlc2NyaWJlTWF0aENQVSA9IGRlc2NyaWJlTWF0aENQVTtcbmZ1bmN0aW9uIGRlc2NyaWJlTWF0aEdQVShuYW1lLCB0ZXN0cywgZmVhdHVyZXNMaXN0KSB7XG4gICAgdmFyIHRlc3ROYW1lQmFzZSA9ICdtYXRoX2dwdS4nICsgbmFtZTtcbiAgICBkZXNjcmliZVdpdGhGZWF0dXJlc0FuZEV4ZWN1dG9yKHRlc3ROYW1lQmFzZSwgdGVzdHMsIGZ1bmN0aW9uICh0ZXN0TmFtZSwgdGVzdHMsIGZlYXR1cmVzKSB7IHJldHVybiBleGVjdXRlTWF0aFRlc3RzKHRlc3ROYW1lLCB0ZXN0cywgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IG1hdGhfZ3B1XzEuTkRBcnJheU1hdGhHUFUoKTsgfSwgZmVhdHVyZXMpOyB9LCBmZWF0dXJlc0xpc3QpO1xufVxuZXhwb3J0cy5kZXNjcmliZU1hdGhHUFUgPSBkZXNjcmliZU1hdGhHUFU7XG5mdW5jdGlvbiBkZXNjcmliZUN1c3RvbShuYW1lLCB0ZXN0cywgZmVhdHVyZXNMaXN0LCBjdXN0b21CZWZvcmVFYWNoLCBjdXN0b21BZnRlckVhY2gpIHtcbiAgICBkZXNjcmliZVdpdGhGZWF0dXJlc0FuZEV4ZWN1dG9yKG5hbWUsIHRlc3RzLCBmdW5jdGlvbiAodGVzdE5hbWUsIHRlc3RzLCBmZWF0dXJlcykgeyByZXR1cm4gZXhlY3V0ZVRlc3RzKHRlc3ROYW1lLCB0ZXN0cywgZmVhdHVyZXMsIGN1c3RvbUJlZm9yZUVhY2gsIGN1c3RvbUFmdGVyRWFjaCk7IH0sIGZlYXR1cmVzTGlzdCk7XG59XG5leHBvcnRzLmRlc2NyaWJlQ3VzdG9tID0gZGVzY3JpYmVDdXN0b207XG5mdW5jdGlvbiBkZXNjcmliZVdpdGhGZWF0dXJlc0FuZEV4ZWN1dG9yKHRlc3ROYW1lQmFzZSwgdGVzdHMsIGV4ZWN1dG9yLCBmZWF0dXJlc0xpc3QpIHtcbiAgICBpZiAoZmVhdHVyZXNMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgZmVhdHVyZXNMaXN0LmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmVzKSB7XG4gICAgICAgICAgICB2YXIgdGVzdE5hbWUgPSB0ZXN0TmFtZUJhc2UgKyAnICcgKyBKU09OLnN0cmluZ2lmeShmZWF0dXJlcyk7XG4gICAgICAgICAgICBleGVjdXRvcih0ZXN0TmFtZSwgdGVzdHMsIGZlYXR1cmVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBleGVjdXRvcih0ZXN0TmFtZUJhc2UsIHRlc3RzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBleGVjdXRlTWF0aFRlc3RzKHRlc3ROYW1lLCB0ZXN0cywgbWF0aEZhY3RvcnksIGZlYXR1cmVzKSB7XG4gICAgdmFyIG1hdGg7XG4gICAgdmFyIGN1c3RvbUJlZm9yZUVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1hdGggPSBtYXRoRmFjdG9yeSgpO1xuICAgICAgICBtYXRoLnN0YXJ0U2NvcGUoKTtcbiAgICB9O1xuICAgIHZhciBjdXN0b21BZnRlckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1hdGguZW5kU2NvcGUobnVsbCk7XG4gICAgICAgIG1hdGguZGlzcG9zZSgpO1xuICAgIH07XG4gICAgdmFyIGN1c3RvbUl0ID0gZnVuY3Rpb24gKG5hbWUsIHRlc3RGdW5jKSB7XG4gICAgICAgIGl0KG5hbWUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRlc3RGdW5jKG1hdGgpOyB9KTtcbiAgICB9O1xuICAgIGV4ZWN1dGVUZXN0cyh0ZXN0TmFtZSwgdGVzdHMsIGZlYXR1cmVzLCBjdXN0b21CZWZvcmVFYWNoLCBjdXN0b21BZnRlckVhY2gsIGN1c3RvbUl0KTtcbn1cbmV4cG9ydHMuZXhlY3V0ZU1hdGhUZXN0cyA9IGV4ZWN1dGVNYXRoVGVzdHM7XG5mdW5jdGlvbiBleGVjdXRlVGVzdHModGVzdE5hbWUsIHRlc3RzLCBmZWF0dXJlcywgY3VzdG9tQmVmb3JlRWFjaCwgY3VzdG9tQWZ0ZXJFYWNoLCBjdXN0b21JdCkge1xuICAgIGlmIChjdXN0b21JdCA9PT0gdm9pZCAwKSB7IGN1c3RvbUl0ID0gaXQ7IH1cbiAgICBkZXNjcmliZSh0ZXN0TmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChmZWF0dXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnQuc2V0RW52aXJvbm1lbnQobmV3IGVudmlyb25tZW50XzEuRW52aXJvbm1lbnQoZmVhdHVyZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXN0b21CZWZvcmVFYWNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXN0b21CZWZvcmVFYWNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhZnRlckVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGN1c3RvbUFmdGVyRWFjaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tQWZ0ZXJFYWNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmVhdHVyZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVudmlyb25tZW50LnNldEVudmlyb25tZW50KG5ldyBlbnZpcm9ubWVudF8xLkVudmlyb25tZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGVzdHMuZm9yRWFjaChmdW5jdGlvbiAodGVzdCkgeyByZXR1cm4gdGVzdChjdXN0b21JdCk7IH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5leGVjdXRlVGVzdHMgPSBleGVjdXRlVGVzdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXN0X3V0aWwuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/test_util.js\n");

/***/ }),

/***/ "./node_modules/deeplearn/dist/src/util.js":
/*!*************************************************!*\
  !*** ./node_modules/deeplearn/dist/src/util.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction shuffle(array) {\n    var counter = array.length;\n    var temp = 0;\n    var index = 0;\n    while (counter > 0) {\n        index = (Math.random() * counter) | 0;\n        counter--;\n        temp = array[counter];\n        array[counter] = array[index];\n        array[index] = temp;\n    }\n}\nexports.shuffle = shuffle;\nfunction clamp(min, x, max) {\n    return Math.max(min, Math.min(x, max));\n}\nexports.clamp = clamp;\nfunction randUniform(a, b) {\n    return Math.random() * (b - a) + a;\n}\nexports.randUniform = randUniform;\nfunction randGauss(mean, stdDev, truncated) {\n    if (mean === void 0) { mean = 0; }\n    if (stdDev === void 0) { stdDev = 1; }\n    if (truncated === void 0) { truncated = false; }\n    var v1, v2, s;\n    do {\n        v1 = 2 * Math.random() - 1;\n        v2 = 2 * Math.random() - 1;\n        s = v1 * v1 + v2 * v2;\n    } while (s > 1);\n    var result = Math.sqrt(-2 * Math.log(s) / s) * v1;\n    if (truncated && Math.abs(result) > 2) {\n        return randGauss(mean, stdDev, true);\n    }\n    return mean + stdDev * result;\n}\nexports.randGauss = randGauss;\nfunction distSquared(a, b) {\n    var result = 0;\n    for (var i = 0; i < a.length; i++) {\n        var diff = a[i] - b[i];\n        result += diff * diff;\n    }\n    return result;\n}\nexports.distSquared = distSquared;\nfunction assert(expr, msg) {\n    if (!expr) {\n        throw new Error(msg);\n    }\n}\nexports.assert = assert;\nfunction assertShapesMatch(shapeA, shapeB, errorMessagePrefix) {\n    if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }\n    assert(arraysEqual(shapeA, shapeB), errorMessagePrefix + (\"Shapes \" + shapeA + \" and \" + shapeB + \" must match\"));\n}\nexports.assertShapesMatch = assertShapesMatch;\nfunction flatten(arr, ret) {\n    ret = (ret === undefined ? [] : ret);\n    for (var i = 0; i < arr.length; ++i) {\n        if (Array.isArray(arr[i])) {\n            flatten(arr[i], ret);\n        }\n        else {\n            ret.push(arr[i]);\n        }\n    }\n    return ret;\n}\nexports.flatten = flatten;\nfunction inferShape(arr) {\n    var shape = [];\n    while (arr instanceof Array) {\n        shape.push(arr.length);\n        arr = arr[0];\n    }\n    return shape;\n}\nexports.inferShape = inferShape;\nfunction sizeFromShape(shape) {\n    if (shape.length === 0) {\n        return 1;\n    }\n    var size = shape[0];\n    for (var i = 1; i < shape.length; i++) {\n        size *= shape[i];\n    }\n    return size;\n}\nexports.sizeFromShape = sizeFromShape;\nfunction isScalarShape(shape) {\n    return shape.length === 0;\n}\nexports.isScalarShape = isScalarShape;\nfunction arraysEqual(n1, n2) {\n    if (n1.length !== n2.length) {\n        return false;\n    }\n    for (var i = 0; i < n1.length; i++) {\n        if (n1[i] !== n2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.arraysEqual = arraysEqual;\nfunction isInt(a) {\n    return a % 1 === 0;\n}\nexports.isInt = isInt;\nfunction tanh(x) {\n    if (Math.tanh != null) {\n        return Math.tanh(x);\n    }\n    if (x === Infinity) {\n        return 1;\n    }\n    else if (x === -Infinity) {\n        return -1;\n    }\n    else {\n        var e2x = Math.exp(2 * x);\n        return (e2x - 1) / (e2x + 1);\n    }\n}\nexports.tanh = tanh;\nfunction sizeToSquarishShape(size) {\n    for (var a = Math.floor(Math.sqrt(size)); a > 1; --a) {\n        if (size % a === 0) {\n            return [a, size / a];\n        }\n    }\n    return [1, size];\n}\nexports.sizeToSquarishShape = sizeToSquarishShape;\nfunction createShuffledIndices(n) {\n    var shuffledIndices = new Uint32Array(n);\n    for (var i = 0; i < n; ++i) {\n        shuffledIndices[i] = i;\n    }\n    shuffle(shuffledIndices);\n    return shuffledIndices;\n}\nexports.createShuffledIndices = createShuffledIndices;\nfunction assertAndGetBroadcastedShape(shapeA, shapeB) {\n    var result = [];\n    var nextADimMustBeOne = false;\n    var nextBDimMustBeOne = false;\n    var errMsg = \"Operands could not be broadcast together with shapes \" +\n        (shapeA + \" and \" + shapeB + \". Currently, we only support a \") +\n        \"stricter version of broadcasting than numpy.\";\n    var l = Math.max(shapeA.length, shapeB.length);\n    shapeA = shapeA.slice().reverse();\n    shapeB = shapeB.slice().reverse();\n    for (var i = 0; i < l; i++) {\n        var a = shapeA[i] || 1;\n        var b = shapeB[i] || 1;\n        if ((b > 1 && nextBDimMustBeOne) || (a > 1 && nextADimMustBeOne)) {\n            throw Error(errMsg);\n        }\n        if (a > 1 && b === 1) {\n            nextBDimMustBeOne = true;\n        }\n        if (b > 1 && a === 1) {\n            nextADimMustBeOne = true;\n        }\n        if (a > 1 && b > 1 && a !== b) {\n            throw Error(errMsg);\n        }\n        result.push(Math.max(a, b));\n    }\n    return result.reverse();\n}\nexports.assertAndGetBroadcastedShape = assertAndGetBroadcastedShape;\nfunction rightPad(a, size) {\n    if (size <= a.length) {\n        return a;\n    }\n    return a + ' '.repeat(size - a.length);\n}\nexports.rightPad = rightPad;\nfunction repeatedTry(checkFn, delayFn, maxCounter) {\n    if (delayFn === void 0) { delayFn = function (counter) { return 0; }; }\n    return new Promise(function (resolve, reject) {\n        var tryCount = 0;\n        var tryFn = function () {\n            if (checkFn()) {\n                resolve();\n                return;\n            }\n            tryCount++;\n            var nextBackoff = delayFn(tryCount);\n            if (maxCounter != null && tryCount >= maxCounter) {\n                reject();\n                return;\n            }\n            setTimeout(tryFn, nextBackoff);\n        };\n        setTimeout(tryFn, 0);\n    });\n}\nexports.repeatedTry = repeatedTry;\nfunction getQueryParams(queryString) {\n    var params = {};\n    queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (s) {\n        var t = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            t[_i - 1] = arguments[_i];\n        }\n        decodeParam(params, t[0], t[1]);\n        return t.join('=');\n    });\n    return params;\n}\nexports.getQueryParams = getQueryParams;\nfunction decodeParam(params, name, value) {\n    params[decodeURIComponent(name)] = decodeURIComponent(value || '');\n}\nfunction inferFromImplicitShape(shape, size) {\n    var shapeProd = 1;\n    var implicitIdx = -1;\n    for (var i = 0; i < shape.length; ++i) {\n        if (shape[i] > 0) {\n            shapeProd *= shape[i];\n        }\n        else if (shape[i] === -1) {\n            if (implicitIdx !== -1) {\n                throw Error(\"Shapes can only have 1 implicit size. \" +\n                    (\"Found -1 at dim \" + implicitIdx + \" and dim \" + i));\n            }\n            implicitIdx = i;\n        }\n        else if (shape[i] <= 0) {\n            throw Error(\"Shapes can not be <= 0. Found \" + shape[i] + \" at dim \" + i);\n        }\n    }\n    if (implicitIdx === -1) {\n        if (size > 0 && size !== shapeProd) {\n            throw Error(\"Size (\" + size + \") must match the product of shape \" + shape);\n        }\n        return shape;\n    }\n    if (size % shapeProd !== 0) {\n        throw Error(\"The implicit shape can't be a fractional number. \" +\n            (\"Got \" + size + \" / \" + shapeProd));\n    }\n    var newShape = shape.slice();\n    newShape[implicitIdx] = size / shapeProd;\n    return newShape;\n}\nexports.inferFromImplicitShape = inferFromImplicitShape;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL3V0aWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvc3JjL3V0aWwuanM/YzMwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHNodWZmbGUoYXJyYXkpIHtcbiAgICB2YXIgY291bnRlciA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgdGVtcCA9IDA7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoY291bnRlciA+IDApIHtcbiAgICAgICAgaW5kZXggPSAoTWF0aC5yYW5kb20oKSAqIGNvdW50ZXIpIHwgMDtcbiAgICAgICAgY291bnRlci0tO1xuICAgICAgICB0ZW1wID0gYXJyYXlbY291bnRlcl07XG4gICAgICAgIGFycmF5W2NvdW50ZXJdID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBhcnJheVtpbmRleF0gPSB0ZW1wO1xuICAgIH1cbn1cbmV4cG9ydHMuc2h1ZmZsZSA9IHNodWZmbGU7XG5mdW5jdGlvbiBjbGFtcChtaW4sIHgsIG1heCkge1xuICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHgsIG1heCkpO1xufVxuZXhwb3J0cy5jbGFtcCA9IGNsYW1wO1xuZnVuY3Rpb24gcmFuZFVuaWZvcm0oYSwgYikge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKGIgLSBhKSArIGE7XG59XG5leHBvcnRzLnJhbmRVbmlmb3JtID0gcmFuZFVuaWZvcm07XG5mdW5jdGlvbiByYW5kR2F1c3MobWVhbiwgc3RkRGV2LCB0cnVuY2F0ZWQpIHtcbiAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICBpZiAodHJ1bmNhdGVkID09PSB2b2lkIDApIHsgdHJ1bmNhdGVkID0gZmFsc2U7IH1cbiAgICB2YXIgdjEsIHYyLCBzO1xuICAgIGRvIHtcbiAgICAgICAgdjEgPSAyICogTWF0aC5yYW5kb20oKSAtIDE7XG4gICAgICAgIHYyID0gMiAqIE1hdGgucmFuZG9tKCkgLSAxO1xuICAgICAgICBzID0gdjEgKiB2MSArIHYyICogdjI7XG4gICAgfSB3aGlsZSAocyA+IDEpO1xuICAgIHZhciByZXN1bHQgPSBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhzKSAvIHMpICogdjE7XG4gICAgaWYgKHRydW5jYXRlZCAmJiBNYXRoLmFicyhyZXN1bHQpID4gMikge1xuICAgICAgICByZXR1cm4gcmFuZEdhdXNzKG1lYW4sIHN0ZERldiwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBtZWFuICsgc3RkRGV2ICogcmVzdWx0O1xufVxuZXhwb3J0cy5yYW5kR2F1c3MgPSByYW5kR2F1c3M7XG5mdW5jdGlvbiBkaXN0U3F1YXJlZChhLCBiKSB7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkaWZmID0gYVtpXSAtIGJbaV07XG4gICAgICAgIHJlc3VsdCArPSBkaWZmICogZGlmZjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZGlzdFNxdWFyZWQgPSBkaXN0U3F1YXJlZDtcbmZ1bmN0aW9uIGFzc2VydChleHByLCBtc2cpIHtcbiAgICBpZiAoIWV4cHIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5mdW5jdGlvbiBhc3NlcnRTaGFwZXNNYXRjaChzaGFwZUEsIHNoYXBlQiwgZXJyb3JNZXNzYWdlUHJlZml4KSB7XG4gICAgaWYgKGVycm9yTWVzc2FnZVByZWZpeCA9PT0gdm9pZCAwKSB7IGVycm9yTWVzc2FnZVByZWZpeCA9ICcnOyB9XG4gICAgYXNzZXJ0KGFycmF5c0VxdWFsKHNoYXBlQSwgc2hhcGVCKSwgZXJyb3JNZXNzYWdlUHJlZml4ICsgKFwiU2hhcGVzIFwiICsgc2hhcGVBICsgXCIgYW5kIFwiICsgc2hhcGVCICsgXCIgbXVzdCBtYXRjaFwiKSk7XG59XG5leHBvcnRzLmFzc2VydFNoYXBlc01hdGNoID0gYXNzZXJ0U2hhcGVzTWF0Y2g7XG5mdW5jdGlvbiBmbGF0dGVuKGFyciwgcmV0KSB7XG4gICAgcmV0ID0gKHJldCA9PT0gdW5kZWZpbmVkID8gW10gOiByZXQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycltpXSkpIHtcbiAgICAgICAgICAgIGZsYXR0ZW4oYXJyW2ldLCByZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0LnB1c2goYXJyW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZXhwb3J0cy5mbGF0dGVuID0gZmxhdHRlbjtcbmZ1bmN0aW9uIGluZmVyU2hhcGUoYXJyKSB7XG4gICAgdmFyIHNoYXBlID0gW107XG4gICAgd2hpbGUgKGFyciBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHNoYXBlLnB1c2goYXJyLmxlbmd0aCk7XG4gICAgICAgIGFyciA9IGFyclswXTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlO1xufVxuZXhwb3J0cy5pbmZlclNoYXBlID0gaW5mZXJTaGFwZTtcbmZ1bmN0aW9uIHNpemVGcm9tU2hhcGUoc2hhcGUpIHtcbiAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IHNoYXBlWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2l6ZSAqPSBzaGFwZVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5leHBvcnRzLnNpemVGcm9tU2hhcGUgPSBzaXplRnJvbVNoYXBlO1xuZnVuY3Rpb24gaXNTY2FsYXJTaGFwZShzaGFwZSkge1xuICAgIHJldHVybiBzaGFwZS5sZW5ndGggPT09IDA7XG59XG5leHBvcnRzLmlzU2NhbGFyU2hhcGUgPSBpc1NjYWxhclNoYXBlO1xuZnVuY3Rpb24gYXJyYXlzRXF1YWwobjEsIG4yKSB7XG4gICAgaWYgKG4xLmxlbmd0aCAhPT0gbjIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuMS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobjFbaV0gIT09IG4yW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmFycmF5c0VxdWFsID0gYXJyYXlzRXF1YWw7XG5mdW5jdGlvbiBpc0ludChhKSB7XG4gICAgcmV0dXJuIGEgJSAxID09PSAwO1xufVxuZXhwb3J0cy5pc0ludCA9IGlzSW50O1xuZnVuY3Rpb24gdGFuaCh4KSB7XG4gICAgaWYgKE1hdGgudGFuaCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnRhbmgoeCk7XG4gICAgfVxuICAgIGlmICh4ID09PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBlMnggPSBNYXRoLmV4cCgyICogeCk7XG4gICAgICAgIHJldHVybiAoZTJ4IC0gMSkgLyAoZTJ4ICsgMSk7XG4gICAgfVxufVxuZXhwb3J0cy50YW5oID0gdGFuaDtcbmZ1bmN0aW9uIHNpemVUb1NxdWFyaXNoU2hhcGUoc2l6ZSkge1xuICAgIGZvciAodmFyIGEgPSBNYXRoLmZsb29yKE1hdGguc3FydChzaXplKSk7IGEgPiAxOyAtLWEpIHtcbiAgICAgICAgaWYgKHNpemUgJSBhID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW2EsIHNpemUgLyBhXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gWzEsIHNpemVdO1xufVxuZXhwb3J0cy5zaXplVG9TcXVhcmlzaFNoYXBlID0gc2l6ZVRvU3F1YXJpc2hTaGFwZTtcbmZ1bmN0aW9uIGNyZWF0ZVNodWZmbGVkSW5kaWNlcyhuKSB7XG4gICAgdmFyIHNodWZmbGVkSW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheShuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBzaHVmZmxlZEluZGljZXNbaV0gPSBpO1xuICAgIH1cbiAgICBzaHVmZmxlKHNodWZmbGVkSW5kaWNlcyk7XG4gICAgcmV0dXJuIHNodWZmbGVkSW5kaWNlcztcbn1cbmV4cG9ydHMuY3JlYXRlU2h1ZmZsZWRJbmRpY2VzID0gY3JlYXRlU2h1ZmZsZWRJbmRpY2VzO1xuZnVuY3Rpb24gYXNzZXJ0QW5kR2V0QnJvYWRjYXN0ZWRTaGFwZShzaGFwZUEsIHNoYXBlQikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgbmV4dEFEaW1NdXN0QmVPbmUgPSBmYWxzZTtcbiAgICB2YXIgbmV4dEJEaW1NdXN0QmVPbmUgPSBmYWxzZTtcbiAgICB2YXIgZXJyTXNnID0gXCJPcGVyYW5kcyBjb3VsZCBub3QgYmUgYnJvYWRjYXN0IHRvZ2V0aGVyIHdpdGggc2hhcGVzIFwiICtcbiAgICAgICAgKHNoYXBlQSArIFwiIGFuZCBcIiArIHNoYXBlQiArIFwiLiBDdXJyZW50bHksIHdlIG9ubHkgc3VwcG9ydCBhIFwiKSArXG4gICAgICAgIFwic3RyaWN0ZXIgdmVyc2lvbiBvZiBicm9hZGNhc3RpbmcgdGhhbiBudW1weS5cIjtcbiAgICB2YXIgbCA9IE1hdGgubWF4KHNoYXBlQS5sZW5ndGgsIHNoYXBlQi5sZW5ndGgpO1xuICAgIHNoYXBlQSA9IHNoYXBlQS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICBzaGFwZUIgPSBzaGFwZUIuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGEgPSBzaGFwZUFbaV0gfHwgMTtcbiAgICAgICAgdmFyIGIgPSBzaGFwZUJbaV0gfHwgMTtcbiAgICAgICAgaWYgKChiID4gMSAmJiBuZXh0QkRpbU11c3RCZU9uZSkgfHwgKGEgPiAxICYmIG5leHRBRGltTXVzdEJlT25lKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYSA+IDEgJiYgYiA9PT0gMSkge1xuICAgICAgICAgICAgbmV4dEJEaW1NdXN0QmVPbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiID4gMSAmJiBhID09PSAxKSB7XG4gICAgICAgICAgICBuZXh0QURpbU11c3RCZU9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgPiAxICYmIGIgPiAxICYmIGEgIT09IGIpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGVyck1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goTWF0aC5tYXgoYSwgYikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKTtcbn1cbmV4cG9ydHMuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0ZWRTaGFwZSA9IGFzc2VydEFuZEdldEJyb2FkY2FzdGVkU2hhcGU7XG5mdW5jdGlvbiByaWdodFBhZChhLCBzaXplKSB7XG4gICAgaWYgKHNpemUgPD0gYS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHJldHVybiBhICsgJyAnLnJlcGVhdChzaXplIC0gYS5sZW5ndGgpO1xufVxuZXhwb3J0cy5yaWdodFBhZCA9IHJpZ2h0UGFkO1xuZnVuY3Rpb24gcmVwZWF0ZWRUcnkoY2hlY2tGbiwgZGVsYXlGbiwgbWF4Q291bnRlcikge1xuICAgIGlmIChkZWxheUZuID09PSB2b2lkIDApIHsgZGVsYXlGbiA9IGZ1bmN0aW9uIChjb3VudGVyKSB7IHJldHVybiAwOyB9OyB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHRyeUNvdW50ID0gMDtcbiAgICAgICAgdmFyIHRyeUZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGNoZWNrRm4oKSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnlDb3VudCsrO1xuICAgICAgICAgICAgdmFyIG5leHRCYWNrb2ZmID0gZGVsYXlGbih0cnlDb3VudCk7XG4gICAgICAgICAgICBpZiAobWF4Q291bnRlciAhPSBudWxsICYmIHRyeUNvdW50ID49IG1heENvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRyeUZuLCBuZXh0QmFja29mZik7XG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQodHJ5Rm4sIDApO1xuICAgIH0pO1xufVxuZXhwb3J0cy5yZXBlYXRlZFRyeSA9IHJlcGVhdGVkVHJ5O1xuZnVuY3Rpb24gZ2V0UXVlcnlQYXJhbXMocXVlcnlTdHJpbmcpIHtcbiAgICB2YXIgcGFyYW1zID0ge307XG4gICAgcXVlcnlTdHJpbmcucmVwbGFjZSgvWz8mXShbXj0/Jl0rKSg/Oj0oW14mXSopKT8vZywgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHRbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlUGFyYW0ocGFyYW1zLCB0WzBdLCB0WzFdKTtcbiAgICAgICAgcmV0dXJuIHQuam9pbignPScpO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJhbXM7XG59XG5leHBvcnRzLmdldFF1ZXJ5UGFyYW1zID0gZ2V0UXVlcnlQYXJhbXM7XG5mdW5jdGlvbiBkZWNvZGVQYXJhbShwYXJhbXMsIG5hbWUsIHZhbHVlKSB7XG4gICAgcGFyYW1zW2RlY29kZVVSSUNvbXBvbmVudChuYW1lKV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUgfHwgJycpO1xufVxuZnVuY3Rpb24gaW5mZXJGcm9tSW1wbGljaXRTaGFwZShzaGFwZSwgc2l6ZSkge1xuICAgIHZhciBzaGFwZVByb2QgPSAxO1xuICAgIHZhciBpbXBsaWNpdElkeCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHNoYXBlW2ldID4gMCkge1xuICAgICAgICAgICAgc2hhcGVQcm9kICo9IHNoYXBlW2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNoYXBlW2ldID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKGltcGxpY2l0SWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2hhcGVzIGNhbiBvbmx5IGhhdmUgMSBpbXBsaWNpdCBzaXplLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIkZvdW5kIC0xIGF0IGRpbSBcIiArIGltcGxpY2l0SWR4ICsgXCIgYW5kIGRpbSBcIiArIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltcGxpY2l0SWR4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaGFwZVtpXSA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNoYXBlcyBjYW4gbm90IGJlIDw9IDAuIEZvdW5kIFwiICsgc2hhcGVbaV0gKyBcIiBhdCBkaW0gXCIgKyBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW1wbGljaXRJZHggPT09IC0xKSB7XG4gICAgICAgIGlmIChzaXplID4gMCAmJiBzaXplICE9PSBzaGFwZVByb2QpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiU2l6ZSAoXCIgKyBzaXplICsgXCIpIG11c3QgbWF0Y2ggdGhlIHByb2R1Y3Qgb2Ygc2hhcGUgXCIgKyBzaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH1cbiAgICBpZiAoc2l6ZSAlIHNoYXBlUHJvZCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBpbXBsaWNpdCBzaGFwZSBjYW4ndCBiZSBhIGZyYWN0aW9uYWwgbnVtYmVyLiBcIiArXG4gICAgICAgICAgICAoXCJHb3QgXCIgKyBzaXplICsgXCIgLyBcIiArIHNoYXBlUHJvZCkpO1xuICAgIH1cbiAgICB2YXIgbmV3U2hhcGUgPSBzaGFwZS5zbGljZSgpO1xuICAgIG5ld1NoYXBlW2ltcGxpY2l0SWR4XSA9IHNpemUgLyBzaGFwZVByb2Q7XG4gICAgcmV0dXJuIG5ld1NoYXBlO1xufVxuZXhwb3J0cy5pbmZlckZyb21JbXBsaWNpdFNoYXBlID0gaW5mZXJGcm9tSW1wbGljaXRTaGFwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/deeplearn/dist/src/util.js\n");

/***/ }),

/***/ "./node_modules/seedrandom/index.js":
/*!******************************************!*\
  !*** ./node_modules/seedrandom/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// A library of seedable RNGs implemented in Javascript.\n//\n// Usage:\n//\n// var seedrandom = require('seedrandom');\n// var random = seedrandom(1); // or any seed.\n// var x = random();       // 0 <= x < 1.  Every bit is random.\n// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.\n\n// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.\n// Period: ~2^116\n// Reported to pass all BigCrush tests.\nvar alea = __webpack_require__(/*! ./lib/alea */ \"./node_modules/seedrandom/lib/alea.js\");\n\n// xor128, a pure xor-shift generator by George Marsaglia.\n// Period: 2^128-1.\n// Reported to fail: MatrixRank and LinearComp.\nvar xor128 = __webpack_require__(/*! ./lib/xor128 */ \"./node_modules/seedrandom/lib/xor128.js\");\n\n// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.\n// Period: 2^192-2^32\n// Reported to fail: CollisionOver, SimpPoker, and LinearComp.\nvar xorwow = __webpack_require__(/*! ./lib/xorwow */ \"./node_modules/seedrandom/lib/xorwow.js\");\n\n// xorshift7, by François Panneton and Pierre L'ecuyer, takes\n// a different approach: it adds robustness by allowing more shifts\n// than Marsaglia's original three.  It is a 7-shift generator\n// with 256 bits, that passes BigCrush with no systmatic failures.\n// Period 2^256-1.\n// No systematic BigCrush failures reported.\nvar xorshift7 = __webpack_require__(/*! ./lib/xorshift7 */ \"./node_modules/seedrandom/lib/xorshift7.js\");\n\n// xor4096, by Richard Brent, is a 4096-bit xor-shift with a\n// very long period that also adds a Weyl generator. It also passes\n// BigCrush with no systematic failures.  Its long period may\n// be useful if you have many generators and need to avoid\n// collisions.\n// Period: 2^4128-2^32.\n// No systematic BigCrush failures reported.\nvar xor4096 = __webpack_require__(/*! ./lib/xor4096 */ \"./node_modules/seedrandom/lib/xor4096.js\");\n\n// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random\n// number generator derived from ChaCha, a modern stream cipher.\n// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf\n// Period: ~2^127\n// No systematic BigCrush failures reported.\nvar tychei = __webpack_require__(/*! ./lib/tychei */ \"./node_modules/seedrandom/lib/tychei.js\");\n\n// The original ARC4-based prng included in this library.\n// Period: ~2^1600\nvar sr = __webpack_require__(/*! ./seedrandom */ \"./node_modules/seedrandom/seedrandom.js\");\n\nsr.alea = alea;\nsr.xor128 = xor128;\nsr.xorwow = xorwow;\nsr.xorshift7 = xorshift7;\nsr.xor4096 = xor4096;\nsr.tychei = tychei;\n\nmodule.exports = sr;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2luZGV4LmpzPzYxMjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBsaWJyYXJ5IG9mIHNlZWRhYmxlIFJOR3MgaW1wbGVtZW50ZWQgaW4gSmF2YXNjcmlwdC5cbi8vXG4vLyBVc2FnZTpcbi8vXG4vLyB2YXIgc2VlZHJhbmRvbSA9IHJlcXVpcmUoJ3NlZWRyYW5kb20nKTtcbi8vIHZhciByYW5kb20gPSBzZWVkcmFuZG9tKDEpOyAvLyBvciBhbnkgc2VlZC5cbi8vIHZhciB4ID0gcmFuZG9tKCk7ICAgICAgIC8vIDAgPD0geCA8IDEuICBFdmVyeSBiaXQgaXMgcmFuZG9tLlxuLy8gdmFyIHggPSByYW5kb20ucXVpY2soKTsgLy8gMCA8PSB4IDwgMS4gIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cblxuLy8gYWxlYSwgYSA1My1iaXQgbXVsdGlwbHktd2l0aC1jYXJyeSBnZW5lcmF0b3IgYnkgSm9oYW5uZXMgQmFhZ8O4ZS5cbi8vIFBlcmlvZDogfjJeMTE2XG4vLyBSZXBvcnRlZCB0byBwYXNzIGFsbCBCaWdDcnVzaCB0ZXN0cy5cbnZhciBhbGVhID0gcmVxdWlyZSgnLi9saWIvYWxlYScpO1xuXG4vLyB4b3IxMjgsIGEgcHVyZSB4b3Itc2hpZnQgZ2VuZXJhdG9yIGJ5IEdlb3JnZSBNYXJzYWdsaWEuXG4vLyBQZXJpb2Q6IDJeMTI4LTEuXG4vLyBSZXBvcnRlZCB0byBmYWlsOiBNYXRyaXhSYW5rIGFuZCBMaW5lYXJDb21wLlxudmFyIHhvcjEyOCA9IHJlcXVpcmUoJy4vbGliL3hvcjEyOCcpO1xuXG4vLyB4b3J3b3csIEdlb3JnZSBNYXJzYWdsaWEncyAxNjAtYml0IHhvci1zaGlmdCBjb21iaW5lZCBwbHVzIHdleWwuXG4vLyBQZXJpb2Q6IDJeMTkyLTJeMzJcbi8vIFJlcG9ydGVkIHRvIGZhaWw6IENvbGxpc2lvbk92ZXIsIFNpbXBQb2tlciwgYW5kIExpbmVhckNvbXAuXG52YXIgeG9yd293ID0gcmVxdWlyZSgnLi9saWIveG9yd293Jyk7XG5cbi8vIHhvcnNoaWZ0NywgYnkgRnJhbsOnb2lzIFBhbm5ldG9uIGFuZCBQaWVycmUgTCdlY3V5ZXIsIHRha2VzXG4vLyBhIGRpZmZlcmVudCBhcHByb2FjaDogaXQgYWRkcyByb2J1c3RuZXNzIGJ5IGFsbG93aW5nIG1vcmUgc2hpZnRzXG4vLyB0aGFuIE1hcnNhZ2xpYSdzIG9yaWdpbmFsIHRocmVlLiAgSXQgaXMgYSA3LXNoaWZ0IGdlbmVyYXRvclxuLy8gd2l0aCAyNTYgYml0cywgdGhhdCBwYXNzZXMgQmlnQ3J1c2ggd2l0aCBubyBzeXN0bWF0aWMgZmFpbHVyZXMuXG4vLyBQZXJpb2QgMl4yNTYtMS5cbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgeG9yc2hpZnQ3ID0gcmVxdWlyZSgnLi9saWIveG9yc2hpZnQ3Jyk7XG5cbi8vIHhvcjQwOTYsIGJ5IFJpY2hhcmQgQnJlbnQsIGlzIGEgNDA5Ni1iaXQgeG9yLXNoaWZ0IHdpdGggYVxuLy8gdmVyeSBsb25nIHBlcmlvZCB0aGF0IGFsc28gYWRkcyBhIFdleWwgZ2VuZXJhdG9yLiBJdCBhbHNvIHBhc3Nlc1xuLy8gQmlnQ3J1c2ggd2l0aCBubyBzeXN0ZW1hdGljIGZhaWx1cmVzLiAgSXRzIGxvbmcgcGVyaW9kIG1heVxuLy8gYmUgdXNlZnVsIGlmIHlvdSBoYXZlIG1hbnkgZ2VuZXJhdG9ycyBhbmQgbmVlZCB0byBhdm9pZFxuLy8gY29sbGlzaW9ucy5cbi8vIFBlcmlvZDogMl40MTI4LTJeMzIuXG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHhvcjQwOTYgPSByZXF1aXJlKCcuL2xpYi94b3I0MDk2Jyk7XG5cbi8vIFR5Y2hlLWksIGJ5IFNhbXVlbCBOZXZlcyBhbmQgRmlsaXBlIEFyYXVqbywgaXMgYSBiaXQtc2hpZnRpbmcgcmFuZG9tXG4vLyBudW1iZXIgZ2VuZXJhdG9yIGRlcml2ZWQgZnJvbSBDaGFDaGEsIGEgbW9kZXJuIHN0cmVhbSBjaXBoZXIuXG4vLyBodHRwczovL2VkZW4uZGVpLnVjLnB0L35zbmV2ZXMvcHVicy8yMDExLXNuZmEyLnBkZlxuLy8gUGVyaW9kOiB+Ml4xMjdcbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgdHljaGVpID0gcmVxdWlyZSgnLi9saWIvdHljaGVpJyk7XG5cbi8vIFRoZSBvcmlnaW5hbCBBUkM0LWJhc2VkIHBybmcgaW5jbHVkZWQgaW4gdGhpcyBsaWJyYXJ5LlxuLy8gUGVyaW9kOiB+Ml4xNjAwXG52YXIgc3IgPSByZXF1aXJlKCcuL3NlZWRyYW5kb20nKTtcblxuc3IuYWxlYSA9IGFsZWE7XG5zci54b3IxMjggPSB4b3IxMjg7XG5zci54b3J3b3cgPSB4b3J3b3c7XG5zci54b3JzaGlmdDcgPSB4b3JzaGlmdDc7XG5zci54b3I0MDk2ID0geG9yNDA5NjtcbnNyLnR5Y2hlaSA9IHR5Y2hlaTtcblxubW9kdWxlLmV4cG9ydHMgPSBzcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/seedrandom/index.js\n");

/***/ }),

/***/ "./node_modules/seedrandom/lib/alea.js":
/*!*********************************************!*\
  !*** ./node_modules/seedrandom/lib/alea.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010\n// http://baagoe.com/en/RandomMusings/javascript/\n// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror\n// Original work is under MIT license -\n\n// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\n\n(function(global, module, define) {\n\nfunction Alea(seed) {\n  var me = this, mash = Mash();\n\n  me.next = function() {\n    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32\n    me.s0 = me.s1;\n    me.s1 = me.s2;\n    return me.s2 = t - (me.c = t | 0);\n  };\n\n  // Apply the seeding algorithm from Baagoe.\n  me.c = 1;\n  me.s0 = mash(' ');\n  me.s1 = mash(' ');\n  me.s2 = mash(' ');\n  me.s0 -= mash(seed);\n  if (me.s0 < 0) { me.s0 += 1; }\n  me.s1 -= mash(seed);\n  if (me.s1 < 0) { me.s1 += 1; }\n  me.s2 -= mash(seed);\n  if (me.s2 < 0) { me.s2 += 1; }\n  mash = null;\n}\n\nfunction copy(f, t) {\n  t.c = f.c;\n  t.s0 = f.s0;\n  t.s1 = f.s1;\n  t.s2 = f.s2;\n  return t;\n}\n\nfunction impl(seed, opts) {\n  var xg = new Alea(seed),\n      state = opts && opts.state,\n      prng = xg.next;\n  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }\n  prng.double = function() {\n    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53\n  };\n  prng.quick = prng;\n  if (state) {\n    if (typeof(state) == 'object') copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nfunction Mash() {\n  var n = 0xefc8249d;\n\n  var mash = function(data) {\n    data = data.toString();\n    for (var i = 0; i < data.length; i++) {\n      n += data.charCodeAt(i);\n      var h = 0.02519603282416938 * n;\n      n = h >>> 0;\n      h -= n;\n      h *= n;\n      n = h >>> 0;\n      h -= n;\n      n += h * 0x100000000; // 2^32\n    }\n    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n  };\n\n  return mash;\n}\n\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (__webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\") && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {\n  this.alea = impl;\n}\n\n})(\n  this,\n  (typeof module) == 'object' && module,    // present in node.js\n  __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\")   // present with an AMD loader\n);\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIvYWxlYS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi9hbGVhLmpzPzEyMTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBwb3J0IG9mIGFuIGFsZ29yaXRobSBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLmNvbT4sIDIwMTBcbi8vIGh0dHA6Ly9iYWFnb2UuY29tL2VuL1JhbmRvbU11c2luZ3MvamF2YXNjcmlwdC9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ucXVpbmxhbi9iZXR0ZXItcmFuZG9tLW51bWJlcnMtZm9yLWphdmFzY3JpcHQtbWlycm9yXG4vLyBPcmlnaW5hbCB3b3JrIGlzIHVuZGVyIE1JVCBsaWNlbnNlIC1cblxuLy8gQ29weXJpZ2h0IChDKSAyMDEwIGJ5IEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2Uub3JnPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vIFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy8gXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIEFsZWEoc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBtYXNoID0gTWFzaCgpO1xuXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IDIwOTE2MzkgKiBtZS5zMCArIG1lLmMgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICAgIG1lLnMwID0gbWUuczE7XG4gICAgbWUuczEgPSBtZS5zMjtcbiAgICByZXR1cm4gbWUuczIgPSB0IC0gKG1lLmMgPSB0IHwgMCk7XG4gIH07XG5cbiAgLy8gQXBwbHkgdGhlIHNlZWRpbmcgYWxnb3JpdGhtIGZyb20gQmFhZ29lLlxuICBtZS5jID0gMTtcbiAgbWUuczAgPSBtYXNoKCcgJyk7XG4gIG1lLnMxID0gbWFzaCgnICcpO1xuICBtZS5zMiA9IG1hc2goJyAnKTtcbiAgbWUuczAgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMwIDwgMCkgeyBtZS5zMCArPSAxOyB9XG4gIG1lLnMxIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMSA8IDApIHsgbWUuczEgKz0gMTsgfVxuICBtZS5zMiAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczIgPCAwKSB7IG1lLnMyICs9IDE7IH1cbiAgbWFzaCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmMgPSBmLmM7XG4gIHQuczAgPSBmLnMwO1xuICB0LnMxID0gZi5zMTtcbiAgdC5zMiA9IGYuczI7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IEFsZWEoc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSB4Zy5uZXh0O1xuICBwcm5nLmludDMyID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpICogMHgxMDAwMDAwMDApIHwgMDsgfVxuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwcm5nKCkgKyAocHJuZygpICogMHgyMDAwMDAgfCAwKSAqIDEuMTEwMjIzMDI0NjI1MTU2NWUtMTY7IC8vIDJeLTUzXG4gIH07XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5mdW5jdGlvbiBNYXNoKCkge1xuICB2YXIgbiA9IDB4ZWZjODI0OWQ7XG5cbiAgdmFyIG1hc2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGggPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgaCAqPSBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBuICs9IGggKiAweDEwMDAwMDAwMDsgLy8gMl4zMlxuICAgIH1cbiAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgfTtcblxuICByZXR1cm4gbWFzaDtcbn1cblxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLmFsZWEgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/seedrandom/lib/alea.js\n");

/***/ }),

/***/ "./node_modules/seedrandom/lib/tychei.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/tychei.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the \"Tyche-i\" prng algorithm by\n// Samuel Neves and Filipe Araujo.\n// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this, strseed = '';\n\n  // Set up generator function.\n  me.next = function() {\n    var b = me.b, c = me.c, d = me.d, a = me.a;\n    b = (b << 25) ^ (b >>> 7) ^ c;\n    c = (c - d) | 0;\n    d = (d << 24) ^ (d >>> 8) ^ a;\n    a = (a - b) | 0;\n    me.b = b = (b << 20) ^ (b >>> 12) ^ c;\n    me.c = c = (c - d) | 0;\n    me.d = (d << 16) ^ (c >>> 16) ^ a;\n    return me.a = (a - b) | 0;\n  };\n\n  /* The following is non-inverted tyche, which has better internal\n   * bit diffusion, but which is about 25% slower than tyche-i in JS.\n  me.next = function() {\n    var a = me.a, b = me.b, c = me.c, d = me.d;\n    a = (me.a + me.b | 0) >>> 0;\n    d = me.d ^ a; d = d << 16 ^ d >>> 16;\n    c = me.c + d | 0;\n    b = me.b ^ c; b = b << 12 ^ d >>> 20;\n    me.a = a = a + b | 0;\n    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;\n    me.c = c = c + d | 0;\n    b = b ^ c;\n    return me.b = (b << 7 ^ b >>> 25);\n  }\n  */\n\n  me.a = 0;\n  me.b = 0;\n  me.c = 2654435769 | 0;\n  me.d = 1367130551;\n\n  if (seed === Math.floor(seed)) {\n    // Integer seed.\n    me.a = (seed / 0x100000000) | 0;\n    me.b = seed | 0;\n  } else {\n    // String seed.\n    strseed += seed;\n  }\n\n  // Mix in string seed, then discard an initial batch of 64 values.\n  for (var k = 0; k < strseed.length + 20; k++) {\n    me.b ^= strseed.charCodeAt(k) | 0;\n    me.next();\n  }\n}\n\nfunction copy(f, t) {\n  t.a = f.a;\n  t.b = f.b;\n  t.c = f.c;\n  t.d = f.d;\n  return t;\n};\n\nfunction impl(seed, opts) {\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (typeof(state) == 'object') copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (__webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\") && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {\n  this.tychei = impl;\n}\n\n})(\n  this,\n  (typeof module) == 'object' && module,    // present in node.js\n  __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\")   // present with an AMD loader\n);\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIvdHljaGVpLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3R5Y2hlaS5qcz84OWVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcIlR5Y2hlLWlcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gU2FtdWVsIE5ldmVzIGFuZCBGaWxpcGUgQXJhdWpvLlxuLy8gU2VlIGh0dHBzOi8vZWRlbi5kZWkudWMucHQvfnNuZXZlcy9wdWJzLzIwMTEtc25mYTIucGRmXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGIgPSBtZS5iLCBjID0gbWUuYywgZCA9IG1lLmQsIGEgPSBtZS5hO1xuICAgIGIgPSAoYiA8PCAyNSkgXiAoYiA+Pj4gNykgXiBjO1xuICAgIGMgPSAoYyAtIGQpIHwgMDtcbiAgICBkID0gKGQgPDwgMjQpIF4gKGQgPj4+IDgpIF4gYTtcbiAgICBhID0gKGEgLSBiKSB8IDA7XG4gICAgbWUuYiA9IGIgPSAoYiA8PCAyMCkgXiAoYiA+Pj4gMTIpIF4gYztcbiAgICBtZS5jID0gYyA9IChjIC0gZCkgfCAwO1xuICAgIG1lLmQgPSAoZCA8PCAxNikgXiAoYyA+Pj4gMTYpIF4gYTtcbiAgICByZXR1cm4gbWUuYSA9IChhIC0gYikgfCAwO1xuICB9O1xuXG4gIC8qIFRoZSBmb2xsb3dpbmcgaXMgbm9uLWludmVydGVkIHR5Y2hlLCB3aGljaCBoYXMgYmV0dGVyIGludGVybmFsXG4gICAqIGJpdCBkaWZmdXNpb24sIGJ1dCB3aGljaCBpcyBhYm91dCAyNSUgc2xvd2VyIHRoYW4gdHljaGUtaSBpbiBKUy5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gbWUuYSwgYiA9IG1lLmIsIGMgPSBtZS5jLCBkID0gbWUuZDtcbiAgICBhID0gKG1lLmEgKyBtZS5iIHwgMCkgPj4+IDA7XG4gICAgZCA9IG1lLmQgXiBhOyBkID0gZCA8PCAxNiBeIGQgPj4+IDE2O1xuICAgIGMgPSBtZS5jICsgZCB8IDA7XG4gICAgYiA9IG1lLmIgXiBjOyBiID0gYiA8PCAxMiBeIGQgPj4+IDIwO1xuICAgIG1lLmEgPSBhID0gYSArIGIgfCAwO1xuICAgIGQgPSBkIF4gYTsgbWUuZCA9IGQgPSBkIDw8IDggXiBkID4+PiAyNDtcbiAgICBtZS5jID0gYyA9IGMgKyBkIHwgMDtcbiAgICBiID0gYiBeIGM7XG4gICAgcmV0dXJuIG1lLmIgPSAoYiA8PCA3IF4gYiA+Pj4gMjUpO1xuICB9XG4gICovXG5cbiAgbWUuYSA9IDA7XG4gIG1lLmIgPSAwO1xuICBtZS5jID0gMjY1NDQzNTc2OSB8IDA7XG4gIG1lLmQgPSAxMzY3MTMwNTUxO1xuXG4gIGlmIChzZWVkID09PSBNYXRoLmZsb29yKHNlZWQpKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLmEgPSAoc2VlZCAvIDB4MTAwMDAwMDAwKSB8IDA7XG4gICAgbWUuYiA9IHNlZWQgfCAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgMjA7IGsrKykge1xuICAgIG1lLmIgXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuYSA9IGYuYTtcbiAgdC5iID0gZi5iO1xuICB0LmMgPSBmLmM7XG4gIHQuZCA9IGYuZDtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnR5Y2hlaSA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/seedrandom/lib/tychei.js\n");

/***/ }),

/***/ "./node_modules/seedrandom/lib/xor128.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xor128.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the \"xor128\" prng algorithm by\n// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this, strseed = '';\n\n  me.x = 0;\n  me.y = 0;\n  me.z = 0;\n  me.w = 0;\n\n  // Set up generator function.\n  me.next = function() {\n    var t = me.x ^ (me.x << 11);\n    me.x = me.y;\n    me.y = me.z;\n    me.z = me.w;\n    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);\n  };\n\n  if (seed === (seed | 0)) {\n    // Integer seed.\n    me.x = seed;\n  } else {\n    // String seed.\n    strseed += seed;\n  }\n\n  // Mix in string seed, then discard an initial batch of 64 values.\n  for (var k = 0; k < strseed.length + 64; k++) {\n    me.x ^= strseed.charCodeAt(k) | 0;\n    me.next();\n  }\n}\n\nfunction copy(f, t) {\n  t.x = f.x;\n  t.y = f.y;\n  t.z = f.z;\n  t.w = f.w;\n  return t;\n}\n\nfunction impl(seed, opts) {\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (typeof(state) == 'object') copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (__webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\") && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {\n  this.xor128 = impl;\n}\n\n})(\n  this,\n  (typeof module) == 'object' && module,    // present in node.js\n  __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\")   // present with an AMD loader\n);\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yMTI4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcjEyOC5qcz9iODM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcjEyOFwiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBHZW9yZ2UgTWFyc2FnbGlhLiAgU2VlIGh0dHA6Ly93d3cuanN0YXRzb2Z0Lm9yZy92MDgvaTE0L3BhcGVyXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICBtZS54ID0gMDtcbiAgbWUueSA9IDA7XG4gIG1lLnogPSAwO1xuICBtZS53ID0gMDtcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSBtZS54IF4gKG1lLnggPDwgMTEpO1xuICAgIG1lLnggPSBtZS55O1xuICAgIG1lLnkgPSBtZS56O1xuICAgIG1lLnogPSBtZS53O1xuICAgIHJldHVybiBtZS53IF49IChtZS53ID4+PiAxOSkgXiB0IF4gKHQgPj4+IDgpO1xuICB9O1xuXG4gIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLnggPSBzZWVkO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgNjQ7IGsrKykge1xuICAgIG1lLnggXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueDtcbiAgdC55ID0gZi55O1xuICB0LnogPSBmLno7XG4gIHQudyA9IGYudztcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yMTI4ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/seedrandom/lib/xor128.js\n");

/***/ }),

/***/ "./node_modules/seedrandom/lib/xor4096.js":
/*!************************************************!*\
  !*** ./node_modules/seedrandom/lib/xor4096.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.\n//\n// This fast non-cryptographic random number generator is designed for\n// use in Monte-Carlo algorithms. It combines a long-period xorshift\n// generator with a Weyl generator, and it passes all common batteries\n// of stasticial tests for randomness while consuming only a few nanoseconds\n// for each prng generated.  For background on the generator, see Brent's\n// paper: \"Some long-period random number generators using shifts and xors.\"\n// http://arxiv.org/pdf/1004.3115v1.pdf\n//\n// Usage:\n//\n// var xor4096 = require('xor4096');\n// random = xor4096(1);                        // Seed with int32 or string.\n// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.\n// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.\n//\n// For nonzero numeric keys, this impelementation provides a sequence\n// identical to that by Brent's xorgens 3 implementaion in C.  This\n// implementation also provides for initalizing the generator with\n// string seeds, or for saving and restoring the state of the generator.\n//\n// On Chrome, this prng benchmarks about 2.1 times slower than\n// Javascript's built-in Math.random().\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this;\n\n  // Set up generator function.\n  me.next = function() {\n    var w = me.w,\n        X = me.X, i = me.i, t, v;\n    // Update Weyl generator.\n    me.w = w = (w + 0x61c88647) | 0;\n    // Update xor generator.\n    v = X[(i + 34) & 127];\n    t = X[i = ((i + 1) & 127)];\n    v ^= v << 13;\n    t ^= t << 17;\n    v ^= v >>> 15;\n    t ^= t >>> 12;\n    // Update Xor generator array state.\n    v = X[i] = v ^ t;\n    me.i = i;\n    // Result is the combination.\n    return (v + (w ^ (w >>> 16))) | 0;\n  };\n\n  function init(me, seed) {\n    var t, v, i, j, w, X = [], limit = 128;\n    if (seed === (seed | 0)) {\n      // Numeric seeds initialize v, which is used to generates X.\n      v = seed;\n      seed = null;\n    } else {\n      // String seeds are mixed into v and X one character at a time.\n      seed = seed + '\\0';\n      v = 0;\n      limit = Math.max(limit, seed.length);\n    }\n    // Initialize circular array and weyl value.\n    for (i = 0, j = -32; j < limit; ++j) {\n      // Put the unicode characters into the array, and shuffle them.\n      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);\n      // After 32 shuffles, take v as the starting w value.\n      if (j === 0) w = v;\n      v ^= v << 10;\n      v ^= v >>> 15;\n      v ^= v << 4;\n      v ^= v >>> 13;\n      if (j >= 0) {\n        w = (w + 0x61c88647) | 0;     // Weyl.\n        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.\n        i = (0 == t) ? i + 1 : 0;     // Count zeroes.\n      }\n    }\n    // We have detected all zeroes; make the key nonzero.\n    if (i >= 128) {\n      X[(seed && seed.length || 0) & 127] = -1;\n    }\n    // Run the generator 512 times to further mix the state before using it.\n    // Factoring this as a function slows the main generator, so it is just\n    // unrolled here.  The weyl generator is not advanced while warming up.\n    i = 127;\n    for (j = 4 * 128; j > 0; --j) {\n      v = X[(i + 34) & 127];\n      t = X[i = ((i + 1) & 127)];\n      v ^= v << 13;\n      t ^= t << 17;\n      v ^= v >>> 15;\n      t ^= t >>> 12;\n      X[i] = v ^ t;\n    }\n    // Storing state as object members is faster than using closure variables.\n    me.w = w;\n    me.X = X;\n    me.i = i;\n  }\n\n  init(me, seed);\n}\n\nfunction copy(f, t) {\n  t.i = f.i;\n  t.w = f.w;\n  t.X = f.X.slice();\n  return t;\n};\n\nfunction impl(seed, opts) {\n  if (seed == null) seed = +(new Date);\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (state.X) copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (__webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\") && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {\n  this.xor4096 = impl;\n}\n\n})(\n  this,                                     // window object or global\n  (typeof module) == 'object' && module,    // present in node.js\n  __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\")   // present with an AMD loader\n);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yNDA5Ni5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3I0MDk2LmpzPzdhZWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgUmljaGFyZCBCcmVudCdzIFhvcmdlbnMgeG9yNDA5NiBhbGdvcml0aG0uXG4vL1xuLy8gVGhpcyBmYXN0IG5vbi1jcnlwdG9ncmFwaGljIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGlzIGRlc2lnbmVkIGZvclxuLy8gdXNlIGluIE1vbnRlLUNhcmxvIGFsZ29yaXRobXMuIEl0IGNvbWJpbmVzIGEgbG9uZy1wZXJpb2QgeG9yc2hpZnRcbi8vIGdlbmVyYXRvciB3aXRoIGEgV2V5bCBnZW5lcmF0b3IsIGFuZCBpdCBwYXNzZXMgYWxsIGNvbW1vbiBiYXR0ZXJpZXNcbi8vIG9mIHN0YXN0aWNpYWwgdGVzdHMgZm9yIHJhbmRvbW5lc3Mgd2hpbGUgY29uc3VtaW5nIG9ubHkgYSBmZXcgbmFub3NlY29uZHNcbi8vIGZvciBlYWNoIHBybmcgZ2VuZXJhdGVkLiAgRm9yIGJhY2tncm91bmQgb24gdGhlIGdlbmVyYXRvciwgc2VlIEJyZW50J3Ncbi8vIHBhcGVyOiBcIlNvbWUgbG9uZy1wZXJpb2QgcmFuZG9tIG51bWJlciBnZW5lcmF0b3JzIHVzaW5nIHNoaWZ0cyBhbmQgeG9ycy5cIlxuLy8gaHR0cDovL2FyeGl2Lm9yZy9wZGYvMTAwNC4zMTE1djEucGRmXG4vL1xuLy8gVXNhZ2U6XG4vL1xuLy8gdmFyIHhvcjQwOTYgPSByZXF1aXJlKCd4b3I0MDk2Jyk7XG4vLyByYW5kb20gPSB4b3I0MDk2KDEpOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZWQgd2l0aCBpbnQzMiBvciBzdHJpbmcuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tKCksIDAuMTUyMDQzNjQ1MDUzODU0Nyk7IC8vICgwLCAxKSByYW5nZSwgNTMgYml0cy5cbi8vIGFzc2VydC5lcXVhbChyYW5kb20uaW50MzIoKSwgMTgwNjUzNDg5Nyk7ICAgLy8gc2lnbmVkIGludDMyLCAzMiBiaXRzLlxuLy9cbi8vIEZvciBub256ZXJvIG51bWVyaWMga2V5cywgdGhpcyBpbXBlbGVtZW50YXRpb24gcHJvdmlkZXMgYSBzZXF1ZW5jZVxuLy8gaWRlbnRpY2FsIHRvIHRoYXQgYnkgQnJlbnQncyB4b3JnZW5zIDMgaW1wbGVtZW50YWlvbiBpbiBDLiAgVGhpc1xuLy8gaW1wbGVtZW50YXRpb24gYWxzbyBwcm92aWRlcyBmb3IgaW5pdGFsaXppbmcgdGhlIGdlbmVyYXRvciB3aXRoXG4vLyBzdHJpbmcgc2VlZHMsIG9yIGZvciBzYXZpbmcgYW5kIHJlc3RvcmluZyB0aGUgc3RhdGUgb2YgdGhlIGdlbmVyYXRvci5cbi8vXG4vLyBPbiBDaHJvbWUsIHRoaXMgcHJuZyBiZW5jaG1hcmtzIGFib3V0IDIuMSB0aW1lcyBzbG93ZXIgdGhhblxuLy8gSmF2YXNjcmlwdCdzIGJ1aWx0LWluIE1hdGgucmFuZG9tKCkuXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3ID0gbWUudyxcbiAgICAgICAgWCA9IG1lLlgsIGkgPSBtZS5pLCB0LCB2O1xuICAgIC8vIFVwZGF0ZSBXZXlsIGdlbmVyYXRvci5cbiAgICBtZS53ID0gdyA9ICh3ICsgMHg2MWM4ODY0NykgfCAwO1xuICAgIC8vIFVwZGF0ZSB4b3IgZ2VuZXJhdG9yLlxuICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICB0ID0gWFtpID0gKChpICsgMSkgJiAxMjcpXTtcbiAgICB2IF49IHYgPDwgMTM7XG4gICAgdCBePSB0IDw8IDE3O1xuICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgdCBePSB0ID4+PiAxMjtcbiAgICAvLyBVcGRhdGUgWG9yIGdlbmVyYXRvciBhcnJheSBzdGF0ZS5cbiAgICB2ID0gWFtpXSA9IHYgXiB0O1xuICAgIG1lLmkgPSBpO1xuICAgIC8vIFJlc3VsdCBpcyB0aGUgY29tYmluYXRpb24uXG4gICAgcmV0dXJuICh2ICsgKHcgXiAodyA+Pj4gMTYpKSkgfCAwO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGluaXQobWUsIHNlZWQpIHtcbiAgICB2YXIgdCwgdiwgaSwgaiwgdywgWCA9IFtdLCBsaW1pdCA9IDEyODtcbiAgICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgICAgLy8gTnVtZXJpYyBzZWVkcyBpbml0aWFsaXplIHYsIHdoaWNoIGlzIHVzZWQgdG8gZ2VuZXJhdGVzIFguXG4gICAgICB2ID0gc2VlZDtcbiAgICAgIHNlZWQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdHJpbmcgc2VlZHMgYXJlIG1peGVkIGludG8gdiBhbmQgWCBvbmUgY2hhcmFjdGVyIGF0IGEgdGltZS5cbiAgICAgIHNlZWQgPSBzZWVkICsgJ1xcMCc7XG4gICAgICB2ID0gMDtcbiAgICAgIGxpbWl0ID0gTWF0aC5tYXgobGltaXQsIHNlZWQubGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gSW5pdGlhbGl6ZSBjaXJjdWxhciBhcnJheSBhbmQgd2V5bCB2YWx1ZS5cbiAgICBmb3IgKGkgPSAwLCBqID0gLTMyOyBqIDwgbGltaXQ7ICsraikge1xuICAgICAgLy8gUHV0IHRoZSB1bmljb2RlIGNoYXJhY3RlcnMgaW50byB0aGUgYXJyYXksIGFuZCBzaHVmZmxlIHRoZW0uXG4gICAgICBpZiAoc2VlZCkgdiBePSBzZWVkLmNoYXJDb2RlQXQoKGogKyAzMikgJSBzZWVkLmxlbmd0aCk7XG4gICAgICAvLyBBZnRlciAzMiBzaHVmZmxlcywgdGFrZSB2IGFzIHRoZSBzdGFydGluZyB3IHZhbHVlLlxuICAgICAgaWYgKGogPT09IDApIHcgPSB2O1xuICAgICAgdiBePSB2IDw8IDEwO1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHYgXj0gdiA8PCA0O1xuICAgICAgdiBePSB2ID4+PiAxMztcbiAgICAgIGlmIChqID49IDApIHtcbiAgICAgICAgdyA9ICh3ICsgMHg2MWM4ODY0NykgfCAwOyAgICAgLy8gV2V5bC5cbiAgICAgICAgdCA9IChYW2ogJiAxMjddIF49ICh2ICsgdykpOyAgLy8gQ29tYmluZSB4b3IgYW5kIHdleWwgdG8gaW5pdCBhcnJheS5cbiAgICAgICAgaSA9ICgwID09IHQpID8gaSArIDEgOiAwOyAgICAgLy8gQ291bnQgemVyb2VzLlxuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBoYXZlIGRldGVjdGVkIGFsbCB6ZXJvZXM7IG1ha2UgdGhlIGtleSBub256ZXJvLlxuICAgIGlmIChpID49IDEyOCkge1xuICAgICAgWFsoc2VlZCAmJiBzZWVkLmxlbmd0aCB8fCAwKSAmIDEyN10gPSAtMTtcbiAgICB9XG4gICAgLy8gUnVuIHRoZSBnZW5lcmF0b3IgNTEyIHRpbWVzIHRvIGZ1cnRoZXIgbWl4IHRoZSBzdGF0ZSBiZWZvcmUgdXNpbmcgaXQuXG4gICAgLy8gRmFjdG9yaW5nIHRoaXMgYXMgYSBmdW5jdGlvbiBzbG93cyB0aGUgbWFpbiBnZW5lcmF0b3IsIHNvIGl0IGlzIGp1c3RcbiAgICAvLyB1bnJvbGxlZCBoZXJlLiAgVGhlIHdleWwgZ2VuZXJhdG9yIGlzIG5vdCBhZHZhbmNlZCB3aGlsZSB3YXJtaW5nIHVwLlxuICAgIGkgPSAxMjc7XG4gICAgZm9yIChqID0gNCAqIDEyODsgaiA+IDA7IC0taikge1xuICAgICAgdiA9IFhbKGkgKyAzNCkgJiAxMjddO1xuICAgICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgICB2IF49IHYgPDwgMTM7XG4gICAgICB0IF49IHQgPDwgMTc7XG4gICAgICB2IF49IHYgPj4+IDE1O1xuICAgICAgdCBePSB0ID4+PiAxMjtcbiAgICAgIFhbaV0gPSB2IF4gdDtcbiAgICB9XG4gICAgLy8gU3RvcmluZyBzdGF0ZSBhcyBvYmplY3QgbWVtYmVycyBpcyBmYXN0ZXIgdGhhbiB1c2luZyBjbG9zdXJlIHZhcmlhYmxlcy5cbiAgICBtZS53ID0gdztcbiAgICBtZS5YID0gWDtcbiAgICBtZS5pID0gaTtcbiAgfVxuXG4gIGluaXQobWUsIHNlZWQpO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5pID0gZi5pO1xuICB0LncgPSBmLnc7XG4gIHQuWCA9IGYuWC5zbGljZSgpO1xuICByZXR1cm4gdDtcbn07XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICBpZiAoc2VlZCA9PSBudWxsKSBzZWVkID0gKyhuZXcgRGF0ZSk7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLlgpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3I0MDk2ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbmRvdyBvYmplY3Qgb3IgZ2xvYmFsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/seedrandom/lib/xor4096.js\n");

/***/ }),

/***/ "./node_modules/seedrandom/lib/xorshift7.js":
/*!**************************************************!*\
  !*** ./node_modules/seedrandom/lib/xorshift7.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the \"xorshift7\" algorithm by\n// François Panneton and Pierre L'ecuyer:\n// \"On the Xorgshift Random Number Generators\"\n// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this;\n\n  // Set up generator function.\n  me.next = function() {\n    // Update xor generator.\n    var X = me.x, i = me.i, t, v, w;\n    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);\n    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);\n    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);\n    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);\n    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);\n    X[i] = v;\n    me.i = (i + 1) & 7;\n    return v;\n  };\n\n  function init(me, seed) {\n    var j, w, X = [];\n\n    if (seed === (seed | 0)) {\n      // Seed state array using a 32-bit integer.\n      w = X[0] = seed;\n    } else {\n      // Seed state using a string.\n      seed = '' + seed;\n      for (j = 0; j < seed.length; ++j) {\n        X[j & 7] = (X[j & 7] << 15) ^\n            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);\n      }\n    }\n    // Enforce an array length of 8, not all zeroes.\n    while (X.length < 8) X.push(0);\n    for (j = 0; j < 8 && X[j] === 0; ++j);\n    if (j == 8) w = X[7] = -1; else w = X[j];\n\n    me.x = X;\n    me.i = 0;\n\n    // Discard an initial 256 values.\n    for (j = 256; j > 0; --j) {\n      me.next();\n    }\n  }\n\n  init(me, seed);\n}\n\nfunction copy(f, t) {\n  t.x = f.x.slice();\n  t.i = f.i;\n  return t;\n}\n\nfunction impl(seed, opts) {\n  if (seed == null) seed = +(new Date);\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (state.x) copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (__webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\") && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {\n  this.xorshift7 = impl;\n}\n\n})(\n  this,\n  (typeof module) == 'object' && module,    // present in node.js\n  __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\")   // present with an AMD loader\n);\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yc2hpZnQ3LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcnNoaWZ0Ny5qcz9jYWUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcnNoaWZ0N1wiIGFsZ29yaXRobSBieVxuLy8gRnJhbsOnb2lzIFBhbm5ldG9uIGFuZCBQaWVycmUgTCdlY3V5ZXI6XG4vLyBcIk9uIHRoZSBYb3Jnc2hpZnQgUmFuZG9tIE51bWJlciBHZW5lcmF0b3JzXCJcbi8vIGh0dHA6Ly9zYWx1Yy5lbmdyLnVjb25uLmVkdS9yZWZzL2NyeXB0by9ybmcvcGFubmV0b24wNW9udGhleG9yc2hpZnQucGRmXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFVwZGF0ZSB4b3IgZ2VuZXJhdG9yLlxuICAgIHZhciBYID0gbWUueCwgaSA9IG1lLmksIHQsIHYsIHc7XG4gICAgdCA9IFhbaV07IHQgXj0gKHQgPj4+IDcpOyB2ID0gdCBeICh0IDw8IDI0KTtcbiAgICB0ID0gWFsoaSArIDEpICYgN107IHYgXj0gdCBeICh0ID4+PiAxMCk7XG4gICAgdCA9IFhbKGkgKyAzKSAmIDddOyB2IF49IHQgXiAodCA+Pj4gMyk7XG4gICAgdCA9IFhbKGkgKyA0KSAmIDddOyB2IF49IHQgXiAodCA8PCA3KTtcbiAgICB0ID0gWFsoaSArIDcpICYgN107IHQgPSB0IF4gKHQgPDwgMTMpOyB2IF49IHQgXiAodCA8PCA5KTtcbiAgICBYW2ldID0gdjtcbiAgICBtZS5pID0gKGkgKyAxKSAmIDc7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5pdChtZSwgc2VlZCkge1xuICAgIHZhciBqLCB3LCBYID0gW107XG5cbiAgICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgICAgLy8gU2VlZCBzdGF0ZSBhcnJheSB1c2luZyBhIDMyLWJpdCBpbnRlZ2VyLlxuICAgICAgdyA9IFhbMF0gPSBzZWVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZWVkIHN0YXRlIHVzaW5nIGEgc3RyaW5nLlxuICAgICAgc2VlZCA9ICcnICsgc2VlZDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzZWVkLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIFhbaiAmIDddID0gKFhbaiAmIDddIDw8IDE1KSBeXG4gICAgICAgICAgICAoc2VlZC5jaGFyQ29kZUF0KGopICsgWFsoaiArIDEpICYgN10gPDwgMTMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBFbmZvcmNlIGFuIGFycmF5IGxlbmd0aCBvZiA4LCBub3QgYWxsIHplcm9lcy5cbiAgICB3aGlsZSAoWC5sZW5ndGggPCA4KSBYLnB1c2goMCk7XG4gICAgZm9yIChqID0gMDsgaiA8IDggJiYgWFtqXSA9PT0gMDsgKytqKTtcbiAgICBpZiAoaiA9PSA4KSB3ID0gWFs3XSA9IC0xOyBlbHNlIHcgPSBYW2pdO1xuXG4gICAgbWUueCA9IFg7XG4gICAgbWUuaSA9IDA7XG5cbiAgICAvLyBEaXNjYXJkIGFuIGluaXRpYWwgMjU2IHZhbHVlcy5cbiAgICBmb3IgKGogPSAyNTY7IGogPiAwOyAtLWopIHtcbiAgICAgIG1lLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICBpbml0KG1lLCBzZWVkKTtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQueCA9IGYueC5zbGljZSgpO1xuICB0LmkgPSBmLmk7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgaWYgKHNlZWQgPT0gbnVsbCkgc2VlZCA9ICsobmV3IERhdGUpO1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS54KSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yc2hpZnQ3ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/seedrandom/lib/xorshift7.js\n");

/***/ }),

/***/ "./node_modules/seedrandom/lib/xorwow.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xorwow.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the \"xorwow\" prng algorithm by\n// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this, strseed = '';\n\n  // Set up generator function.\n  me.next = function() {\n    var t = (me.x ^ (me.x >>> 2));\n    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;\n    return (me.d = (me.d + 362437 | 0)) +\n       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;\n  };\n\n  me.x = 0;\n  me.y = 0;\n  me.z = 0;\n  me.w = 0;\n  me.v = 0;\n\n  if (seed === (seed | 0)) {\n    // Integer seed.\n    me.x = seed;\n  } else {\n    // String seed.\n    strseed += seed;\n  }\n\n  // Mix in string seed, then discard an initial batch of 64 values.\n  for (var k = 0; k < strseed.length + 64; k++) {\n    me.x ^= strseed.charCodeAt(k) | 0;\n    if (k == strseed.length) {\n      me.d = me.x << 10 ^ me.x >>> 4;\n    }\n    me.next();\n  }\n}\n\nfunction copy(f, t) {\n  t.x = f.x;\n  t.y = f.y;\n  t.z = f.z;\n  t.w = f.w;\n  t.v = f.v;\n  t.d = f.d;\n  return t;\n}\n\nfunction impl(seed, opts) {\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (typeof(state) == 'object') copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (__webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\") && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {\n  this.xorwow = impl;\n}\n\n})(\n  this,\n  (typeof module) == 'object' && module,    // present in node.js\n  __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\")   // present with an AMD loader\n);\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yd293LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcndvdy5qcz9hNDllIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcndvd1wiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBHZW9yZ2UgTWFyc2FnbGlhLiAgU2VlIGh0dHA6Ly93d3cuanN0YXRzb2Z0Lm9yZy92MDgvaTE0L3BhcGVyXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSAobWUueCBeIChtZS54ID4+PiAyKSk7XG4gICAgbWUueCA9IG1lLnk7IG1lLnkgPSBtZS56OyBtZS56ID0gbWUudzsgbWUudyA9IG1lLnY7XG4gICAgcmV0dXJuIChtZS5kID0gKG1lLmQgKyAzNjI0MzcgfCAwKSkgK1xuICAgICAgIChtZS52ID0gKG1lLnYgXiAobWUudiA8PCA0KSkgXiAodCBeICh0IDw8IDEpKSkgfCAwO1xuICB9O1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuICBtZS52ID0gMDtcblxuICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS54ID0gc2VlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDY0OyBrKyspIHtcbiAgICBtZS54IF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgaWYgKGsgPT0gc3Ryc2VlZC5sZW5ndGgpIHtcbiAgICAgIG1lLmQgPSBtZS54IDw8IDEwIF4gbWUueCA+Pj4gNDtcbiAgICB9XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLng7XG4gIHQueSA9IGYueTtcbiAgdC56ID0gZi56O1xuICB0LncgPSBmLnc7XG4gIHQudiA9IGYudjtcbiAgdC5kID0gZi5kO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3J3b3cgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/seedrandom/lib/xorwow.js\n");

/***/ }),

/***/ "./node_modules/seedrandom/seedrandom.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/seedrandom.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*\nCopyright 2014 David Bau.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n(function (pool, math) {\n//\n// The following constants are related to IEEE 754 limits.\n//\nvar global = this,\n    width = 256,        // each RC4 output is 0 <= x < 256\n    chunks = 6,         // at least six RC4 outputs for each double\n    digits = 52,        // there are 52 significant digits in a double\n    rngname = 'random', // rngname: name for Math.random and Math.seedrandom\n    startdenom = math.pow(width, chunks),\n    significance = math.pow(2, digits),\n    overflow = significance * 2,\n    mask = width - 1,\n    nodecrypto;         // node.js crypto module, initialized at the bottom.\n\n//\n// seedrandom()\n// This is the seedrandom function described above.\n//\nfunction seedrandom(seed, options, callback) {\n  var key = [];\n  options = (options == true) ? { entropy: true } : (options || {});\n\n  // Flatten the seed string or build one from local entropy if needed.\n  var shortseed = mixkey(flatten(\n    options.entropy ? [seed, tostring(pool)] :\n    (seed == null) ? autoseed() : seed, 3), key);\n\n  // Use the seed to initialize an ARC4 generator.\n  var arc4 = new ARC4(key);\n\n  // This function returns a random double in [0, 1) that contains\n  // randomness in every bit of the mantissa of the IEEE 754 value.\n  var prng = function() {\n    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48\n        d = startdenom,                 //   and denominator d = 2 ^ 48.\n        x = 0;                          //   and no 'extra last byte'.\n    while (n < significance) {          // Fill up all significant digits by\n      n = (n + x) * width;              //   shifting numerator and\n      d *= width;                       //   denominator and generating a\n      x = arc4.g(1);                    //   new least-significant-byte.\n    }\n    while (n >= overflow) {             // To avoid rounding up, before adding\n      n /= 2;                           //   last byte, shift everything\n      d /= 2;                           //   right using integer math until\n      x >>>= 1;                         //   we have exactly the desired bits.\n    }\n    return (n + x) / d;                 // Form the number within [0, 1).\n  };\n\n  prng.int32 = function() { return arc4.g(4) | 0; }\n  prng.quick = function() { return arc4.g(4) / 0x100000000; }\n  prng.double = prng;\n\n  // Mix the randomness into accumulated entropy.\n  mixkey(tostring(arc4.S), pool);\n\n  // Calling convention: what to return as a function of prng, seed, is_math.\n  return (options.pass || callback ||\n      function(prng, seed, is_math_call, state) {\n        if (state) {\n          // Load the arc4 state from the given state if it has an S array.\n          if (state.S) { copy(state, arc4); }\n          // Only provide the .state method if requested via options.state.\n          prng.state = function() { return copy(arc4, {}); }\n        }\n\n        // If called as a method of Math (Math.seedrandom()), mutate\n        // Math.random because that is how seedrandom.js has worked since v1.0.\n        if (is_math_call) { math[rngname] = prng; return seed; }\n\n        // Otherwise, it is a newer calling convention, so return the\n        // prng directly.\n        else return prng;\n      })(\n  prng,\n  shortseed,\n  'global' in options ? options.global : (this == math),\n  options.state);\n}\nmath['seed' + rngname] = seedrandom;\n\n//\n// ARC4\n//\n// An ARC4 implementation.  The constructor takes a key in the form of\n// an array of at most (width) integers that should be 0 <= x < (width).\n//\n// The g(count) method returns a pseudorandom integer that concatenates\n// the next (count) outputs from ARC4.  Its return value is a number x\n// that is in the range 0 <= x < (width ^ count).\n//\nfunction ARC4(key) {\n  var t, keylen = key.length,\n      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];\n\n  // The empty key [] is treated as [0].\n  if (!keylen) { key = [keylen++]; }\n\n  // Set up S using the standard key scheduling algorithm.\n  while (i < width) {\n    s[i] = i++;\n  }\n  for (i = 0; i < width; i++) {\n    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];\n    s[j] = t;\n  }\n\n  // The \"g\" method returns the next (count) outputs as one number.\n  (me.g = function(count) {\n    // Using instance members instead of closure state nearly doubles speed.\n    var t, r = 0,\n        i = me.i, j = me.j, s = me.S;\n    while (count--) {\n      t = s[i = mask & (i + 1)];\n      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];\n    }\n    me.i = i; me.j = j;\n    return r;\n    // For robust unpredictability, the function call below automatically\n    // discards an initial batch of values.  This is called RC4-drop[256].\n    // See http://google.com/search?q=rsa+fluhrer+response&btnI\n  })(width);\n}\n\n//\n// copy()\n// Copies internal state of ARC4 to or from a plain object.\n//\nfunction copy(f, t) {\n  t.i = f.i;\n  t.j = f.j;\n  t.S = f.S.slice();\n  return t;\n};\n\n//\n// flatten()\n// Converts an object tree to nested arrays of strings.\n//\nfunction flatten(obj, depth) {\n  var result = [], typ = (typeof obj), prop;\n  if (depth && typ == 'object') {\n    for (prop in obj) {\n      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}\n    }\n  }\n  return (result.length ? result : typ == 'string' ? obj : obj + '\\0');\n}\n\n//\n// mixkey()\n// Mixes a string seed into a key that is an array of integers, and\n// returns a shortened string seed that is equivalent to the result key.\n//\nfunction mixkey(seed, key) {\n  var stringseed = seed + '', smear, j = 0;\n  while (j < stringseed.length) {\n    key[mask & j] =\n      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));\n  }\n  return tostring(key);\n}\n\n//\n// autoseed()\n// Returns an object for autoseeding, using window.crypto and Node crypto\n// module if available.\n//\nfunction autoseed() {\n  try {\n    var out;\n    if (nodecrypto && (out = nodecrypto.randomBytes)) {\n      // The use of 'out' to remember randomBytes makes tight minified code.\n      out = out(width);\n    } else {\n      out = new Uint8Array(width);\n      (global.crypto || global.msCrypto).getRandomValues(out);\n    }\n    return tostring(out);\n  } catch (e) {\n    var browser = global.navigator,\n        plugins = browser && browser.plugins;\n    return [+new Date, global, plugins, global.screen, tostring(pool)];\n  }\n}\n\n//\n// tostring()\n// Converts an array of charcodes to a string\n//\nfunction tostring(a) {\n  return String.fromCharCode.apply(0, a);\n}\n\n//\n// When seedrandom.js is loaded, we immediately mix a few bits\n// from the built-in RNG into the entropy pool.  Because we do\n// not want to interfere with deterministic PRNG state later,\n// seedrandom will not call math.random on its own again after\n// initialization.\n//\nmixkey(math.random(), pool);\n\n//\n// Nodejs and AMD support: export the implementation as a module using\n// either convention.\n//\nif ((typeof module) == 'object' && module.exports) {\n  module.exports = seedrandom;\n  // When in node.js, try using crypto package for autoseeding.\n  try {\n    nodecrypto = __webpack_require__(/*! crypto */ 0);\n  } catch (ex) {}\n} else if (true) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return seedrandom; }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n// End anonymous scope, and pass initial values.\n})(\n  [],     // pool: entropy pool starts empty\n  Math    // math: package containing random, pow, and seedrandom\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9zZWVkcmFuZG9tLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vc2VlZHJhbmRvbS5qcz9hNDlkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxNCBEYXZpZCBCYXUuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxuSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbkNMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG5UT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxuU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiovXG5cbihmdW5jdGlvbiAocG9vbCwgbWF0aCkge1xuLy9cbi8vIFRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSByZWxhdGVkIHRvIElFRUUgNzU0IGxpbWl0cy5cbi8vXG52YXIgZ2xvYmFsID0gdGhpcyxcbiAgICB3aWR0aCA9IDI1NiwgICAgICAgIC8vIGVhY2ggUkM0IG91dHB1dCBpcyAwIDw9IHggPCAyNTZcbiAgICBjaHVua3MgPSA2LCAgICAgICAgIC8vIGF0IGxlYXN0IHNpeCBSQzQgb3V0cHV0cyBmb3IgZWFjaCBkb3VibGVcbiAgICBkaWdpdHMgPSA1MiwgICAgICAgIC8vIHRoZXJlIGFyZSA1MiBzaWduaWZpY2FudCBkaWdpdHMgaW4gYSBkb3VibGVcbiAgICBybmduYW1lID0gJ3JhbmRvbScsIC8vIHJuZ25hbWU6IG5hbWUgZm9yIE1hdGgucmFuZG9tIGFuZCBNYXRoLnNlZWRyYW5kb21cbiAgICBzdGFydGRlbm9tID0gbWF0aC5wb3cod2lkdGgsIGNodW5rcyksXG4gICAgc2lnbmlmaWNhbmNlID0gbWF0aC5wb3coMiwgZGlnaXRzKSxcbiAgICBvdmVyZmxvdyA9IHNpZ25pZmljYW5jZSAqIDIsXG4gICAgbWFzayA9IHdpZHRoIC0gMSxcbiAgICBub2RlY3J5cHRvOyAgICAgICAgIC8vIG5vZGUuanMgY3J5cHRvIG1vZHVsZSwgaW5pdGlhbGl6ZWQgYXQgdGhlIGJvdHRvbS5cblxuLy9cbi8vIHNlZWRyYW5kb20oKVxuLy8gVGhpcyBpcyB0aGUgc2VlZHJhbmRvbSBmdW5jdGlvbiBkZXNjcmliZWQgYWJvdmUuXG4vL1xuZnVuY3Rpb24gc2VlZHJhbmRvbShzZWVkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIga2V5ID0gW107XG4gIG9wdGlvbnMgPSAob3B0aW9ucyA9PSB0cnVlKSA/IHsgZW50cm9weTogdHJ1ZSB9IDogKG9wdGlvbnMgfHwge30pO1xuXG4gIC8vIEZsYXR0ZW4gdGhlIHNlZWQgc3RyaW5nIG9yIGJ1aWxkIG9uZSBmcm9tIGxvY2FsIGVudHJvcHkgaWYgbmVlZGVkLlxuICB2YXIgc2hvcnRzZWVkID0gbWl4a2V5KGZsYXR0ZW4oXG4gICAgb3B0aW9ucy5lbnRyb3B5ID8gW3NlZWQsIHRvc3RyaW5nKHBvb2wpXSA6XG4gICAgKHNlZWQgPT0gbnVsbCkgPyBhdXRvc2VlZCgpIDogc2VlZCwgMyksIGtleSk7XG5cbiAgLy8gVXNlIHRoZSBzZWVkIHRvIGluaXRpYWxpemUgYW4gQVJDNCBnZW5lcmF0b3IuXG4gIHZhciBhcmM0ID0gbmV3IEFSQzQoa2V5KTtcblxuICAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSByYW5kb20gZG91YmxlIGluIFswLCAxKSB0aGF0IGNvbnRhaW5zXG4gIC8vIHJhbmRvbW5lc3MgaW4gZXZlcnkgYml0IG9mIHRoZSBtYW50aXNzYSBvZiB0aGUgSUVFRSA3NTQgdmFsdWUuXG4gIHZhciBwcm5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSBhcmM0LmcoY2h1bmtzKSwgICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG51bWVyYXRvciBuIDwgMiBeIDQ4XG4gICAgICAgIGQgPSBzdGFydGRlbm9tLCAgICAgICAgICAgICAgICAgLy8gICBhbmQgZGVub21pbmF0b3IgZCA9IDIgXiA0OC5cbiAgICAgICAgeCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGFuZCBubyAnZXh0cmEgbGFzdCBieXRlJy5cbiAgICB3aGlsZSAobiA8IHNpZ25pZmljYW5jZSkgeyAgICAgICAgICAvLyBGaWxsIHVwIGFsbCBzaWduaWZpY2FudCBkaWdpdHMgYnlcbiAgICAgIG4gPSAobiArIHgpICogd2lkdGg7ICAgICAgICAgICAgICAvLyAgIHNoaWZ0aW5nIG51bWVyYXRvciBhbmRcbiAgICAgIGQgKj0gd2lkdGg7ICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGRlbm9taW5hdG9yIGFuZCBnZW5lcmF0aW5nIGFcbiAgICAgIHggPSBhcmM0LmcoMSk7ICAgICAgICAgICAgICAgICAgICAvLyAgIG5ldyBsZWFzdC1zaWduaWZpY2FudC1ieXRlLlxuICAgIH1cbiAgICB3aGlsZSAobiA+PSBvdmVyZmxvdykgeyAgICAgICAgICAgICAvLyBUbyBhdm9pZCByb3VuZGluZyB1cCwgYmVmb3JlIGFkZGluZ1xuICAgICAgbiAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgbGFzdCBieXRlLCBzaGlmdCBldmVyeXRoaW5nXG4gICAgICBkIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICByaWdodCB1c2luZyBpbnRlZ2VyIG1hdGggdW50aWxcbiAgICAgIHggPj4+PSAxOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHdlIGhhdmUgZXhhY3RseSB0aGUgZGVzaXJlZCBiaXRzLlxuICAgIH1cbiAgICByZXR1cm4gKG4gKyB4KSAvIGQ7ICAgICAgICAgICAgICAgICAvLyBGb3JtIHRoZSBudW1iZXIgd2l0aGluIFswLCAxKS5cbiAgfTtcblxuICBwcm5nLmludDMyID0gZnVuY3Rpb24oKSB7IHJldHVybiBhcmM0LmcoNCkgfCAwOyB9XG4gIHBybmcucXVpY2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFyYzQuZyg0KSAvIDB4MTAwMDAwMDAwOyB9XG4gIHBybmcuZG91YmxlID0gcHJuZztcblxuICAvLyBNaXggdGhlIHJhbmRvbW5lc3MgaW50byBhY2N1bXVsYXRlZCBlbnRyb3B5LlxuICBtaXhrZXkodG9zdHJpbmcoYXJjNC5TKSwgcG9vbCk7XG5cbiAgLy8gQ2FsbGluZyBjb252ZW50aW9uOiB3aGF0IHRvIHJldHVybiBhcyBhIGZ1bmN0aW9uIG9mIHBybmcsIHNlZWQsIGlzX21hdGguXG4gIHJldHVybiAob3B0aW9ucy5wYXNzIHx8IGNhbGxiYWNrIHx8XG4gICAgICBmdW5jdGlvbihwcm5nLCBzZWVkLCBpc19tYXRoX2NhbGwsIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIC8vIExvYWQgdGhlIGFyYzQgc3RhdGUgZnJvbSB0aGUgZ2l2ZW4gc3RhdGUgaWYgaXQgaGFzIGFuIFMgYXJyYXkuXG4gICAgICAgICAgaWYgKHN0YXRlLlMpIHsgY29weShzdGF0ZSwgYXJjNCk7IH1cbiAgICAgICAgICAvLyBPbmx5IHByb3ZpZGUgdGhlIC5zdGF0ZSBtZXRob2QgaWYgcmVxdWVzdGVkIHZpYSBvcHRpb25zLnN0YXRlLlxuICAgICAgICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoYXJjNCwge30pOyB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBjYWxsZWQgYXMgYSBtZXRob2Qgb2YgTWF0aCAoTWF0aC5zZWVkcmFuZG9tKCkpLCBtdXRhdGVcbiAgICAgICAgLy8gTWF0aC5yYW5kb20gYmVjYXVzZSB0aGF0IGlzIGhvdyBzZWVkcmFuZG9tLmpzIGhhcyB3b3JrZWQgc2luY2UgdjEuMC5cbiAgICAgICAgaWYgKGlzX21hdGhfY2FsbCkgeyBtYXRoW3JuZ25hbWVdID0gcHJuZzsgcmV0dXJuIHNlZWQ7IH1cblxuICAgICAgICAvLyBPdGhlcndpc2UsIGl0IGlzIGEgbmV3ZXIgY2FsbGluZyBjb252ZW50aW9uLCBzbyByZXR1cm4gdGhlXG4gICAgICAgIC8vIHBybmcgZGlyZWN0bHkuXG4gICAgICAgIGVsc2UgcmV0dXJuIHBybmc7XG4gICAgICB9KShcbiAgcHJuZyxcbiAgc2hvcnRzZWVkLFxuICAnZ2xvYmFsJyBpbiBvcHRpb25zID8gb3B0aW9ucy5nbG9iYWwgOiAodGhpcyA9PSBtYXRoKSxcbiAgb3B0aW9ucy5zdGF0ZSk7XG59XG5tYXRoWydzZWVkJyArIHJuZ25hbWVdID0gc2VlZHJhbmRvbTtcblxuLy9cbi8vIEFSQzRcbi8vXG4vLyBBbiBBUkM0IGltcGxlbWVudGF0aW9uLiAgVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEga2V5IGluIHRoZSBmb3JtIG9mXG4vLyBhbiBhcnJheSBvZiBhdCBtb3N0ICh3aWR0aCkgaW50ZWdlcnMgdGhhdCBzaG91bGQgYmUgMCA8PSB4IDwgKHdpZHRoKS5cbi8vXG4vLyBUaGUgZyhjb3VudCkgbWV0aG9kIHJldHVybnMgYSBwc2V1ZG9yYW5kb20gaW50ZWdlciB0aGF0IGNvbmNhdGVuYXRlc1xuLy8gdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGZyb20gQVJDNC4gIEl0cyByZXR1cm4gdmFsdWUgaXMgYSBudW1iZXIgeFxuLy8gdGhhdCBpcyBpbiB0aGUgcmFuZ2UgMCA8PSB4IDwgKHdpZHRoIF4gY291bnQpLlxuLy9cbmZ1bmN0aW9uIEFSQzQoa2V5KSB7XG4gIHZhciB0LCBrZXlsZW4gPSBrZXkubGVuZ3RoLFxuICAgICAgbWUgPSB0aGlzLCBpID0gMCwgaiA9IG1lLmkgPSBtZS5qID0gMCwgcyA9IG1lLlMgPSBbXTtcblxuICAvLyBUaGUgZW1wdHkga2V5IFtdIGlzIHRyZWF0ZWQgYXMgWzBdLlxuICBpZiAoIWtleWxlbikgeyBrZXkgPSBba2V5bGVuKytdOyB9XG5cbiAgLy8gU2V0IHVwIFMgdXNpbmcgdGhlIHN0YW5kYXJkIGtleSBzY2hlZHVsaW5nIGFsZ29yaXRobS5cbiAgd2hpbGUgKGkgPCB3aWR0aCkge1xuICAgIHNbaV0gPSBpKys7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICBzW2ldID0gc1tqID0gbWFzayAmIChqICsga2V5W2kgJSBrZXlsZW5dICsgKHQgPSBzW2ldKSldO1xuICAgIHNbal0gPSB0O1xuICB9XG5cbiAgLy8gVGhlIFwiZ1wiIG1ldGhvZCByZXR1cm5zIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBhcyBvbmUgbnVtYmVyLlxuICAobWUuZyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgLy8gVXNpbmcgaW5zdGFuY2UgbWVtYmVycyBpbnN0ZWFkIG9mIGNsb3N1cmUgc3RhdGUgbmVhcmx5IGRvdWJsZXMgc3BlZWQuXG4gICAgdmFyIHQsIHIgPSAwLFxuICAgICAgICBpID0gbWUuaSwgaiA9IG1lLmosIHMgPSBtZS5TO1xuICAgIHdoaWxlIChjb3VudC0tKSB7XG4gICAgICB0ID0gc1tpID0gbWFzayAmIChpICsgMSldO1xuICAgICAgciA9IHIgKiB3aWR0aCArIHNbbWFzayAmICgoc1tpXSA9IHNbaiA9IG1hc2sgJiAoaiArIHQpXSkgKyAoc1tqXSA9IHQpKV07XG4gICAgfVxuICAgIG1lLmkgPSBpOyBtZS5qID0gajtcbiAgICByZXR1cm4gcjtcbiAgICAvLyBGb3Igcm9idXN0IHVucHJlZGljdGFiaWxpdHksIHRoZSBmdW5jdGlvbiBjYWxsIGJlbG93IGF1dG9tYXRpY2FsbHlcbiAgICAvLyBkaXNjYXJkcyBhbiBpbml0aWFsIGJhdGNoIG9mIHZhbHVlcy4gIFRoaXMgaXMgY2FsbGVkIFJDNC1kcm9wWzI1Nl0uXG4gICAgLy8gU2VlIGh0dHA6Ly9nb29nbGUuY29tL3NlYXJjaD9xPXJzYStmbHVocmVyK3Jlc3BvbnNlJmJ0bklcbiAgfSkod2lkdGgpO1xufVxuXG4vL1xuLy8gY29weSgpXG4vLyBDb3BpZXMgaW50ZXJuYWwgc3RhdGUgb2YgQVJDNCB0byBvciBmcm9tIGEgcGxhaW4gb2JqZWN0LlxuLy9cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmkgPSBmLmk7XG4gIHQuaiA9IGYuajtcbiAgdC5TID0gZi5TLnNsaWNlKCk7XG4gIHJldHVybiB0O1xufTtcblxuLy9cbi8vIGZsYXR0ZW4oKVxuLy8gQ29udmVydHMgYW4gb2JqZWN0IHRyZWUgdG8gbmVzdGVkIGFycmF5cyBvZiBzdHJpbmdzLlxuLy9cbmZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBkZXB0aCkge1xuICB2YXIgcmVzdWx0ID0gW10sIHR5cCA9ICh0eXBlb2Ygb2JqKSwgcHJvcDtcbiAgaWYgKGRlcHRoICYmIHR5cCA9PSAnb2JqZWN0Jykge1xuICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgIHRyeSB7IHJlc3VsdC5wdXNoKGZsYXR0ZW4ob2JqW3Byb3BdLCBkZXB0aCAtIDEpKTsgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gIH1cbiAgcmV0dXJuIChyZXN1bHQubGVuZ3RoID8gcmVzdWx0IDogdHlwID09ICdzdHJpbmcnID8gb2JqIDogb2JqICsgJ1xcMCcpO1xufVxuXG4vL1xuLy8gbWl4a2V5KClcbi8vIE1peGVzIGEgc3RyaW5nIHNlZWQgaW50byBhIGtleSB0aGF0IGlzIGFuIGFycmF5IG9mIGludGVnZXJzLCBhbmRcbi8vIHJldHVybnMgYSBzaG9ydGVuZWQgc3RyaW5nIHNlZWQgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSByZXN1bHQga2V5LlxuLy9cbmZ1bmN0aW9uIG1peGtleShzZWVkLCBrZXkpIHtcbiAgdmFyIHN0cmluZ3NlZWQgPSBzZWVkICsgJycsIHNtZWFyLCBqID0gMDtcbiAgd2hpbGUgKGogPCBzdHJpbmdzZWVkLmxlbmd0aCkge1xuICAgIGtleVttYXNrICYgal0gPVxuICAgICAgbWFzayAmICgoc21lYXIgXj0ga2V5W21hc2sgJiBqXSAqIDE5KSArIHN0cmluZ3NlZWQuY2hhckNvZGVBdChqKyspKTtcbiAgfVxuICByZXR1cm4gdG9zdHJpbmcoa2V5KTtcbn1cblxuLy9cbi8vIGF1dG9zZWVkKClcbi8vIFJldHVybnMgYW4gb2JqZWN0IGZvciBhdXRvc2VlZGluZywgdXNpbmcgd2luZG93LmNyeXB0byBhbmQgTm9kZSBjcnlwdG9cbi8vIG1vZHVsZSBpZiBhdmFpbGFibGUuXG4vL1xuZnVuY3Rpb24gYXV0b3NlZWQoKSB7XG4gIHRyeSB7XG4gICAgdmFyIG91dDtcbiAgICBpZiAobm9kZWNyeXB0byAmJiAob3V0ID0gbm9kZWNyeXB0by5yYW5kb21CeXRlcykpIHtcbiAgICAgIC8vIFRoZSB1c2Ugb2YgJ291dCcgdG8gcmVtZW1iZXIgcmFuZG9tQnl0ZXMgbWFrZXMgdGlnaHQgbWluaWZpZWQgY29kZS5cbiAgICAgIG91dCA9IG91dCh3aWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHdpZHRoKTtcbiAgICAgIChnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKG91dCk7XG4gICAgfVxuICAgIHJldHVybiB0b3N0cmluZyhvdXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGJyb3dzZXIgPSBnbG9iYWwubmF2aWdhdG9yLFxuICAgICAgICBwbHVnaW5zID0gYnJvd3NlciAmJiBicm93c2VyLnBsdWdpbnM7XG4gICAgcmV0dXJuIFsrbmV3IERhdGUsIGdsb2JhbCwgcGx1Z2lucywgZ2xvYmFsLnNjcmVlbiwgdG9zdHJpbmcocG9vbCldO1xuICB9XG59XG5cbi8vXG4vLyB0b3N0cmluZygpXG4vLyBDb252ZXJ0cyBhbiBhcnJheSBvZiBjaGFyY29kZXMgdG8gYSBzdHJpbmdcbi8vXG5mdW5jdGlvbiB0b3N0cmluZyhhKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsIGEpO1xufVxuXG4vL1xuLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcbi8vIGZyb20gdGhlIGJ1aWx0LWluIFJORyBpbnRvIHRoZSBlbnRyb3B5IHBvb2wuICBCZWNhdXNlIHdlIGRvXG4vLyBub3Qgd2FudCB0byBpbnRlcmZlcmUgd2l0aCBkZXRlcm1pbmlzdGljIFBSTkcgc3RhdGUgbGF0ZXIsXG4vLyBzZWVkcmFuZG9tIHdpbGwgbm90IGNhbGwgbWF0aC5yYW5kb20gb24gaXRzIG93biBhZ2FpbiBhZnRlclxuLy8gaW5pdGlhbGl6YXRpb24uXG4vL1xubWl4a2V5KG1hdGgucmFuZG9tKCksIHBvb2wpO1xuXG4vL1xuLy8gTm9kZWpzIGFuZCBBTUQgc3VwcG9ydDogZXhwb3J0IHRoZSBpbXBsZW1lbnRhdGlvbiBhcyBhIG1vZHVsZSB1c2luZ1xuLy8gZWl0aGVyIGNvbnZlbnRpb24uXG4vL1xuaWYgKCh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHNlZWRyYW5kb207XG4gIC8vIFdoZW4gaW4gbm9kZS5qcywgdHJ5IHVzaW5nIGNyeXB0byBwYWNrYWdlIGZvciBhdXRvc2VlZGluZy5cbiAgdHJ5IHtcbiAgICBub2RlY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gIH0gY2F0Y2ggKGV4KSB7fVxufSBlbHNlIGlmICgodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIHNlZWRyYW5kb207IH0pO1xufVxuXG4vLyBFbmQgYW5vbnltb3VzIHNjb3BlLCBhbmQgcGFzcyBpbml0aWFsIHZhbHVlcy5cbn0pKFxuICBbXSwgICAgIC8vIHBvb2w6IGVudHJvcHkgcG9vbCBzdGFydHMgZW1wdHlcbiAgTWF0aCAgICAvLyBtYXRoOiBwYWNrYWdlIGNvbnRhaW5pbmcgcmFuZG9tLCBwb3csIGFuZCBzZWVkcmFuZG9tXG4pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/seedrandom/seedrandom.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-define.js":
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function() {\n\tthrow new Error(\"define cannot be used indirect\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2FtZC1kZWZpbmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLWRlZmluZS5qcz9kYThiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG5cdHRocm93IG5ldyBFcnJvcihcImRlZmluZSBjYW5ub3QgYmUgdXNlZCBpbmRpcmVjdFwiKTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/amd-define.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2FtZC1vcHRpb25zLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzPzAwODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/amd-options.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL21vZHVsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanM/Y2VkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ 0:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9jcnlwdG8gKGlnbm9yZWQpP2I2NTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKGlnbm9yZWQpICovIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ })

/******/ });
